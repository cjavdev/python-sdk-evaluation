"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .fleetdeviceobjectresponsebody import (
    FleetDeviceObjectResponseBody,
    FleetDeviceObjectResponseBodyTypedDict,
)
from .industrialassetobjectresponsebody import (
    IndustrialAssetObjectResponseBody,
    IndustrialAssetObjectResponseBodyTypedDict,
)
from .joblocationresponseobjectresponsebody import (
    JobLocationResponseObjectResponseBody,
    JobLocationResponseObjectResponseBodyTypedDict,
)
from enum import Enum
import pydantic
from samsara.types import BaseModel
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class JobResponseObjectResponseBodyStatus(str, Enum):
    r"""The current job status  Valid values: `active`, `scheduled`, `completed`"""

    ACTIVE = "active"
    SCHEDULED = "scheduled"
    COMPLETED = "completed"


class JobResponseObjectResponseBodyTypedDict(TypedDict):
    r"""Job object to be passed back"""

    address: JobLocationResponseObjectResponseBodyTypedDict
    r"""jobLocation object"""
    created_at: str
    r"""When the job was created"""
    customer_name: str
    r"""Customer name for job"""
    end_date: str
    r"""End date of job in RFC 3339 format"""
    id: str
    r"""Job id"""
    modified_at: str
    r"""When the job was last modified"""
    name: str
    r"""Job name"""
    notes: str
    r"""Notes for the upcoming job"""
    start_date: str
    r"""Start date of job in RFC 3339 format"""
    status: JobResponseObjectResponseBodyStatus
    r"""The current job status  Valid values: `active`, `scheduled`, `completed`"""
    uuid: str
    r"""Samsara uuid"""
    fleet_devices: NotRequired[List[FleetDeviceObjectResponseBodyTypedDict]]
    r"""fleet devices in this job (cannot have both industrial assets and fleet devices in the same job)"""
    industrial_assets: NotRequired[List[IndustrialAssetObjectResponseBodyTypedDict]]
    r"""Industrial Assets in this job (cannot have both industrial assets and fleet devices in the same job)"""
    ontime_window_after_arrival_ms: NotRequired[int]
    r"""Specifies the time window (in milliseconds) after a stop's scheduled arrival time during which the stop is considered 'on-time'."""
    ontime_window_before_arrival_ms: NotRequired[int]
    r"""Specifies the time window (in milliseconds) before a stop's scheduled arrival time during which the stop is considered 'on-time'."""


class JobResponseObjectResponseBody(BaseModel):
    r"""Job object to be passed back"""

    address: JobLocationResponseObjectResponseBody
    r"""jobLocation object"""

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]
    r"""When the job was created"""

    customer_name: Annotated[str, pydantic.Field(alias="customerName")]
    r"""Customer name for job"""

    end_date: Annotated[str, pydantic.Field(alias="endDate")]
    r"""End date of job in RFC 3339 format"""

    id: str
    r"""Job id"""

    modified_at: Annotated[str, pydantic.Field(alias="modifiedAt")]
    r"""When the job was last modified"""

    name: str
    r"""Job name"""

    notes: str
    r"""Notes for the upcoming job"""

    start_date: Annotated[str, pydantic.Field(alias="startDate")]
    r"""Start date of job in RFC 3339 format"""

    status: JobResponseObjectResponseBodyStatus
    r"""The current job status  Valid values: `active`, `scheduled`, `completed`"""

    uuid: str
    r"""Samsara uuid"""

    fleet_devices: Annotated[
        Optional[List[FleetDeviceObjectResponseBody]],
        pydantic.Field(alias="fleetDevices"),
    ] = None
    r"""fleet devices in this job (cannot have both industrial assets and fleet devices in the same job)"""

    industrial_assets: Annotated[
        Optional[List[IndustrialAssetObjectResponseBody]],
        pydantic.Field(alias="industrialAssets"),
    ] = None
    r"""Industrial Assets in this job (cannot have both industrial assets and fleet devices in the same job)"""

    ontime_window_after_arrival_ms: Annotated[
        Optional[int], pydantic.Field(alias="ontimeWindowAfterArrivalMs")
    ] = None
    r"""Specifies the time window (in milliseconds) after a stop's scheduled arrival time during which the stop is considered 'on-time'."""

    ontime_window_before_arrival_ms: Annotated[
        Optional[int], pydantic.Field(alias="ontimeWindowBeforeArrivalMs")
    ] = None
    r"""Specifies the time window (in milliseconds) before a stop's scheduled arrival time during which the stop is considered 'on-time'."""
