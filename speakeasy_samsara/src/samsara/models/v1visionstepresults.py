"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from enum import Enum
import pydantic
from samsara.types import BaseModel
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class AngleConfiguredTypedDict(TypedDict):
    r"""The configured angle allowance range (in degrees)"""

    high: NotRequired[int]
    low: NotRequired[int]


class AngleConfigured(BaseModel):
    r"""The configured angle allowance range (in degrees)"""

    high: Optional[int] = None

    low: Optional[int] = None


class AngleCheckTypedDict(TypedDict):
    angle_configured: NotRequired[AngleConfiguredTypedDict]
    r"""The configured angle allowance range (in degrees)"""
    angle_found: NotRequired[int]
    r"""The counter-clockwise angle detected from the first edge to the second edge"""
    end_step_name: NotRequired[str]
    r"""The name of the second reference step used to check the angle"""
    start_step_name: NotRequired[str]
    r"""The name of the first reference step used to check the angle"""


class AngleCheck(BaseModel):
    angle_configured: Annotated[
        Optional[AngleConfigured], pydantic.Field(alias="angleConfigured")
    ] = None
    r"""The configured angle allowance range (in degrees)"""

    angle_found: Annotated[Optional[int], pydantic.Field(alias="angleFound")] = None
    r"""The counter-clockwise angle detected from the first edge to the second edge"""

    end_step_name: Annotated[Optional[str], pydantic.Field(alias="endStepName")] = None
    r"""The name of the second reference step used to check the angle"""

    start_step_name: Annotated[Optional[str], pydantic.Field(alias="startStepName")] = (
        None
    )
    r"""The name of the first reference step used to check the angle"""


class BarcodeTypedDict(TypedDict):
    contents: NotRequired[str]
    match_string: NotRequired[str]
    type: NotRequired[str]


class Barcode(BaseModel):
    contents: Optional[str] = None

    match_string: Annotated[Optional[str], pydantic.Field(alias="matchString")] = None

    type: Optional[str] = None


class StepsTypedDict(TypedDict):
    name: NotRequired[str]
    result: NotRequired[str]


class Steps(BaseModel):
    name: Optional[str] = None

    result: Optional[str] = None


class BooleanLogicTypedDict(TypedDict):
    operator: NotRequired[str]
    steps: NotRequired[List[StepsTypedDict]]


class BooleanLogic(BaseModel):
    operator: Optional[str] = None

    steps: Optional[List[Steps]] = None


class AngleRangeTypedDict(TypedDict):
    r"""The configured angle allowance range"""

    high: NotRequired[int]
    low: NotRequired[int]


class AngleRange(BaseModel):
    r"""The configured angle allowance range"""

    high: Optional[int] = None

    low: Optional[int] = None


class ContrastRangeTypedDict(TypedDict):
    r"""The configured contrast allowance range"""

    high: NotRequired[int]
    low: NotRequired[int]


class ContrastRange(BaseModel):
    r"""The configured contrast allowance range"""

    high: Optional[int] = None

    low: Optional[int] = None


class FilterPolarity(str, Enum):
    r"""The configured polarity for finding edges. Valid values: `LIGHT TO DARK`, `DARK TO LIGHT`."""

    LIGHT_TO_DARK = "LIGHT TO DARK"
    DARK_TO_LIGHT = "DARK TO LIGHT"


class SharpnessRangeTypedDict(TypedDict):
    r"""The configured sharpness allowance range"""

    high: NotRequired[int]
    low: NotRequired[int]


class SharpnessRange(BaseModel):
    r"""The configured sharpness allowance range"""

    high: Optional[int] = None

    low: Optional[int] = None


class StraightnessRangeTypedDict(TypedDict):
    r"""The configured straightness allowance range"""

    high: NotRequired[int]
    low: NotRequired[int]


class StraightnessRange(BaseModel):
    r"""The configured straightness allowance range"""

    high: Optional[int] = None

    low: Optional[int] = None


class CaliperTypedDict(TypedDict):
    angle_range: NotRequired[AngleRangeTypedDict]
    r"""The configured angle allowance range"""
    contrast_range: NotRequired[ContrastRangeTypedDict]
    r"""The configured contrast allowance range"""
    distance_found: NotRequired[float]
    r"""The distance found between the found edges"""
    filter_polarity: NotRequired[FilterPolarity]
    r"""The configured polarity for finding edges. Valid values: `LIGHT TO DARK`, `DARK TO LIGHT`."""
    max_distance: NotRequired[float]
    r"""The maximum allowed distance threshold"""
    min_distance: NotRequired[float]
    r"""The minumum allowed distance threshold"""
    sharpness_range: NotRequired[SharpnessRangeTypedDict]
    r"""The configured sharpness allowance range"""
    straightness_range: NotRequired[StraightnessRangeTypedDict]
    r"""The configured straightness allowance range"""
    unit: NotRequired[str]
    r"""The measurement unit of the distance found and the min and max distance threshold"""


class Caliper(BaseModel):
    angle_range: Annotated[Optional[AngleRange], pydantic.Field(alias="angleRange")] = (
        None
    )
    r"""The configured angle allowance range"""

    contrast_range: Annotated[
        Optional[ContrastRange], pydantic.Field(alias="contrastRange")
    ] = None
    r"""The configured contrast allowance range"""

    distance_found: Annotated[
        Optional[float], pydantic.Field(alias="distanceFound")
    ] = None
    r"""The distance found between the found edges"""

    filter_polarity: Annotated[
        Optional[FilterPolarity], pydantic.Field(alias="filterPolarity")
    ] = FilterPolarity.LIGHT_TO_DARK
    r"""The configured polarity for finding edges. Valid values: `LIGHT TO DARK`, `DARK TO LIGHT`."""

    max_distance: Annotated[Optional[float], pydantic.Field(alias="maxDistance")] = None
    r"""The maximum allowed distance threshold"""

    min_distance: Annotated[Optional[float], pydantic.Field(alias="minDistance")] = None
    r"""The minumum allowed distance threshold"""

    sharpness_range: Annotated[
        Optional[SharpnessRange], pydantic.Field(alias="sharpnessRange")
    ] = None
    r"""The configured sharpness allowance range"""

    straightness_range: Annotated[
        Optional[StraightnessRange], pydantic.Field(alias="straightnessRange")
    ] = None
    r"""The configured straightness allowance range"""

    unit: Optional[str] = None
    r"""The measurement unit of the distance found and the min and max distance threshold"""


class ContourTypedDict(TypedDict):
    angle_degrees: NotRequired[int]
    r"""The rotation angle found"""
    angle_tolerance: NotRequired[int]
    r"""The rotation angle allowance"""
    match_percentage: NotRequired[int]
    r"""The contour match percentage with the configured contour"""
    match_threshold: NotRequired[int]
    r"""The configured match threshold for contours"""


class Contour(BaseModel):
    angle_degrees: Annotated[Optional[int], pydantic.Field(alias="angleDegrees")] = None
    r"""The rotation angle found"""

    angle_tolerance: Annotated[
        Optional[int], pydantic.Field(alias="angleTolerance")
    ] = None
    r"""The rotation angle allowance"""

    match_percentage: Annotated[
        Optional[int], pydantic.Field(alias="matchPercentage")
    ] = None
    r"""The contour match percentage with the configured contour"""

    match_threshold: Annotated[
        Optional[int], pydantic.Field(alias="matchThreshold")
    ] = None
    r"""The configured match threshold for contours"""


class DistanceTypedDict(TypedDict):
    distance_found: NotRequired[int]
    r"""The distance found between the start and end references"""
    end_step_name: NotRequired[str]
    r"""The name of the second reference step that we're checking the distances between"""
    enforce_offset_angle_range: NotRequired[bool]
    r"""Whether an offset angle range is enforced"""
    max_distance: NotRequired[int]
    r"""The maximum allowed distance threshold"""
    max_offset_angle: NotRequired[int]
    r"""The maximum angle allowance (in degrees) if enforceOffsetAngleRange is true"""
    min_distance: NotRequired[int]
    r"""The minumum allowed distance threshold"""
    min_offset_angle: NotRequired[int]
    r"""The minimum angle allowance (in degrees) if enforceOffsetAngleRange is true"""
    offset_angle_found: NotRequired[int]
    r"""The counter-clockwise angle (in degrees) found between the horizontal axis of the start reference step and the last"""
    start_step_name: NotRequired[str]
    r"""The name of the first reference step that we're checking the distances between"""
    unit: NotRequired[str]
    r"""The measurement unit of the distance found and the min and max distance threshold"""


class Distance(BaseModel):
    distance_found: Annotated[Optional[int], pydantic.Field(alias="distanceFound")] = (
        None
    )
    r"""The distance found between the start and end references"""

    end_step_name: Annotated[Optional[str], pydantic.Field(alias="endStepName")] = None
    r"""The name of the second reference step that we're checking the distances between"""

    enforce_offset_angle_range: Annotated[
        Optional[bool], pydantic.Field(alias="enforceOffsetAngleRange")
    ] = None
    r"""Whether an offset angle range is enforced"""

    max_distance: Annotated[Optional[int], pydantic.Field(alias="maxDistance")] = None
    r"""The maximum allowed distance threshold"""

    max_offset_angle: Annotated[
        Optional[int], pydantic.Field(alias="maxOffsetAngle")
    ] = None
    r"""The maximum angle allowance (in degrees) if enforceOffsetAngleRange is true"""

    min_distance: Annotated[Optional[int], pydantic.Field(alias="minDistance")] = None
    r"""The minumum allowed distance threshold"""

    min_offset_angle: Annotated[
        Optional[int], pydantic.Field(alias="minOffsetAngle")
    ] = None
    r"""The minimum angle allowance (in degrees) if enforceOffsetAngleRange is true"""

    offset_angle_found: Annotated[
        Optional[int], pydantic.Field(alias="offsetAngleFound")
    ] = None
    r"""The counter-clockwise angle (in degrees) found between the horizontal axis of the start reference step and the last"""

    start_step_name: Annotated[Optional[str], pydantic.Field(alias="startStepName")] = (
        None
    )
    r"""The name of the first reference step that we're checking the distances between"""

    unit: Optional[str] = None
    r"""The measurement unit of the distance found and the min and max distance threshold"""


class ExpirationDateTypedDict(TypedDict):
    date_offset: NotRequired[int]
    found_date: NotRequired[str]
    match_date: NotRequired[str]


class ExpirationDate(BaseModel):
    date_offset: Annotated[Optional[int], pydantic.Field(alias="dateOffset")] = None

    found_date: Annotated[Optional[str], pydantic.Field(alias="foundDate")] = None

    match_date: Annotated[Optional[str], pydantic.Field(alias="matchDate")] = None


class FindCopiesTypedDict(TypedDict):
    angle_tolerance: NotRequired[int]
    r"""The orientation angle tolerance (+/- °)"""
    found_count: NotRequired[int]
    r"""The number of copies found"""
    max_count: NotRequired[int]
    r"""The maximum number of copies allowed"""
    min_count: NotRequired[int]
    r"""The minimum number of copies allowed"""
    threshold: NotRequired[int]
    r"""The minimum required similarity (in %) of a found copy compared to the configured match region"""


class FindCopies(BaseModel):
    angle_tolerance: Annotated[
        Optional[int], pydantic.Field(alias="angleTolerance")
    ] = None
    r"""The orientation angle tolerance (+/- °)"""

    found_count: Annotated[Optional[int], pydantic.Field(alias="foundCount")] = None
    r"""The number of copies found"""

    max_count: Annotated[Optional[int], pydantic.Field(alias="maxCount")] = None
    r"""The maximum number of copies allowed"""

    min_count: Annotated[Optional[int], pydantic.Field(alias="minCount")] = None
    r"""The minimum number of copies allowed"""

    threshold: Optional[int] = None
    r"""The minimum required similarity (in %) of a found copy compared to the configured match region"""


class V1VisionStepResultsAngleRangeTypedDict(TypedDict):
    r"""The configured angle allowance range"""

    high: NotRequired[int]
    low: NotRequired[int]


class V1VisionStepResultsAngleRange(BaseModel):
    r"""The configured angle allowance range"""

    high: Optional[int] = None

    low: Optional[int] = None


class V1VisionStepResultsContrastRangeTypedDict(TypedDict):
    r"""The configured contrast allowance range"""

    high: NotRequired[int]
    low: NotRequired[int]


class V1VisionStepResultsContrastRange(BaseModel):
    r"""The configured contrast allowance range"""

    high: Optional[int] = None

    low: Optional[int] = None


class V1VisionStepResultsSharpnessRangeTypedDict(TypedDict):
    r"""The configured sharpness allowance range"""

    high: NotRequired[int]
    low: NotRequired[int]


class V1VisionStepResultsSharpnessRange(BaseModel):
    r"""The configured sharpness allowance range"""

    high: Optional[int] = None

    low: Optional[int] = None


class V1VisionStepResultsStraightnessRangeTypedDict(TypedDict):
    r"""The configured straightness allowance range"""

    high: NotRequired[int]
    low: NotRequired[int]


class V1VisionStepResultsStraightnessRange(BaseModel):
    r"""The configured straightness allowance range"""

    high: Optional[int] = None

    low: Optional[int] = None


class FindEdgeTypedDict(TypedDict):
    angle_found: NotRequired[int]
    r"""The detected angle in degrees"""
    angle_range: NotRequired[V1VisionStepResultsAngleRangeTypedDict]
    r"""The configured angle allowance range"""
    contrast_percent: NotRequired[int]
    r"""The detected contrast percentage"""
    contrast_range: NotRequired[V1VisionStepResultsContrastRangeTypedDict]
    r"""The configured contrast allowance range"""
    filter_polarity: NotRequired[str]
    r"""The configured polarity for finding edges. Valid values: `LIGHT TO DARK`, `DARK TO LIGHT`."""
    sharpness_percent: NotRequired[int]
    r"""The detected sharpness percentage"""
    sharpness_range: NotRequired[V1VisionStepResultsSharpnessRangeTypedDict]
    r"""The configured sharpness allowance range"""
    straightness_found: NotRequired[int]
    r"""The detected straightness percentage"""
    straightness_range: NotRequired[V1VisionStepResultsStraightnessRangeTypedDict]
    r"""The configured straightness allowance range"""


class FindEdge(BaseModel):
    angle_found: Annotated[Optional[int], pydantic.Field(alias="angleFound")] = None
    r"""The detected angle in degrees"""

    angle_range: Annotated[
        Optional[V1VisionStepResultsAngleRange], pydantic.Field(alias="angleRange")
    ] = None
    r"""The configured angle allowance range"""

    contrast_percent: Annotated[
        Optional[int], pydantic.Field(alias="contrastPercent")
    ] = None
    r"""The detected contrast percentage"""

    contrast_range: Annotated[
        Optional[V1VisionStepResultsContrastRange],
        pydantic.Field(alias="contrastRange"),
    ] = None
    r"""The configured contrast allowance range"""

    filter_polarity: Annotated[
        Optional[str], pydantic.Field(alias="filterPolarity")
    ] = None
    r"""The configured polarity for finding edges. Valid values: `LIGHT TO DARK`, `DARK TO LIGHT`."""

    sharpness_percent: Annotated[
        Optional[int], pydantic.Field(alias="sharpnessPercent")
    ] = None
    r"""The detected sharpness percentage"""

    sharpness_range: Annotated[
        Optional[V1VisionStepResultsSharpnessRange],
        pydantic.Field(alias="sharpnessRange"),
    ] = None
    r"""The configured sharpness allowance range"""

    straightness_found: Annotated[
        Optional[int], pydantic.Field(alias="straightnessFound")
    ] = None
    r"""The detected straightness percentage"""

    straightness_range: Annotated[
        Optional[V1VisionStepResultsStraightnessRange],
        pydantic.Field(alias="straightnessRange"),
    ] = None
    r"""The configured straightness allowance range"""


class FindShapesTypedDict(TypedDict):
    found_count: NotRequired[int]
    max_count: NotRequired[int]
    min_count: NotRequired[int]


class FindShapes(BaseModel):
    found_count: Annotated[Optional[int], pydantic.Field(alias="foundCount")] = None

    max_count: Annotated[Optional[int], pydantic.Field(alias="maxCount")] = None

    min_count: Annotated[Optional[int], pydantic.Field(alias="minCount")] = None


class CoordinatesTypedDict(TypedDict):
    x: NotRequired[int]
    y: NotRequired[int]


class Coordinates(BaseModel):
    x: Optional[int] = None

    y: Optional[int] = None


class FixtureTypedDict(TypedDict):
    coordinates: NotRequired[CoordinatesTypedDict]
    found: NotRequired[bool]
    rotation_degrees: NotRequired[int]


class Fixture(BaseModel):
    coordinates: Optional[Coordinates] = None

    found: Optional[bool] = None

    rotation_degrees: Annotated[
        Optional[int], pydantic.Field(alias="rotationDegrees")
    ] = None


class LabelMatchTypedDict(TypedDict):
    score: NotRequired[int]
    threshold: NotRequired[int]


class LabelMatch(BaseModel):
    score: Optional[int] = None

    threshold: Optional[int] = None


class BlueRangeTypedDict(TypedDict):
    high: NotRequired[int]
    low: NotRequired[int]


class BlueRange(BaseModel):
    high: Optional[int] = None

    low: Optional[int] = None


class GrayscaleRangeTypedDict(TypedDict):
    high: NotRequired[int]
    low: NotRequired[int]


class GrayscaleRange(BaseModel):
    high: Optional[int] = None

    low: Optional[int] = None


class GreenRangeTypedDict(TypedDict):
    high: NotRequired[int]
    low: NotRequired[int]


class GreenRange(BaseModel):
    high: Optional[int] = None

    low: Optional[int] = None


class HueRangeTypedDict(TypedDict):
    high: NotRequired[int]
    low: NotRequired[int]


class HueRange(BaseModel):
    high: Optional[int] = None

    low: Optional[int] = None


class RedRangeTypedDict(TypedDict):
    high: NotRequired[int]
    low: NotRequired[int]


class RedRange(BaseModel):
    high: Optional[int] = None

    low: Optional[int] = None


class SaturationRangeTypedDict(TypedDict):
    high: NotRequired[int]
    low: NotRequired[int]


class SaturationRange(BaseModel):
    high: Optional[int] = None

    low: Optional[int] = None


class ValueRangeTypedDict(TypedDict):
    high: NotRequired[int]
    low: NotRequired[int]


class ValueRange(BaseModel):
    high: Optional[int] = None

    low: Optional[int] = None


class PresenceAbsenceTypedDict(TypedDict):
    blue_range: NotRequired[BlueRangeTypedDict]
    check_for_absence: NotRequired[bool]
    grayscale_range: NotRequired[GrayscaleRangeTypedDict]
    green_range: NotRequired[GreenRangeTypedDict]
    hue_range: NotRequired[HueRangeTypedDict]
    red_range: NotRequired[RedRangeTypedDict]
    saturation_range: NotRequired[SaturationRangeTypedDict]
    score: NotRequired[int]
    threshold: NotRequired[int]
    value_range: NotRequired[ValueRangeTypedDict]


class PresenceAbsence(BaseModel):
    blue_range: Annotated[Optional[BlueRange], pydantic.Field(alias="blueRange")] = None

    check_for_absence: Annotated[
        Optional[bool], pydantic.Field(alias="checkForAbsence")
    ] = None

    grayscale_range: Annotated[
        Optional[GrayscaleRange], pydantic.Field(alias="grayscaleRange")
    ] = None

    green_range: Annotated[Optional[GreenRange], pydantic.Field(alias="greenRange")] = (
        None
    )

    hue_range: Annotated[Optional[HueRange], pydantic.Field(alias="hueRange")] = None

    red_range: Annotated[Optional[RedRange], pydantic.Field(alias="redRange")] = None

    saturation_range: Annotated[
        Optional[SaturationRange], pydantic.Field(alias="saturationRange")
    ] = None

    score: Optional[int] = None

    threshold: Optional[int] = None

    value_range: Annotated[Optional[ValueRange], pydantic.Field(alias="valueRange")] = (
        None
    )


class TextMatchTypedDict(TypedDict):
    found_text: NotRequired[str]
    match_string: NotRequired[str]


class TextMatch(BaseModel):
    found_text: Annotated[Optional[str], pydantic.Field(alias="foundText")] = None

    match_string: Annotated[Optional[str], pydantic.Field(alias="matchString")] = None


class V1VisionStepResultsTypedDict(TypedDict):
    angle_check: NotRequired[AngleCheckTypedDict]
    barcode: NotRequired[List[BarcodeTypedDict]]
    boolean_logic: NotRequired[BooleanLogicTypedDict]
    caliper: NotRequired[CaliperTypedDict]
    contour: NotRequired[ContourTypedDict]
    distance: NotRequired[DistanceTypedDict]
    expiration_date: NotRequired[ExpirationDateTypedDict]
    find_copies: NotRequired[FindCopiesTypedDict]
    find_edge: NotRequired[FindEdgeTypedDict]
    find_shapes: NotRequired[FindShapesTypedDict]
    fixture: NotRequired[FixtureTypedDict]
    label_match: NotRequired[LabelMatchTypedDict]
    name: NotRequired[str]
    presence_absence: NotRequired[PresenceAbsenceTypedDict]
    result: NotRequired[str]
    text_match: NotRequired[TextMatchTypedDict]


class V1VisionStepResults(BaseModel):
    angle_check: Annotated[Optional[AngleCheck], pydantic.Field(alias="angleCheck")] = (
        None
    )

    barcode: Optional[List[Barcode]] = None

    boolean_logic: Annotated[
        Optional[BooleanLogic], pydantic.Field(alias="booleanLogic")
    ] = None

    caliper: Optional[Caliper] = None

    contour: Optional[Contour] = None

    distance: Optional[Distance] = None

    expiration_date: Annotated[
        Optional[ExpirationDate], pydantic.Field(alias="expirationDate")
    ] = None

    find_copies: Annotated[Optional[FindCopies], pydantic.Field(alias="findCopies")] = (
        None
    )

    find_edge: Annotated[Optional[FindEdge], pydantic.Field(alias="findEdge")] = None

    find_shapes: Annotated[Optional[FindShapes], pydantic.Field(alias="findShapes")] = (
        None
    )

    fixture: Optional[Fixture] = None

    label_match: Annotated[Optional[LabelMatch], pydantic.Field(alias="labelMatch")] = (
        None
    )

    name: Optional[str] = None

    presence_absence: Annotated[
        Optional[PresenceAbsence], pydantic.Field(alias="presenceAbsence")
    ] = None

    result: Optional[str] = None

    text_match: Annotated[Optional[TextMatch], pydantic.Field(alias="textMatch")] = None
