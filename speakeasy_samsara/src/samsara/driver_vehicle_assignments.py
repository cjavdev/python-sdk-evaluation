"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from samsara import models, utils
from samsara._hooks import HookContext
from samsara.types import OptionalNullable, UNSET
from samsara.utils import get_security_from_env
from typing import Any, List, Mapping, Optional, Union


class DriverVehicleAssignments(BaseSDK):
    def delete_driver_vehicle_assignments(
        self,
        *,
        vehicle_id: str,
        assigned_at_time: Optional[str] = None,
        end_time: Optional[str] = None,
        is_passenger: Optional[bool] = None,
        start_time: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[
        models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsBadRequestErrorResponseBody
    ]:
        r"""Delete API generated driver-vehicle assignments

        Delete driver assignments that were created using the `POST fleet/driver-vehicle-assignments` endpoint for the requested vehicle in the requested time range.

        <b>Rate limit:</b> 100 requests/min (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write Assignments** under the Assignments category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param vehicle_id: ID of the vehicle. This can be either a unique Samsara ID or an [external ID](https://developers.samsara.com/docs/external-ids) for the vehicle.
        :param assigned_at_time: Assigned at time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param end_time: An end time in RFC 3339 format. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param is_passenger: Indicates if assigned driver is passenger
        :param start_time: A start time in RFC 3339 format. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = (
            models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsRequestBody(
                assigned_at_time=assigned_at_time,
                end_time=end_time,
                is_passenger=is_passenger,
                start_time=start_time,
                vehicle_id=vehicle_id,
            )
        )

        req = self._build_request(
            method="DELETE",
            path="/fleet/driver-vehicle-assignments",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request,
                False,
                False,
                "json",
                models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="deleteDriverVehicleAssignments",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "204", "*"):
            return None
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsUnauthorizedErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsNotFoundErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsMethodNotAllowedErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsTooManyRequestsErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsInternalServerErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsNotImplementedErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsBadGatewayErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsServiceUnavailableErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsGatewayTimeoutErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def delete_driver_vehicle_assignments_async(
        self,
        *,
        vehicle_id: str,
        assigned_at_time: Optional[str] = None,
        end_time: Optional[str] = None,
        is_passenger: Optional[bool] = None,
        start_time: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[
        models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsBadRequestErrorResponseBody
    ]:
        r"""Delete API generated driver-vehicle assignments

        Delete driver assignments that were created using the `POST fleet/driver-vehicle-assignments` endpoint for the requested vehicle in the requested time range.

        <b>Rate limit:</b> 100 requests/min (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write Assignments** under the Assignments category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param vehicle_id: ID of the vehicle. This can be either a unique Samsara ID or an [external ID](https://developers.samsara.com/docs/external-ids) for the vehicle.
        :param assigned_at_time: Assigned at time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param end_time: An end time in RFC 3339 format. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param is_passenger: Indicates if assigned driver is passenger
        :param start_time: A start time in RFC 3339 format. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = (
            models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsRequestBody(
                assigned_at_time=assigned_at_time,
                end_time=end_time,
                is_passenger=is_passenger,
                start_time=start_time,
                vehicle_id=vehicle_id,
            )
        )

        req = self._build_request_async(
            method="DELETE",
            path="/fleet/driver-vehicle-assignments",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request,
                False,
                False,
                "json",
                models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="deleteDriverVehicleAssignments",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "204", "*"):
            return None
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsUnauthorizedErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsNotFoundErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsMethodNotAllowedErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsTooManyRequestsErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsInternalServerErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsNotImplementedErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsBadGatewayErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsServiceUnavailableErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsGatewayTimeoutErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2DeleteDriverVehicleAssignmentsBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_driver_vehicle_assignments(
        self,
        *,
        filter_by: models.FilterBy,
        start_time: Optional[str] = None,
        end_time: Optional[str] = None,
        driver_ids: Optional[List[str]] = None,
        vehicle_ids: Optional[List[str]] = None,
        driver_tag_ids: Optional[str] = None,
        vehicle_tag_ids: Optional[str] = None,
        after: Optional[str] = None,
        assignment_type: Optional[models.QueryParamAssignmentType] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetDriverVehicleAssignmentsResponse:
        r"""Get all driver-vehicle assignments

        Get all driver-vehicle assignments for the requested drivers or vehicles in the requested time range. To fetch driver-vehicle assignments out of the vehicle trips' time ranges, assignmentType needs to be specified. Note: this endpoint replaces past endpoints to fetch assignments by driver or by vehicle. Visit [this migration guide](https://developers.samsara.com/docs/migrating-from-driver-vehicle-assignment-or-vehicle-driver-assignment-endpoints) for more information.

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Assignments** under the Assignments category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param filter_by: Option to filter by drivers or vehicles.  Valid values: `drivers`, `vehicles`
        :param start_time: A start time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param end_time: An end time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param driver_ids: A filter on the data based on this comma-separated list of driver IDs and externalIds. Example: `driverIds=1234,5678,payroll:4841`
        :param vehicle_ids: ID of the vehicle. This can either be the Samsara-specified ID, or an external ID. External IDs are customer specified key-value pairs created in the POST or PATCH requests of this resource. To specify an external ID as part of a path parameter, use the following format: \"key:value\". For example, \"maintenanceId:250020\".
        :param driver_tag_ids: A filter on the data based on this comma-separated list of driver tag IDs. Example: `tagIds=1234,5678`
        :param vehicle_tag_ids: A filter on the data based on this comma-separated list of vehicle tag IDs. Example: `tagIds=1234,5678`
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param assignment_type: Specifies which assignment type to filter by.  Valid values: `HOS`, `idCard`, `static`, `faceId`, `tachograph`, `safetyManual`, `RFID`, `trailer`, `external`, `qrCode`
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetDriverVehicleAssignmentsRequest(
            filter_by=filter_by,
            start_time=start_time,
            end_time=end_time,
            driver_ids=driver_ids,
            vehicle_ids=vehicle_ids,
            driver_tag_ids=driver_tag_ids,
            vehicle_tag_ids=vehicle_tag_ids,
            after=after,
            assignment_type=assignment_type,
        )

        req = self._build_request(
            method="GET",
            path="/fleet/driver-vehicle-assignments",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getDriverVehicleAssignments",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsResponseBody,
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsUnauthorizedErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsNotFoundErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsMethodNotAllowedErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsTooManyRequestsErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsInternalServerErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsNotImplementedErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsBadGatewayErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsServiceUnavailableErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsGatewayTimeoutErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_driver_vehicle_assignments_async(
        self,
        *,
        filter_by: models.FilterBy,
        start_time: Optional[str] = None,
        end_time: Optional[str] = None,
        driver_ids: Optional[List[str]] = None,
        vehicle_ids: Optional[List[str]] = None,
        driver_tag_ids: Optional[str] = None,
        vehicle_tag_ids: Optional[str] = None,
        after: Optional[str] = None,
        assignment_type: Optional[models.QueryParamAssignmentType] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetDriverVehicleAssignmentsResponse:
        r"""Get all driver-vehicle assignments

        Get all driver-vehicle assignments for the requested drivers or vehicles in the requested time range. To fetch driver-vehicle assignments out of the vehicle trips' time ranges, assignmentType needs to be specified. Note: this endpoint replaces past endpoints to fetch assignments by driver or by vehicle. Visit [this migration guide](https://developers.samsara.com/docs/migrating-from-driver-vehicle-assignment-or-vehicle-driver-assignment-endpoints) for more information.

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Assignments** under the Assignments category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param filter_by: Option to filter by drivers or vehicles.  Valid values: `drivers`, `vehicles`
        :param start_time: A start time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param end_time: An end time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param driver_ids: A filter on the data based on this comma-separated list of driver IDs and externalIds. Example: `driverIds=1234,5678,payroll:4841`
        :param vehicle_ids: ID of the vehicle. This can either be the Samsara-specified ID, or an external ID. External IDs are customer specified key-value pairs created in the POST or PATCH requests of this resource. To specify an external ID as part of a path parameter, use the following format: \"key:value\". For example, \"maintenanceId:250020\".
        :param driver_tag_ids: A filter on the data based on this comma-separated list of driver tag IDs. Example: `tagIds=1234,5678`
        :param vehicle_tag_ids: A filter on the data based on this comma-separated list of vehicle tag IDs. Example: `tagIds=1234,5678`
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param assignment_type: Specifies which assignment type to filter by.  Valid values: `HOS`, `idCard`, `static`, `faceId`, `tachograph`, `safetyManual`, `RFID`, `trailer`, `external`, `qrCode`
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetDriverVehicleAssignmentsRequest(
            filter_by=filter_by,
            start_time=start_time,
            end_time=end_time,
            driver_ids=driver_ids,
            vehicle_ids=vehicle_ids,
            driver_tag_ids=driver_tag_ids,
            vehicle_tag_ids=vehicle_tag_ids,
            after=after,
            assignment_type=assignment_type,
        )

        req = self._build_request_async(
            method="GET",
            path="/fleet/driver-vehicle-assignments",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getDriverVehicleAssignments",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsResponseBody,
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsUnauthorizedErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsNotFoundErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsMethodNotAllowedErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsTooManyRequestsErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsInternalServerErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsNotImplementedErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsBadGatewayErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsServiceUnavailableErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsGatewayTimeoutErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2GetDriverVehicleAssignmentsBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def update_driver_vehicle_assignment(
        self,
        *,
        driver_id: str,
        start_time: str,
        vehicle_id: str,
        assigned_at_time: Optional[str] = None,
        end_time: Optional[str] = None,
        is_passenger: Optional[bool] = None,
        metadata: Optional[
            Union[
                models.PatchDriverVehicleAssignmentsV2RequestBodyMetadataRequestBody,
                models.PatchDriverVehicleAssignmentsV2RequestBodyMetadataRequestBodyTypedDict,
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.UpdateDriverVehicleAssignmentResponse:
        r"""Update API generated driver-vehicle assignments

        Update driver assignments that were created using the `POST fleet/driver-vehicle-assignments`. Vehicle Id, Driver Id, and Start Time must match an existing assignment.

        <b>Rate limit:</b> 100 requests/min (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write Assignments** under the Assignments category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param driver_id: ID of the driver. This can be either a unique Samsara ID or an [external ID](https://developers.samsara.com/docs/external-ids) for the driver.
        :param start_time: The start time in RFC 3339 format. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param vehicle_id: ID of the vehicle. This can be either a unique Samsara ID or an [external ID](https://developers.samsara.com/docs/external-ids) for the vehicle.
        :param assigned_at_time: The time at which the assignment was made in RFC 3339 format. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param end_time: The end time in RFC 3339 format. To make this an ongoing assignment (ie. an assignment with no end time), provide an endTime value of 'null'. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param is_passenger: Is this driver a passenger?
        :param metadata: Metadata about this driver assignment
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentRequestBody(
            assigned_at_time=assigned_at_time,
            driver_id=driver_id,
            end_time=end_time,
            is_passenger=is_passenger,
            metadata=utils.get_pydantic_model(
                metadata,
                Optional[
                    models.PatchDriverVehicleAssignmentsV2RequestBodyMetadataRequestBody
                ],
            ),
            start_time=start_time,
            vehicle_id=vehicle_id,
        )

        req = self._build_request(
            method="PATCH",
            path="/fleet/driver-vehicle-assignments",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request,
                False,
                False,
                "json",
                models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="updateDriverVehicleAssignment",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "202", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentResponseBody,
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentUnauthorizedErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentNotFoundErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentMethodNotAllowedErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentTooManyRequestsErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentInternalServerErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentNotImplementedErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentBadGatewayErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentServiceUnavailableErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentGatewayTimeoutErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def update_driver_vehicle_assignment_async(
        self,
        *,
        driver_id: str,
        start_time: str,
        vehicle_id: str,
        assigned_at_time: Optional[str] = None,
        end_time: Optional[str] = None,
        is_passenger: Optional[bool] = None,
        metadata: Optional[
            Union[
                models.PatchDriverVehicleAssignmentsV2RequestBodyMetadataRequestBody,
                models.PatchDriverVehicleAssignmentsV2RequestBodyMetadataRequestBodyTypedDict,
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.UpdateDriverVehicleAssignmentResponse:
        r"""Update API generated driver-vehicle assignments

        Update driver assignments that were created using the `POST fleet/driver-vehicle-assignments`. Vehicle Id, Driver Id, and Start Time must match an existing assignment.

        <b>Rate limit:</b> 100 requests/min (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write Assignments** under the Assignments category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param driver_id: ID of the driver. This can be either a unique Samsara ID or an [external ID](https://developers.samsara.com/docs/external-ids) for the driver.
        :param start_time: The start time in RFC 3339 format. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param vehicle_id: ID of the vehicle. This can be either a unique Samsara ID or an [external ID](https://developers.samsara.com/docs/external-ids) for the vehicle.
        :param assigned_at_time: The time at which the assignment was made in RFC 3339 format. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param end_time: The end time in RFC 3339 format. To make this an ongoing assignment (ie. an assignment with no end time), provide an endTime value of 'null'. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param is_passenger: Is this driver a passenger?
        :param metadata: Metadata about this driver assignment
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentRequestBody(
            assigned_at_time=assigned_at_time,
            driver_id=driver_id,
            end_time=end_time,
            is_passenger=is_passenger,
            metadata=utils.get_pydantic_model(
                metadata,
                Optional[
                    models.PatchDriverVehicleAssignmentsV2RequestBodyMetadataRequestBody
                ],
            ),
            start_time=start_time,
            vehicle_id=vehicle_id,
        )

        req = self._build_request_async(
            method="PATCH",
            path="/fleet/driver-vehicle-assignments",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request,
                False,
                False,
                "json",
                models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="updateDriverVehicleAssignment",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "202", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentResponseBody,
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentUnauthorizedErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentNotFoundErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentMethodNotAllowedErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentTooManyRequestsErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentInternalServerErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentNotImplementedErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentBadGatewayErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentServiceUnavailableErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentGatewayTimeoutErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2UpdateDriverVehicleAssignmentBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def create_driver_vehicle_assignment(
        self,
        *,
        driver_id: str,
        vehicle_id: str,
        assigned_at_time: Optional[str] = None,
        end_time: Optional[str] = None,
        is_passenger: Optional[bool] = None,
        metadata: Optional[
            Union[
                models.PostDriverVehicleAssignmentsV2RequestBodyMetadataRequestBody,
                models.PostDriverVehicleAssignmentsV2RequestBodyMetadataRequestBodyTypedDict,
            ]
        ] = None,
        start_time: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CreateDriverVehicleAssignmentResponse:
        r"""Create a new driver-vehicle assignment

        Assign vehicle drive-time to a driver via API. For a step-by-step instruction on how to leverage this endpoint, see [this guide](https://developers.samsara.com/docs/creating-driver-vehicle-assignments)

        <b>Rate limit:</b> 100 requests/min (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write Assignments** under the Assignments category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param driver_id: ID of the driver. This can be either a unique Samsara ID or an [external ID](https://developers.samsara.com/docs/external-ids) for the driver.
        :param vehicle_id: ID of the vehicle. This can be either a unique Samsara ID or an [external ID](https://developers.samsara.com/docs/external-ids) for the vehicle.
        :param assigned_at_time: The time at which the assignment was made in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param end_time: The end time in RFC 3339 format. Defaults to max-time (meaning it's an ongoing assignment) if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param is_passenger: Is this driver a passenger? Defaults to false if not provided
        :param metadata: Metadata about this driver assignment
        :param start_time: The start time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentRequestBody(
            assigned_at_time=assigned_at_time,
            driver_id=driver_id,
            end_time=end_time,
            is_passenger=is_passenger,
            metadata=utils.get_pydantic_model(
                metadata,
                Optional[
                    models.PostDriverVehicleAssignmentsV2RequestBodyMetadataRequestBody
                ],
            ),
            start_time=start_time,
            vehicle_id=vehicle_id,
        )

        req = self._build_request(
            method="POST",
            path="/fleet/driver-vehicle-assignments",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request,
                False,
                False,
                "json",
                models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="createDriverVehicleAssignment",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentResponseBody,
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentUnauthorizedErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentNotFoundErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentMethodNotAllowedErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentTooManyRequestsErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentInternalServerErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentNotImplementedErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentBadGatewayErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentServiceUnavailableErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentGatewayTimeoutErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def create_driver_vehicle_assignment_async(
        self,
        *,
        driver_id: str,
        vehicle_id: str,
        assigned_at_time: Optional[str] = None,
        end_time: Optional[str] = None,
        is_passenger: Optional[bool] = None,
        metadata: Optional[
            Union[
                models.PostDriverVehicleAssignmentsV2RequestBodyMetadataRequestBody,
                models.PostDriverVehicleAssignmentsV2RequestBodyMetadataRequestBodyTypedDict,
            ]
        ] = None,
        start_time: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CreateDriverVehicleAssignmentResponse:
        r"""Create a new driver-vehicle assignment

        Assign vehicle drive-time to a driver via API. For a step-by-step instruction on how to leverage this endpoint, see [this guide](https://developers.samsara.com/docs/creating-driver-vehicle-assignments)

        <b>Rate limit:</b> 100 requests/min (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write Assignments** under the Assignments category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param driver_id: ID of the driver. This can be either a unique Samsara ID or an [external ID](https://developers.samsara.com/docs/external-ids) for the driver.
        :param vehicle_id: ID of the vehicle. This can be either a unique Samsara ID or an [external ID](https://developers.samsara.com/docs/external-ids) for the vehicle.
        :param assigned_at_time: The time at which the assignment was made in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param end_time: The end time in RFC 3339 format. Defaults to max-time (meaning it's an ongoing assignment) if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param is_passenger: Is this driver a passenger? Defaults to false if not provided
        :param metadata: Metadata about this driver assignment
        :param start_time: The start time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentRequestBody(
            assigned_at_time=assigned_at_time,
            driver_id=driver_id,
            end_time=end_time,
            is_passenger=is_passenger,
            metadata=utils.get_pydantic_model(
                metadata,
                Optional[
                    models.PostDriverVehicleAssignmentsV2RequestBodyMetadataRequestBody
                ],
            ),
            start_time=start_time,
            vehicle_id=vehicle_id,
        )

        req = self._build_request_async(
            method="POST",
            path="/fleet/driver-vehicle-assignments",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request,
                False,
                False,
                "json",
                models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="createDriverVehicleAssignment",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentResponseBody,
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentUnauthorizedErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentNotFoundErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentMethodNotAllowedErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentTooManyRequestsErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentInternalServerErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentNotImplementedErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentBadGatewayErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentServiceUnavailableErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentGatewayTimeoutErrorResponseBodyData,
            )
            raise models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.DriverVehicleAssignmentsV2CreateDriverVehicleAssignmentBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )
