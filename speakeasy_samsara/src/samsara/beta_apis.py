"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from datetime import datetime
from samsara import models, utils
from samsara._hooks import HookContext
from samsara.types import BaseModel, OptionalNullable, UNSET
from samsara.utils import get_security_from_env
from typing import Any, Dict, List, Mapping, Optional, Union, cast


class BetaAPIs(BaseSDK):
    def delete_asset(
        self,
        *,
        id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.AssetsDeleteAssetBadRequestErrorResponseBody]:
        r"""[beta] Delete an existing asset.

        Delete an existing asset.

        <b>Rate limit:</b> 100 requests/min (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write Assets** under the Assets category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param id: A filter selecting a single asset by id.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.DeleteAssetRequest(
            id=id,
        )

        req = self._build_request(
            method="DELETE",
            path="/assets",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="deleteAsset",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "204", "*"):
            return None
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.AssetsDeleteAssetUnauthorizedErrorResponseBodyData
            )
            raise models.AssetsDeleteAssetUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.AssetsDeleteAssetNotFoundErrorResponseBodyData
            )
            raise models.AssetsDeleteAssetNotFoundErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsDeleteAssetMethodNotAllowedErrorResponseBodyData,
            )
            raise models.AssetsDeleteAssetMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsDeleteAssetTooManyRequestsErrorResponseBodyData,
            )
            raise models.AssetsDeleteAssetTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsDeleteAssetInternalServerErrorResponseBodyData,
            )
            raise models.AssetsDeleteAssetInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsDeleteAssetNotImplementedErrorResponseBodyData,
            )
            raise models.AssetsDeleteAssetNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.AssetsDeleteAssetBadGatewayErrorResponseBodyData
            )
            raise models.AssetsDeleteAssetBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsDeleteAssetServiceUnavailableErrorResponseBodyData,
            )
            raise models.AssetsDeleteAssetServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsDeleteAssetGatewayTimeoutErrorResponseBodyData,
            )
            raise models.AssetsDeleteAssetGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.AssetsDeleteAssetBadRequestErrorResponseBody
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def delete_asset_async(
        self,
        *,
        id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.AssetsDeleteAssetBadRequestErrorResponseBody]:
        r"""[beta] Delete an existing asset.

        Delete an existing asset.

        <b>Rate limit:</b> 100 requests/min (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write Assets** under the Assets category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param id: A filter selecting a single asset by id.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.DeleteAssetRequest(
            id=id,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/assets",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="deleteAsset",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "204", "*"):
            return None
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.AssetsDeleteAssetUnauthorizedErrorResponseBodyData
            )
            raise models.AssetsDeleteAssetUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.AssetsDeleteAssetNotFoundErrorResponseBodyData
            )
            raise models.AssetsDeleteAssetNotFoundErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsDeleteAssetMethodNotAllowedErrorResponseBodyData,
            )
            raise models.AssetsDeleteAssetMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsDeleteAssetTooManyRequestsErrorResponseBodyData,
            )
            raise models.AssetsDeleteAssetTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsDeleteAssetInternalServerErrorResponseBodyData,
            )
            raise models.AssetsDeleteAssetInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsDeleteAssetNotImplementedErrorResponseBodyData,
            )
            raise models.AssetsDeleteAssetNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.AssetsDeleteAssetBadGatewayErrorResponseBodyData
            )
            raise models.AssetsDeleteAssetBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsDeleteAssetServiceUnavailableErrorResponseBodyData,
            )
            raise models.AssetsDeleteAssetServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsDeleteAssetGatewayTimeoutErrorResponseBodyData,
            )
            raise models.AssetsDeleteAssetGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.AssetsDeleteAssetBadRequestErrorResponseBody
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def list_assets(
        self,
        *,
        type_: Optional[models.QueryParamType] = None,
        after: Optional[str] = None,
        updated_after_time: Optional[str] = None,
        include_external_ids: Optional[bool] = None,
        include_tags: Optional[bool] = None,
        tag_ids: Optional[str] = None,
        parent_tag_ids: Optional[str] = None,
        ids: Optional[List[str]] = None,
        attribute_value_ids: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ListAssetsResponse:
        r"""[beta] List all assets.

        List all assets. Up to 300 assets will be returned per page.

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Assets** under the Assets category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param type: The operational context in which the asset interacts with the Samsara system. Examples: Vehicle (eg: truck, bus...), Trailer (eg: dry van, reefer, flatbed...), Powered Equipment (eg: dozer, crane...), Unpowered Equipment (eg: container, dumpster...), or Uncategorized.  Valid values: `uncategorized`, `trailer`, `equipment`, `unpowered`, `vehicle`
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param updated_after_time: A filter on data to have an updated at time after or equal to this specified time in RFC 3339 format. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param include_external_ids: Optional boolean indicating whether to return external IDs on supported entities
        :param include_tags: Optional boolean indicating whether to return tags on supported entities
        :param tag_ids: A filter on the data based on this comma-separated list of tag IDs. Example: `tagIds=1234,5678`
        :param parent_tag_ids: A filter on the data based on this comma-separated list of parent tag IDs, for use by orgs with tag hierarchies. Specifying a parent tag will implicitly include all descendent tags of the parent tag. Example: `parentTagIds=345,678`
        :param ids: A filter on the data based on this comma-separated list of asset IDs and External IDs.
        :param attribute_value_ids: A filter on the data based on this comma-separated list of attribute value IDs. Only entities associated with ALL of the referenced values will be returned (i.e. the intersection of the sets of entities with each value). Example: `attributeValueIds=076efac2-83b5-47aa-ba36-18428436dcac,6707b3f0-23b9-4fe3-b7be-11be34aea544`
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.ListAssetsRequest(
            type=type_,
            after=after,
            updated_after_time=updated_after_time,
            include_external_ids=include_external_ids,
            include_tags=include_tags,
            tag_ids=tag_ids,
            parent_tag_ids=parent_tag_ids,
            ids=ids,
            attribute_value_ids=attribute_value_ids,
        )

        req = self._build_request(
            method="GET",
            path="/assets",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="listAssets",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.AssetsListAssetsResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.AssetsListAssetsUnauthorizedErrorResponseBodyData
            )
            raise models.AssetsListAssetsUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.AssetsListAssetsNotFoundErrorResponseBodyData
            )
            raise models.AssetsListAssetsNotFoundErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsListAssetsMethodNotAllowedErrorResponseBodyData,
            )
            raise models.AssetsListAssetsMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsListAssetsTooManyRequestsErrorResponseBodyData,
            )
            raise models.AssetsListAssetsTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsListAssetsInternalServerErrorResponseBodyData,
            )
            raise models.AssetsListAssetsInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsListAssetsNotImplementedErrorResponseBodyData,
            )
            raise models.AssetsListAssetsNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.AssetsListAssetsBadGatewayErrorResponseBodyData
            )
            raise models.AssetsListAssetsBadGatewayErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsListAssetsServiceUnavailableErrorResponseBodyData,
            )
            raise models.AssetsListAssetsServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsListAssetsGatewayTimeoutErrorResponseBodyData,
            )
            raise models.AssetsListAssetsGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.AssetsListAssetsBadRequestErrorResponseBody
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def list_assets_async(
        self,
        *,
        type_: Optional[models.QueryParamType] = None,
        after: Optional[str] = None,
        updated_after_time: Optional[str] = None,
        include_external_ids: Optional[bool] = None,
        include_tags: Optional[bool] = None,
        tag_ids: Optional[str] = None,
        parent_tag_ids: Optional[str] = None,
        ids: Optional[List[str]] = None,
        attribute_value_ids: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ListAssetsResponse:
        r"""[beta] List all assets.

        List all assets. Up to 300 assets will be returned per page.

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Assets** under the Assets category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param type: The operational context in which the asset interacts with the Samsara system. Examples: Vehicle (eg: truck, bus...), Trailer (eg: dry van, reefer, flatbed...), Powered Equipment (eg: dozer, crane...), Unpowered Equipment (eg: container, dumpster...), or Uncategorized.  Valid values: `uncategorized`, `trailer`, `equipment`, `unpowered`, `vehicle`
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param updated_after_time: A filter on data to have an updated at time after or equal to this specified time in RFC 3339 format. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param include_external_ids: Optional boolean indicating whether to return external IDs on supported entities
        :param include_tags: Optional boolean indicating whether to return tags on supported entities
        :param tag_ids: A filter on the data based on this comma-separated list of tag IDs. Example: `tagIds=1234,5678`
        :param parent_tag_ids: A filter on the data based on this comma-separated list of parent tag IDs, for use by orgs with tag hierarchies. Specifying a parent tag will implicitly include all descendent tags of the parent tag. Example: `parentTagIds=345,678`
        :param ids: A filter on the data based on this comma-separated list of asset IDs and External IDs.
        :param attribute_value_ids: A filter on the data based on this comma-separated list of attribute value IDs. Only entities associated with ALL of the referenced values will be returned (i.e. the intersection of the sets of entities with each value). Example: `attributeValueIds=076efac2-83b5-47aa-ba36-18428436dcac,6707b3f0-23b9-4fe3-b7be-11be34aea544`
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.ListAssetsRequest(
            type=type_,
            after=after,
            updated_after_time=updated_after_time,
            include_external_ids=include_external_ids,
            include_tags=include_tags,
            tag_ids=tag_ids,
            parent_tag_ids=parent_tag_ids,
            ids=ids,
            attribute_value_ids=attribute_value_ids,
        )

        req = self._build_request_async(
            method="GET",
            path="/assets",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="listAssets",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.AssetsListAssetsResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.AssetsListAssetsUnauthorizedErrorResponseBodyData
            )
            raise models.AssetsListAssetsUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.AssetsListAssetsNotFoundErrorResponseBodyData
            )
            raise models.AssetsListAssetsNotFoundErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsListAssetsMethodNotAllowedErrorResponseBodyData,
            )
            raise models.AssetsListAssetsMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsListAssetsTooManyRequestsErrorResponseBodyData,
            )
            raise models.AssetsListAssetsTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsListAssetsInternalServerErrorResponseBodyData,
            )
            raise models.AssetsListAssetsInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsListAssetsNotImplementedErrorResponseBodyData,
            )
            raise models.AssetsListAssetsNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.AssetsListAssetsBadGatewayErrorResponseBodyData
            )
            raise models.AssetsListAssetsBadGatewayErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsListAssetsServiceUnavailableErrorResponseBodyData,
            )
            raise models.AssetsListAssetsServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsListAssetsGatewayTimeoutErrorResponseBodyData,
            )
            raise models.AssetsListAssetsGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.AssetsListAssetsBadRequestErrorResponseBody
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def update_asset(
        self,
        *,
        id: str,
        external_ids: Optional[Dict[str, str]] = None,
        license_plate: Optional[str] = None,
        make: Optional[str] = None,
        model: Optional[str] = None,
        name: Optional[str] = None,
        notes: Optional[str] = None,
        regulation_mode: Optional[
            models.AssetsUpdateAssetRequestBodyRegulationMode
        ] = None,
        serial_number: Optional[str] = None,
        type_: Optional[models.AssetsUpdateAssetRequestBodyType] = None,
        vin: Optional[str] = None,
        year: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.UpdateAssetResponse:
        r"""[beta] Update an existing asset.

        Update an existing asset.

        <b>Rate limit:</b> 100 requests/min (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write Assets** under the Assets category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param id: A filter selecting a single asset by id.
        :param external_ids: A map of external ids
        :param license_plate: The license plate of the asset.
        :param make: The manufacturer of the asset. (If a VIN is entered and the system detects it is registered to a different manufacturer than provided an error will be returned).
        :param model: The manufacturer model of the asset. (If a VIN is entered and the system detects it is registered to a different model than provided an error will be returned).
        :param name: The human-readable name of the asset. This is set by a fleet administrator and will appear in both Samsara’s cloud dashboard as well as the Samsara Driver mobile app. By default, this name is the serial number of the Samsara Asset Gateway. It can be set or updated through the Samsara Dashboard or through the API at any time.
        :param notes: These are generic notes about the asset. Can be set or updated through the Samsara Dashboard or the API at any time.
        :param regulation_mode: Whether or not the asset is regulated, unregulated (non-CMV), or a mixed use unregulated asset. Primarily used with vehicles.  Valid values: `mixed`, `regulated`, `unregulated`
        :param serial_number: The serial number of the asset.
        :param type: The operational context in which the asset interacts with the Samsara system. Examples: Vehicle (eg: truck, bus...), Trailer (eg: dry van, reefer, flatbed...), Powered Equipment (eg: dozer, crane...), Unpowered Equipment (eg: container, dumpster...), or Uncategorized.  Valid values: `uncategorized`, `trailer`, `equipment`, `unpowered`, `vehicle`
        :param vin: The vehicle identification number of the asset.
        :param year: The year of manufacture of the asset.  (If a VIN is entered and the system detects it is registered to a different year than provided an error will be returned).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.UpdateAssetRequest(
            id=id,
            assets_update_asset_request_body=models.AssetsUpdateAssetRequestBody(
                external_ids=external_ids,
                license_plate=license_plate,
                make=make,
                model=model,
                name=name,
                notes=notes,
                regulation_mode=regulation_mode,
                serial_number=serial_number,
                type=type_,
                vin=vin,
                year=year,
            ),
        )

        req = self._build_request(
            method="PATCH",
            path="/assets",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.assets_update_asset_request_body,
                False,
                False,
                "json",
                models.AssetsUpdateAssetRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="updateAsset",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.AssetsUpdateAssetResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.AssetsUpdateAssetUnauthorizedErrorResponseBodyData
            )
            raise models.AssetsUpdateAssetUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.AssetsUpdateAssetNotFoundErrorResponseBodyData
            )
            raise models.AssetsUpdateAssetNotFoundErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsUpdateAssetMethodNotAllowedErrorResponseBodyData,
            )
            raise models.AssetsUpdateAssetMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsUpdateAssetTooManyRequestsErrorResponseBodyData,
            )
            raise models.AssetsUpdateAssetTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsUpdateAssetInternalServerErrorResponseBodyData,
            )
            raise models.AssetsUpdateAssetInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsUpdateAssetNotImplementedErrorResponseBodyData,
            )
            raise models.AssetsUpdateAssetNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.AssetsUpdateAssetBadGatewayErrorResponseBodyData
            )
            raise models.AssetsUpdateAssetBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsUpdateAssetServiceUnavailableErrorResponseBodyData,
            )
            raise models.AssetsUpdateAssetServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsUpdateAssetGatewayTimeoutErrorResponseBodyData,
            )
            raise models.AssetsUpdateAssetGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.AssetsUpdateAssetBadRequestErrorResponseBody
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def update_asset_async(
        self,
        *,
        id: str,
        external_ids: Optional[Dict[str, str]] = None,
        license_plate: Optional[str] = None,
        make: Optional[str] = None,
        model: Optional[str] = None,
        name: Optional[str] = None,
        notes: Optional[str] = None,
        regulation_mode: Optional[
            models.AssetsUpdateAssetRequestBodyRegulationMode
        ] = None,
        serial_number: Optional[str] = None,
        type_: Optional[models.AssetsUpdateAssetRequestBodyType] = None,
        vin: Optional[str] = None,
        year: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.UpdateAssetResponse:
        r"""[beta] Update an existing asset.

        Update an existing asset.

        <b>Rate limit:</b> 100 requests/min (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write Assets** under the Assets category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param id: A filter selecting a single asset by id.
        :param external_ids: A map of external ids
        :param license_plate: The license plate of the asset.
        :param make: The manufacturer of the asset. (If a VIN is entered and the system detects it is registered to a different manufacturer than provided an error will be returned).
        :param model: The manufacturer model of the asset. (If a VIN is entered and the system detects it is registered to a different model than provided an error will be returned).
        :param name: The human-readable name of the asset. This is set by a fleet administrator and will appear in both Samsara’s cloud dashboard as well as the Samsara Driver mobile app. By default, this name is the serial number of the Samsara Asset Gateway. It can be set or updated through the Samsara Dashboard or through the API at any time.
        :param notes: These are generic notes about the asset. Can be set or updated through the Samsara Dashboard or the API at any time.
        :param regulation_mode: Whether or not the asset is regulated, unregulated (non-CMV), or a mixed use unregulated asset. Primarily used with vehicles.  Valid values: `mixed`, `regulated`, `unregulated`
        :param serial_number: The serial number of the asset.
        :param type: The operational context in which the asset interacts with the Samsara system. Examples: Vehicle (eg: truck, bus...), Trailer (eg: dry van, reefer, flatbed...), Powered Equipment (eg: dozer, crane...), Unpowered Equipment (eg: container, dumpster...), or Uncategorized.  Valid values: `uncategorized`, `trailer`, `equipment`, `unpowered`, `vehicle`
        :param vin: The vehicle identification number of the asset.
        :param year: The year of manufacture of the asset.  (If a VIN is entered and the system detects it is registered to a different year than provided an error will be returned).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.UpdateAssetRequest(
            id=id,
            assets_update_asset_request_body=models.AssetsUpdateAssetRequestBody(
                external_ids=external_ids,
                license_plate=license_plate,
                make=make,
                model=model,
                name=name,
                notes=notes,
                regulation_mode=regulation_mode,
                serial_number=serial_number,
                type=type_,
                vin=vin,
                year=year,
            ),
        )

        req = self._build_request_async(
            method="PATCH",
            path="/assets",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.assets_update_asset_request_body,
                False,
                False,
                "json",
                models.AssetsUpdateAssetRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="updateAsset",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.AssetsUpdateAssetResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.AssetsUpdateAssetUnauthorizedErrorResponseBodyData
            )
            raise models.AssetsUpdateAssetUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.AssetsUpdateAssetNotFoundErrorResponseBodyData
            )
            raise models.AssetsUpdateAssetNotFoundErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsUpdateAssetMethodNotAllowedErrorResponseBodyData,
            )
            raise models.AssetsUpdateAssetMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsUpdateAssetTooManyRequestsErrorResponseBodyData,
            )
            raise models.AssetsUpdateAssetTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsUpdateAssetInternalServerErrorResponseBodyData,
            )
            raise models.AssetsUpdateAssetInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsUpdateAssetNotImplementedErrorResponseBodyData,
            )
            raise models.AssetsUpdateAssetNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.AssetsUpdateAssetBadGatewayErrorResponseBodyData
            )
            raise models.AssetsUpdateAssetBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsUpdateAssetServiceUnavailableErrorResponseBodyData,
            )
            raise models.AssetsUpdateAssetServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsUpdateAssetGatewayTimeoutErrorResponseBodyData,
            )
            raise models.AssetsUpdateAssetGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.AssetsUpdateAssetBadRequestErrorResponseBody
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def create_asset(
        self,
        *,
        request: Union[
            models.AssetsCreateAssetRequestBody,
            models.AssetsCreateAssetRequestBodyTypedDict,
        ] = models.AssetsCreateAssetRequestBody(),
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CreateAssetResponse:
        r"""[beta] Create a new asset.

        Create a new asset.

        <b>Rate limit:</b> 100 requests/min (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write Assets** under the Assets category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.AssetsCreateAssetRequestBody)
        request = cast(models.AssetsCreateAssetRequestBody, request)

        req = self._build_request(
            method="POST",
            path="/assets",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request,
                False,
                True,
                "json",
                Optional[models.AssetsCreateAssetRequestBody],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="createAsset",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.AssetsCreateAssetResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.AssetsCreateAssetUnauthorizedErrorResponseBodyData
            )
            raise models.AssetsCreateAssetUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.AssetsCreateAssetNotFoundErrorResponseBodyData
            )
            raise models.AssetsCreateAssetNotFoundErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsCreateAssetMethodNotAllowedErrorResponseBodyData,
            )
            raise models.AssetsCreateAssetMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsCreateAssetTooManyRequestsErrorResponseBodyData,
            )
            raise models.AssetsCreateAssetTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsCreateAssetInternalServerErrorResponseBodyData,
            )
            raise models.AssetsCreateAssetInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsCreateAssetNotImplementedErrorResponseBodyData,
            )
            raise models.AssetsCreateAssetNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.AssetsCreateAssetBadGatewayErrorResponseBodyData
            )
            raise models.AssetsCreateAssetBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsCreateAssetServiceUnavailableErrorResponseBodyData,
            )
            raise models.AssetsCreateAssetServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsCreateAssetGatewayTimeoutErrorResponseBodyData,
            )
            raise models.AssetsCreateAssetGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.AssetsCreateAssetBadRequestErrorResponseBody
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def create_asset_async(
        self,
        *,
        request: Union[
            models.AssetsCreateAssetRequestBody,
            models.AssetsCreateAssetRequestBodyTypedDict,
        ] = models.AssetsCreateAssetRequestBody(),
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CreateAssetResponse:
        r"""[beta] Create a new asset.

        Create a new asset.

        <b>Rate limit:</b> 100 requests/min (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write Assets** under the Assets category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.AssetsCreateAssetRequestBody)
        request = cast(models.AssetsCreateAssetRequestBody, request)

        req = self._build_request_async(
            method="POST",
            path="/assets",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request,
                False,
                True,
                "json",
                Optional[models.AssetsCreateAssetRequestBody],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="createAsset",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.AssetsCreateAssetResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.AssetsCreateAssetUnauthorizedErrorResponseBodyData
            )
            raise models.AssetsCreateAssetUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.AssetsCreateAssetNotFoundErrorResponseBodyData
            )
            raise models.AssetsCreateAssetNotFoundErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsCreateAssetMethodNotAllowedErrorResponseBodyData,
            )
            raise models.AssetsCreateAssetMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsCreateAssetTooManyRequestsErrorResponseBodyData,
            )
            raise models.AssetsCreateAssetTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsCreateAssetInternalServerErrorResponseBodyData,
            )
            raise models.AssetsCreateAssetInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsCreateAssetNotImplementedErrorResponseBodyData,
            )
            raise models.AssetsCreateAssetNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.AssetsCreateAssetBadGatewayErrorResponseBodyData
            )
            raise models.AssetsCreateAssetBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsCreateAssetServiceUnavailableErrorResponseBodyData,
            )
            raise models.AssetsCreateAssetServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsCreateAssetGatewayTimeoutErrorResponseBodyData,
            )
            raise models.AssetsCreateAssetGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.AssetsCreateAssetBadRequestErrorResponseBody
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_assets_inputs(
        self,
        *,
        ids: List[str],
        type_: models.GetAssetsInputsQueryParamType,
        start_time: str,
        after: Optional[str] = None,
        end_time: Optional[str] = None,
        include_external_ids: Optional[bool] = None,
        include_tags: Optional[bool] = None,
        include_attributes: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetAssetsInputsResponse:
        r"""[beta] List asset inputs data in an organization.

        This endpoint will return data collected from the inputs of your organization's assets based on the time parameters passed in. Results are paginated. If you include an endTime, the endpoint will return data up until that point. If you don’t include an endTime, you can continue to poll the API real-time with the pagination cursor that gets returned on every call. The endpoint will only return data up until the endTime that has been processed by the server at the time of the original request. You will need to request the same [startTime, endTime) range again to receive data for assets processed after the original request time. This endpoint sorts data by time ascending.

        <b>Rate limit:</b> 10 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Assets** under the Assets category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param ids: Comma-separated list of asset IDs. Limited to 100 ID's for each request.
        :param type: Input stat type to query for.  Valid values: `auxInput1`, `auxInput2`, `auxInput3`, `auxInput4`, `auxInput5`, `auxInput6`, `auxInput7`, `auxInput8`, `auxInput9`, `auxInput10`, `auxInput11`, `auxInput12`, `auxInput13`, `analogInput1Voltage`, `analogInput2Voltage`, `analogInput1Current`, `analogInput2Current`, `batteryVoltage`
        :param start_time: A start time in RFC 3339 format. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param end_time: An end time in RFC 3339 format. Defaults to never if not provided; if not provided then pagination will not cease, and a valid pagination cursor will always be returned. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param include_external_ids: Optional boolean indicating whether to return external IDs on supported entities
        :param include_tags: Optional boolean indicating whether to return tags on supported entities
        :param include_attributes: Optional boolean indicating whether to return attributes on supported entities
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetAssetsInputsRequest(
            ids=ids,
            type=type_,
            after=after,
            start_time=start_time,
            end_time=end_time,
            include_external_ids=include_external_ids,
            include_tags=include_tags,
            include_attributes=include_attributes,
        )

        req = self._build_request(
            method="GET",
            path="/assets/inputs/stream",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getAssetsInputs",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.AssetsInputsGetAssetsInputsResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsInputsGetAssetsInputsUnauthorizedErrorResponseBodyData,
            )
            raise models.AssetsInputsGetAssetsInputsUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsInputsGetAssetsInputsNotFoundErrorResponseBodyData,
            )
            raise models.AssetsInputsGetAssetsInputsNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsInputsGetAssetsInputsMethodNotAllowedErrorResponseBodyData,
            )
            raise models.AssetsInputsGetAssetsInputsMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsInputsGetAssetsInputsTooManyRequestsErrorResponseBodyData,
            )
            raise models.AssetsInputsGetAssetsInputsTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsInputsGetAssetsInputsInternalServerErrorResponseBodyData,
            )
            raise models.AssetsInputsGetAssetsInputsInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsInputsGetAssetsInputsNotImplementedErrorResponseBodyData,
            )
            raise models.AssetsInputsGetAssetsInputsNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsInputsGetAssetsInputsBadGatewayErrorResponseBodyData,
            )
            raise models.AssetsInputsGetAssetsInputsBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsInputsGetAssetsInputsServiceUnavailableErrorResponseBodyData,
            )
            raise models.AssetsInputsGetAssetsInputsServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsInputsGetAssetsInputsGatewayTimeoutErrorResponseBodyData,
            )
            raise models.AssetsInputsGetAssetsInputsGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.AssetsInputsGetAssetsInputsBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_assets_inputs_async(
        self,
        *,
        ids: List[str],
        type_: models.GetAssetsInputsQueryParamType,
        start_time: str,
        after: Optional[str] = None,
        end_time: Optional[str] = None,
        include_external_ids: Optional[bool] = None,
        include_tags: Optional[bool] = None,
        include_attributes: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetAssetsInputsResponse:
        r"""[beta] List asset inputs data in an organization.

        This endpoint will return data collected from the inputs of your organization's assets based on the time parameters passed in. Results are paginated. If you include an endTime, the endpoint will return data up until that point. If you don’t include an endTime, you can continue to poll the API real-time with the pagination cursor that gets returned on every call. The endpoint will only return data up until the endTime that has been processed by the server at the time of the original request. You will need to request the same [startTime, endTime) range again to receive data for assets processed after the original request time. This endpoint sorts data by time ascending.

        <b>Rate limit:</b> 10 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Assets** under the Assets category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param ids: Comma-separated list of asset IDs. Limited to 100 ID's for each request.
        :param type: Input stat type to query for.  Valid values: `auxInput1`, `auxInput2`, `auxInput3`, `auxInput4`, `auxInput5`, `auxInput6`, `auxInput7`, `auxInput8`, `auxInput9`, `auxInput10`, `auxInput11`, `auxInput12`, `auxInput13`, `analogInput1Voltage`, `analogInput2Voltage`, `analogInput1Current`, `analogInput2Current`, `batteryVoltage`
        :param start_time: A start time in RFC 3339 format. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param end_time: An end time in RFC 3339 format. Defaults to never if not provided; if not provided then pagination will not cease, and a valid pagination cursor will always be returned. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param include_external_ids: Optional boolean indicating whether to return external IDs on supported entities
        :param include_tags: Optional boolean indicating whether to return tags on supported entities
        :param include_attributes: Optional boolean indicating whether to return attributes on supported entities
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetAssetsInputsRequest(
            ids=ids,
            type=type_,
            after=after,
            start_time=start_time,
            end_time=end_time,
            include_external_ids=include_external_ids,
            include_tags=include_tags,
            include_attributes=include_attributes,
        )

        req = self._build_request_async(
            method="GET",
            path="/assets/inputs/stream",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getAssetsInputs",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.AssetsInputsGetAssetsInputsResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsInputsGetAssetsInputsUnauthorizedErrorResponseBodyData,
            )
            raise models.AssetsInputsGetAssetsInputsUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsInputsGetAssetsInputsNotFoundErrorResponseBodyData,
            )
            raise models.AssetsInputsGetAssetsInputsNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsInputsGetAssetsInputsMethodNotAllowedErrorResponseBodyData,
            )
            raise models.AssetsInputsGetAssetsInputsMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsInputsGetAssetsInputsTooManyRequestsErrorResponseBodyData,
            )
            raise models.AssetsInputsGetAssetsInputsTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsInputsGetAssetsInputsInternalServerErrorResponseBodyData,
            )
            raise models.AssetsInputsGetAssetsInputsInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsInputsGetAssetsInputsNotImplementedErrorResponseBodyData,
            )
            raise models.AssetsInputsGetAssetsInputsNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsInputsGetAssetsInputsBadGatewayErrorResponseBodyData,
            )
            raise models.AssetsInputsGetAssetsInputsBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsInputsGetAssetsInputsServiceUnavailableErrorResponseBodyData,
            )
            raise models.AssetsInputsGetAssetsInputsServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AssetsInputsGetAssetsInputsGatewayTimeoutErrorResponseBodyData,
            )
            raise models.AssetsInputsGetAssetsInputsGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.AssetsInputsGetAssetsInputsBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_aemp_equipment_list(
        self,
        *,
        page_number: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetAempEquipmentListResponse:
        r"""[beta] Get a list of AEMP equipment

        Get a list of equipment following the AEMP ISO 15143-3 standard.

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read AEMP** under the Equipment category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param page_number: The number corresponding to a specific page of paginated results, defaulting to the first page if not provided. The default page size is 100 records.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetAempEquipmentListRequest(
            page_number=page_number,
        )

        req = self._build_request(
            method="GET",
            path="/beta/aemp/Fleet/{pageNumber}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getAempEquipmentList",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.AempEquipmentGetAempEquipmentListResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AempEquipmentGetAempEquipmentListUnauthorizedErrorResponseBodyData,
            )
            raise models.AempEquipmentGetAempEquipmentListUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AempEquipmentGetAempEquipmentListNotFoundErrorResponseBodyData,
            )
            raise models.AempEquipmentGetAempEquipmentListNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AempEquipmentGetAempEquipmentListMethodNotAllowedErrorResponseBodyData,
            )
            raise models.AempEquipmentGetAempEquipmentListMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AempEquipmentGetAempEquipmentListTooManyRequestsErrorResponseBodyData,
            )
            raise models.AempEquipmentGetAempEquipmentListTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AempEquipmentGetAempEquipmentListInternalServerErrorResponseBodyData,
            )
            raise models.AempEquipmentGetAempEquipmentListInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AempEquipmentGetAempEquipmentListNotImplementedErrorResponseBodyData,
            )
            raise models.AempEquipmentGetAempEquipmentListNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AempEquipmentGetAempEquipmentListBadGatewayErrorResponseBodyData,
            )
            raise models.AempEquipmentGetAempEquipmentListBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AempEquipmentGetAempEquipmentListServiceUnavailableErrorResponseBodyData,
            )
            raise models.AempEquipmentGetAempEquipmentListServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AempEquipmentGetAempEquipmentListGatewayTimeoutErrorResponseBodyData,
            )
            raise models.AempEquipmentGetAempEquipmentListGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.AempEquipmentGetAempEquipmentListBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_aemp_equipment_list_async(
        self,
        *,
        page_number: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetAempEquipmentListResponse:
        r"""[beta] Get a list of AEMP equipment

        Get a list of equipment following the AEMP ISO 15143-3 standard.

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read AEMP** under the Equipment category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param page_number: The number corresponding to a specific page of paginated results, defaulting to the first page if not provided. The default page size is 100 records.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetAempEquipmentListRequest(
            page_number=page_number,
        )

        req = self._build_request_async(
            method="GET",
            path="/beta/aemp/Fleet/{pageNumber}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getAempEquipmentList",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.AempEquipmentGetAempEquipmentListResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AempEquipmentGetAempEquipmentListUnauthorizedErrorResponseBodyData,
            )
            raise models.AempEquipmentGetAempEquipmentListUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AempEquipmentGetAempEquipmentListNotFoundErrorResponseBodyData,
            )
            raise models.AempEquipmentGetAempEquipmentListNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AempEquipmentGetAempEquipmentListMethodNotAllowedErrorResponseBodyData,
            )
            raise models.AempEquipmentGetAempEquipmentListMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AempEquipmentGetAempEquipmentListTooManyRequestsErrorResponseBodyData,
            )
            raise models.AempEquipmentGetAempEquipmentListTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AempEquipmentGetAempEquipmentListInternalServerErrorResponseBodyData,
            )
            raise models.AempEquipmentGetAempEquipmentListInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AempEquipmentGetAempEquipmentListNotImplementedErrorResponseBodyData,
            )
            raise models.AempEquipmentGetAempEquipmentListNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AempEquipmentGetAempEquipmentListBadGatewayErrorResponseBodyData,
            )
            raise models.AempEquipmentGetAempEquipmentListBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AempEquipmentGetAempEquipmentListServiceUnavailableErrorResponseBodyData,
            )
            raise models.AempEquipmentGetAempEquipmentListServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.AempEquipmentGetAempEquipmentListGatewayTimeoutErrorResponseBodyData,
            )
            raise models.AempEquipmentGetAempEquipmentListGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.AempEquipmentGetAempEquipmentListBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_driver_efficiency(
        self,
        *,
        driver_activation_status: Optional[
            models.GetDriverEfficiencyQueryParamDriverActivationStatus
        ] = None,
        driver_ids: Optional[List[str]] = None,
        after: Optional[str] = None,
        driver_tag_ids: Optional[List[str]] = None,
        driver_parent_tag_ids: Optional[List[str]] = None,
        start_time: Optional[datetime] = None,
        end_time: Optional[datetime] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetDriverEfficiencyResponse:
        r"""[beta] List driver efficiency

        Get all driver and associated vehicle efficiency data.

        <b>Rate limit:</b> 50 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        To use this endpoint, select **Read Fuel & Energy** under the Fuel & Energy category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>

        :param driver_activation_status: If value is `deactivated`, only drivers that are deactivated will appear in the response. This parameter will default to `active` if not provided (fetching only active drivers).
        :param driver_ids: A filter on the data based on this comma-separated list of driver IDs. Cannot be used with tag filtering or driver status. Example: `driverIds=1234,5678`
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param driver_tag_ids: Filters summary to drivers based on this comma-separated list of tag IDs. Data from all the drivers' respective vehicles will be included in the summary, regardless of which tag the vehicle is associated with. Should not be provided in addition to `driverIds`. Example: driverTagIds=1234,5678
        :param driver_parent_tag_ids: Filters like `driverTagIds` but includes descendants of all the given parent tags. Should not be provided in addition to `driverIds`. Example: `driverParentTagIds=1234,5678`
        :param start_time: A start time in RFC 3339 format. The results will be truncated to the hour mark for the provided time. For example, if `startTime` is 2020-03-17T12:06:19Z then the results will include data starting from 2020-03-17T12:00:00Z. The provided start time cannot be in the future. Start time can be at most 31 days before the end time. If the start time is within the last hour, the results will be empty. Default: 24 hours prior to endTime.  Note that the most recent 72 hours of data may still be processing and is subject to change and latency, so it is not recommended to request data for the most recent 72 hours.
        :param end_time: An end time in RFC 3339 format. The results will be truncated to the hour mark for the provided time. For example, if `endTime` is 2020-03-17T12:06:19Z then the results will include data up until 2020-03-17T12:00:00Z. The provided end time cannot be in the future. End time can be at most 31 days after the start time. Default: The current time truncated to the hour mark.  Note that the most recent 72 hours of data may still be processing and is subject to change and latency, so it is not recommended to request data for the most recent 72 hours
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetDriverEfficiencyRequest(
            driver_activation_status=driver_activation_status,
            driver_ids=driver_ids,
            after=after,
            driver_tag_ids=driver_tag_ids,
            driver_parent_tag_ids=driver_parent_tag_ids,
            start_time=start_time,
            end_time=end_time,
        )

        req = self._build_request(
            method="GET",
            path="/beta/fleet/drivers/efficiency",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getDriverEfficiency",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.DriverEfficienciesResponse
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(http_res.text, models.StandardErrorResponse)

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_driver_efficiency_async(
        self,
        *,
        driver_activation_status: Optional[
            models.GetDriverEfficiencyQueryParamDriverActivationStatus
        ] = None,
        driver_ids: Optional[List[str]] = None,
        after: Optional[str] = None,
        driver_tag_ids: Optional[List[str]] = None,
        driver_parent_tag_ids: Optional[List[str]] = None,
        start_time: Optional[datetime] = None,
        end_time: Optional[datetime] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetDriverEfficiencyResponse:
        r"""[beta] List driver efficiency

        Get all driver and associated vehicle efficiency data.

        <b>Rate limit:</b> 50 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        To use this endpoint, select **Read Fuel & Energy** under the Fuel & Energy category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>

        :param driver_activation_status: If value is `deactivated`, only drivers that are deactivated will appear in the response. This parameter will default to `active` if not provided (fetching only active drivers).
        :param driver_ids: A filter on the data based on this comma-separated list of driver IDs. Cannot be used with tag filtering or driver status. Example: `driverIds=1234,5678`
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param driver_tag_ids: Filters summary to drivers based on this comma-separated list of tag IDs. Data from all the drivers' respective vehicles will be included in the summary, regardless of which tag the vehicle is associated with. Should not be provided in addition to `driverIds`. Example: driverTagIds=1234,5678
        :param driver_parent_tag_ids: Filters like `driverTagIds` but includes descendants of all the given parent tags. Should not be provided in addition to `driverIds`. Example: `driverParentTagIds=1234,5678`
        :param start_time: A start time in RFC 3339 format. The results will be truncated to the hour mark for the provided time. For example, if `startTime` is 2020-03-17T12:06:19Z then the results will include data starting from 2020-03-17T12:00:00Z. The provided start time cannot be in the future. Start time can be at most 31 days before the end time. If the start time is within the last hour, the results will be empty. Default: 24 hours prior to endTime.  Note that the most recent 72 hours of data may still be processing and is subject to change and latency, so it is not recommended to request data for the most recent 72 hours.
        :param end_time: An end time in RFC 3339 format. The results will be truncated to the hour mark for the provided time. For example, if `endTime` is 2020-03-17T12:06:19Z then the results will include data up until 2020-03-17T12:00:00Z. The provided end time cannot be in the future. End time can be at most 31 days after the start time. Default: The current time truncated to the hour mark.  Note that the most recent 72 hours of data may still be processing and is subject to change and latency, so it is not recommended to request data for the most recent 72 hours
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetDriverEfficiencyRequest(
            driver_activation_status=driver_activation_status,
            driver_ids=driver_ids,
            after=after,
            driver_tag_ids=driver_tag_ids,
            driver_parent_tag_ids=driver_parent_tag_ids,
            start_time=start_time,
            end_time=end_time,
        )

        req = self._build_request_async(
            method="GET",
            path="/beta/fleet/drivers/efficiency",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getDriverEfficiency",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.DriverEfficienciesResponse
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(http_res.text, models.StandardErrorResponse)

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def patch_equipment(
        self,
        *,
        id_param: str,
        attributes: Optional[
            Union[List[models.GoaAttributeTiny], List[models.GoaAttributeTinyTypedDict]]
        ] = None,
        engine_hours: Optional[int] = None,
        equipment_serial_number: Optional[str] = None,
        external_ids: Optional[Dict[str, str]] = None,
        id: Optional[str] = None,
        name: Optional[str] = None,
        notes: Optional[str] = None,
        odometer_meters: Optional[int] = None,
        tag_ids: Optional[List[str]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PatchEquipmentResponse:
        r"""[beta] Update an equipment

        Update an equipment.  **Note** this implementation of patch uses [the JSON merge patch](https://tools.ietf.org/html/rfc7396) proposed standard.
        This means that any fields included in the patch request will _overwrite_ fields which exist on the target resource.
        For arrays, this means any array included in the request will _replace_ the array that exists at the specified path, it will not _add_ to the existing array

        <b>Rate limit:</b> 100 requests/min (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write Equipment** under the Equipment category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param id_param: The unique Samsara ID of the Equipment. This is automatically generated when the Equipment object is created. It cannot be changed.
        :param attributes: List of attributes associated with the entity
        :param engine_hours: When you provide a manual engine hours override, Samsara will begin updating a equipment's engine hours used since this override was set.
        :param equipment_serial_number: The serial number of the equipment.
        :param external_ids: A map of external ids
        :param id: The unique Samsara ID of the Equipment. This is automatically generated when the Equipment object is created. It cannot be changed.
        :param name: The human-readable name of the Equipment. This is set by a fleet administrator and will appear in both Samsara’s cloud dashboard as well as the Samsara Driver mobile app. By default, this name is the serial number of the Samsara Asset Gateway. It can be set or updated through the Samsara Dashboard or through the API at any time.
        :param notes: These are generic notes about the Equipment. Empty by default. Can be set or updated through the Samsara Dashboard or the API at any time.
        :param odometer_meters: When you provide a manual odometer override, Samsara will begin updating a equipment's odometer using GPS distance traveled since this override was set.
        :param tag_ids: An array of IDs of tags to associate with this equipment. If your access to the API is scoped by one or more tags, this field is required to pass in.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.PatchEquipmentRequest(
            id_param=id_param,
            equipment_patch_equipment_request_body=models.EquipmentPatchEquipmentRequestBody(
                attributes=utils.get_pydantic_model(
                    attributes, Optional[List[models.GoaAttributeTiny]]
                ),
                engine_hours=engine_hours,
                equipment_serial_number=equipment_serial_number,
                external_ids=external_ids,
                id=id,
                name=name,
                notes=notes,
                odometer_meters=odometer_meters,
                tag_ids=tag_ids,
            ),
        )

        req = self._build_request(
            method="PATCH",
            path="/beta/fleet/equipment/{id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.equipment_patch_equipment_request_body,
                False,
                False,
                "json",
                models.EquipmentPatchEquipmentRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="patchEquipment",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.EquipmentPatchEquipmentResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EquipmentPatchEquipmentUnauthorizedErrorResponseBodyData,
            )
            raise models.EquipmentPatchEquipmentUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EquipmentPatchEquipmentNotFoundErrorResponseBodyData,
            )
            raise models.EquipmentPatchEquipmentNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EquipmentPatchEquipmentMethodNotAllowedErrorResponseBodyData,
            )
            raise models.EquipmentPatchEquipmentMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EquipmentPatchEquipmentTooManyRequestsErrorResponseBodyData,
            )
            raise models.EquipmentPatchEquipmentTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EquipmentPatchEquipmentInternalServerErrorResponseBodyData,
            )
            raise models.EquipmentPatchEquipmentInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EquipmentPatchEquipmentNotImplementedErrorResponseBodyData,
            )
            raise models.EquipmentPatchEquipmentNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EquipmentPatchEquipmentBadGatewayErrorResponseBodyData,
            )
            raise models.EquipmentPatchEquipmentBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EquipmentPatchEquipmentServiceUnavailableErrorResponseBodyData,
            )
            raise models.EquipmentPatchEquipmentServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EquipmentPatchEquipmentGatewayTimeoutErrorResponseBodyData,
            )
            raise models.EquipmentPatchEquipmentGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.EquipmentPatchEquipmentBadRequestErrorResponseBody
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def patch_equipment_async(
        self,
        *,
        id_param: str,
        attributes: Optional[
            Union[List[models.GoaAttributeTiny], List[models.GoaAttributeTinyTypedDict]]
        ] = None,
        engine_hours: Optional[int] = None,
        equipment_serial_number: Optional[str] = None,
        external_ids: Optional[Dict[str, str]] = None,
        id: Optional[str] = None,
        name: Optional[str] = None,
        notes: Optional[str] = None,
        odometer_meters: Optional[int] = None,
        tag_ids: Optional[List[str]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PatchEquipmentResponse:
        r"""[beta] Update an equipment

        Update an equipment.  **Note** this implementation of patch uses [the JSON merge patch](https://tools.ietf.org/html/rfc7396) proposed standard.
        This means that any fields included in the patch request will _overwrite_ fields which exist on the target resource.
        For arrays, this means any array included in the request will _replace_ the array that exists at the specified path, it will not _add_ to the existing array

        <b>Rate limit:</b> 100 requests/min (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write Equipment** under the Equipment category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param id_param: The unique Samsara ID of the Equipment. This is automatically generated when the Equipment object is created. It cannot be changed.
        :param attributes: List of attributes associated with the entity
        :param engine_hours: When you provide a manual engine hours override, Samsara will begin updating a equipment's engine hours used since this override was set.
        :param equipment_serial_number: The serial number of the equipment.
        :param external_ids: A map of external ids
        :param id: The unique Samsara ID of the Equipment. This is automatically generated when the Equipment object is created. It cannot be changed.
        :param name: The human-readable name of the Equipment. This is set by a fleet administrator and will appear in both Samsara’s cloud dashboard as well as the Samsara Driver mobile app. By default, this name is the serial number of the Samsara Asset Gateway. It can be set or updated through the Samsara Dashboard or through the API at any time.
        :param notes: These are generic notes about the Equipment. Empty by default. Can be set or updated through the Samsara Dashboard or the API at any time.
        :param odometer_meters: When you provide a manual odometer override, Samsara will begin updating a equipment's odometer using GPS distance traveled since this override was set.
        :param tag_ids: An array of IDs of tags to associate with this equipment. If your access to the API is scoped by one or more tags, this field is required to pass in.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.PatchEquipmentRequest(
            id_param=id_param,
            equipment_patch_equipment_request_body=models.EquipmentPatchEquipmentRequestBody(
                attributes=utils.get_pydantic_model(
                    attributes, Optional[List[models.GoaAttributeTiny]]
                ),
                engine_hours=engine_hours,
                equipment_serial_number=equipment_serial_number,
                external_ids=external_ids,
                id=id,
                name=name,
                notes=notes,
                odometer_meters=odometer_meters,
                tag_ids=tag_ids,
            ),
        )

        req = self._build_request_async(
            method="PATCH",
            path="/beta/fleet/equipment/{id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.equipment_patch_equipment_request_body,
                False,
                False,
                "json",
                models.EquipmentPatchEquipmentRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="patchEquipment",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.EquipmentPatchEquipmentResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EquipmentPatchEquipmentUnauthorizedErrorResponseBodyData,
            )
            raise models.EquipmentPatchEquipmentUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EquipmentPatchEquipmentNotFoundErrorResponseBodyData,
            )
            raise models.EquipmentPatchEquipmentNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EquipmentPatchEquipmentMethodNotAllowedErrorResponseBodyData,
            )
            raise models.EquipmentPatchEquipmentMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EquipmentPatchEquipmentTooManyRequestsErrorResponseBodyData,
            )
            raise models.EquipmentPatchEquipmentTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EquipmentPatchEquipmentInternalServerErrorResponseBodyData,
            )
            raise models.EquipmentPatchEquipmentInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EquipmentPatchEquipmentNotImplementedErrorResponseBodyData,
            )
            raise models.EquipmentPatchEquipmentNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EquipmentPatchEquipmentBadGatewayErrorResponseBodyData,
            )
            raise models.EquipmentPatchEquipmentBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EquipmentPatchEquipmentServiceUnavailableErrorResponseBodyData,
            )
            raise models.EquipmentPatchEquipmentServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EquipmentPatchEquipmentGatewayTimeoutErrorResponseBodyData,
            )
            raise models.EquipmentPatchEquipmentGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.EquipmentPatchEquipmentBadRequestErrorResponseBody
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_hos_eld_events(
        self,
        *,
        start_time: str,
        end_time: str,
        driver_ids: Optional[List[str]] = None,
        tag_ids: Optional[str] = None,
        parent_tag_ids: Optional[str] = None,
        driver_activation_status: Optional[
            models.QueryParamDriverActivationStatus
        ] = models.QueryParamDriverActivationStatus.ACTIVE,
        after: Optional[str] = None,
        limit: Optional[int] = 25,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetHosEldEventsResponse:
        r"""[beta] Get driver HOS ELD events

        Get all HOS ELD events in a time range, grouped by driver. Attributes will be populated depending on which ELD Event Type is being returned.

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read ELD Compliance Settings (US)** under the Compliance category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param start_time: A start time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param end_time: An end time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param driver_ids: A filter on the data based on this comma-separated list of driver IDs and externalIds. Example: `driverIds=1234,5678,payroll:4841`
        :param tag_ids: A filter on the data based on this comma-separated list of tag IDs. Example: `tagIds=1234,5678`
        :param parent_tag_ids: A filter on the data based on this comma-separated list of parent tag IDs, for use by orgs with tag hierarchies. Specifying a parent tag will implicitly include all descendent tags of the parent tag. Example: `parentTagIds=345,678`
        :param driver_activation_status: If value is `deactivated`, only drivers that are deactivated will appear in the response. This parameter will default to `active` if not provided (fetching only active drivers).  Valid values: `active`, `deactivated`
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param limit: The limit for how many objects will be in the response. Default and max for this value is 25 objects.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetHosEldEventsRequest(
            start_time=start_time,
            end_time=end_time,
            driver_ids=driver_ids,
            tag_ids=tag_ids,
            parent_tag_ids=parent_tag_ids,
            driver_activation_status=driver_activation_status,
            after=after,
            limit=limit,
        )

        req = self._build_request(
            method="GET",
            path="/beta/fleet/hos/drivers/eld-events",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getHosEldEvents",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.HosEldEventsGetHosEldEventsResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosEldEventsGetHosEldEventsUnauthorizedErrorResponseBodyData,
            )
            raise models.HosEldEventsGetHosEldEventsUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosEldEventsGetHosEldEventsNotFoundErrorResponseBodyData,
            )
            raise models.HosEldEventsGetHosEldEventsNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosEldEventsGetHosEldEventsMethodNotAllowedErrorResponseBodyData,
            )
            raise models.HosEldEventsGetHosEldEventsMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosEldEventsGetHosEldEventsTooManyRequestsErrorResponseBodyData,
            )
            raise models.HosEldEventsGetHosEldEventsTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosEldEventsGetHosEldEventsInternalServerErrorResponseBodyData,
            )
            raise models.HosEldEventsGetHosEldEventsInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosEldEventsGetHosEldEventsNotImplementedErrorResponseBodyData,
            )
            raise models.HosEldEventsGetHosEldEventsNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosEldEventsGetHosEldEventsBadGatewayErrorResponseBodyData,
            )
            raise models.HosEldEventsGetHosEldEventsBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosEldEventsGetHosEldEventsServiceUnavailableErrorResponseBodyData,
            )
            raise models.HosEldEventsGetHosEldEventsServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosEldEventsGetHosEldEventsGatewayTimeoutErrorResponseBodyData,
            )
            raise models.HosEldEventsGetHosEldEventsGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.HosEldEventsGetHosEldEventsBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_hos_eld_events_async(
        self,
        *,
        start_time: str,
        end_time: str,
        driver_ids: Optional[List[str]] = None,
        tag_ids: Optional[str] = None,
        parent_tag_ids: Optional[str] = None,
        driver_activation_status: Optional[
            models.QueryParamDriverActivationStatus
        ] = models.QueryParamDriverActivationStatus.ACTIVE,
        after: Optional[str] = None,
        limit: Optional[int] = 25,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetHosEldEventsResponse:
        r"""[beta] Get driver HOS ELD events

        Get all HOS ELD events in a time range, grouped by driver. Attributes will be populated depending on which ELD Event Type is being returned.

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read ELD Compliance Settings (US)** under the Compliance category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param start_time: A start time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param end_time: An end time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param driver_ids: A filter on the data based on this comma-separated list of driver IDs and externalIds. Example: `driverIds=1234,5678,payroll:4841`
        :param tag_ids: A filter on the data based on this comma-separated list of tag IDs. Example: `tagIds=1234,5678`
        :param parent_tag_ids: A filter on the data based on this comma-separated list of parent tag IDs, for use by orgs with tag hierarchies. Specifying a parent tag will implicitly include all descendent tags of the parent tag. Example: `parentTagIds=345,678`
        :param driver_activation_status: If value is `deactivated`, only drivers that are deactivated will appear in the response. This parameter will default to `active` if not provided (fetching only active drivers).  Valid values: `active`, `deactivated`
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param limit: The limit for how many objects will be in the response. Default and max for this value is 25 objects.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetHosEldEventsRequest(
            start_time=start_time,
            end_time=end_time,
            driver_ids=driver_ids,
            tag_ids=tag_ids,
            parent_tag_ids=parent_tag_ids,
            driver_activation_status=driver_activation_status,
            after=after,
            limit=limit,
        )

        req = self._build_request_async(
            method="GET",
            path="/beta/fleet/hos/drivers/eld-events",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getHosEldEvents",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.HosEldEventsGetHosEldEventsResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosEldEventsGetHosEldEventsUnauthorizedErrorResponseBodyData,
            )
            raise models.HosEldEventsGetHosEldEventsUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosEldEventsGetHosEldEventsNotFoundErrorResponseBodyData,
            )
            raise models.HosEldEventsGetHosEldEventsNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosEldEventsGetHosEldEventsMethodNotAllowedErrorResponseBodyData,
            )
            raise models.HosEldEventsGetHosEldEventsMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosEldEventsGetHosEldEventsTooManyRequestsErrorResponseBodyData,
            )
            raise models.HosEldEventsGetHosEldEventsTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosEldEventsGetHosEldEventsInternalServerErrorResponseBodyData,
            )
            raise models.HosEldEventsGetHosEldEventsInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosEldEventsGetHosEldEventsNotImplementedErrorResponseBodyData,
            )
            raise models.HosEldEventsGetHosEldEventsNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosEldEventsGetHosEldEventsBadGatewayErrorResponseBodyData,
            )
            raise models.HosEldEventsGetHosEldEventsBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosEldEventsGetHosEldEventsServiceUnavailableErrorResponseBodyData,
            )
            raise models.HosEldEventsGetHosEldEventsServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosEldEventsGetHosEldEventsGatewayTimeoutErrorResponseBodyData,
            )
            raise models.HosEldEventsGetHosEldEventsGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.HosEldEventsGetHosEldEventsBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_trailer_stats_snapshot(
        self,
        *,
        types: str,
        tag_ids: Optional[str] = None,
        parent_tag_ids: Optional[str] = None,
        after: Optional[str] = None,
        trailer_ids: Optional[str] = None,
        time: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetTrailerStatsSnapshotResponse:
        r"""[beta] Get trailer stats

        Returns the last known stats of all trailers at the given `time`. If no `time` is specified, the current time is used.

        <b>Rate limit:</b> 25 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Trailer Statistics** under the Trailers category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param types: The stat types you want this endpoint to return information on.  You may list **up to 3** types using comma-separated format. For example: `types=gps,reeferAmbientAirTemperatureMilliC,gpsOdometerMeters`.  * `gps`: GPS data including lat/long, heading, speed, and a reverse geocode address. * `gpsOdometerMeters`: Odometer reading provided by GPS calculations. You must provide a manual odometer reading before this value is updated. Manual odometer readings can be provided via the PATCH /fleet/trailers/{id} endpoint or through the [cloud dashboard](https://kb.samsara.com/hc/en-us/articles/115005273667-Editing-Odometer-Reading). Odometer readings wthat are manually set will update as GPS trip data is gathered. * `reeferAmbientAirTemperatureMilliC`: The ambient air temperature reading of the reefer in millidegree Celsius. * `reeferObdEngineSeconds`: The cumulative number of seconds the reefer has run according to onboard diagnostics. Only supported on reefer solutions. * `reeferSupplyAirTemperatureMilliCZone1`: The supply or discharge air temperature zone 1 in millidegrees Celsius. For single zone reefers, this applies to the single zone. Only supported on multizone reefer solutions. * `reeferSupplyAirTemperatureMilliCZone2`: The supply or discharge air temperature zone 2 in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferSupplyAirTemperatureMilliCZone3`: The supply or discharge air temperature zone 3 in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferFuelPercent`: The fuel level of the reefer unit in percentage points (e.g. `99`, `50`, etc). Only supported on reefer solutions. * `carrierReeferState`: The overall state of the reefer (`Off`, `On`). Only supported on multizone Carrier reefer solutions. * `reeferStateZone1`: The state of the reefer in zone 1. For single zone reefers, this applies tot he single zone. Only supported on multizone reefer solutions. * `reeferStateZone2`: The state of the reefer in zone 2. Only supported on multizone reefer solutions. * `reeferStateZone3`: The state of the reefer in zone 3. Only supported on multizone reefer solutions. * `reeferRunMode`: The operational mode of the reefer (`Start/Stop`, `Continuous`) * `reeferAlarms`: Any alarms that are present on the reefer. Only supported on reefer solutions. * `reeferReturnAirTemperatureMilliCZone1`: The return air temperature in zone 1 of the reefer in millidegrees Celsius. For single zone reefers, this applies to the single zone. Only supported on multizone reefer solutions. * `reeferReturnAirTemperatureMilliCZone2`: The return air temperature in zone 2 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferReturnAirTemperatureMilliCZone3`: The return air temperature in zone 3 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferSetPointTemperatureMilliCZone1`: The set point temperature in zone 1 of the reefer in millidegrees Celsius. For single zone reefers, this applies to the single zone. Only supported on multizone reefer solutions. * `reeferSetPointTemperatureMilliCZone2`: The set point temperature in zone 2 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferSetPointTemperatureMilliCZone3`: The set point temperature in zone 3 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferDoorStateZone1`: The door status in zone 1 of the reefer. For single zone reefers, this applies to the single zone. * `reeferDoorStateZone2`: The door status in zone 2 of the reefer. Only supported on multizone reefer solutions. * `reeferDoorStateZone3`: The door status in zone 3 of the reefer. Only supported on multizone reefer solutions.
        :param tag_ids: A filter on the data based on this comma-separated list of tag IDs. Example: `tagIds=1234,5678`
        :param parent_tag_ids: A filter on the data based on this comma-separated list of parent tag IDs, for use by orgs with tag hierarchies. Specifying a parent tag will implicitly include all descendent tags of the parent tag. Example: `parentTagIds=345,678`
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param trailer_ids: A filter on the data based on this comma-separated list of trailer IDs and externalIds. Example: `trailerIds=1234,5678,samsara.vin:1HGBH41JXMN109186`
        :param time: A filter on the data that returns the last known data points with timestamps less than or equal to this value. Defaults to now if not provided. Must be a string in RFC 3339 Format. Millisecond precision and timezones are supported.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetTrailerStatsSnapshotRequest(
            types=types,
            tag_ids=tag_ids,
            parent_tag_ids=parent_tag_ids,
            after=after,
            trailer_ids=trailer_ids,
            time=time,
        )

        req = self._build_request(
            method="GET",
            path="/beta/fleet/trailers/stats",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getTrailerStatsSnapshot",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.TrailerStatsGetTrailerStatsSnapshotResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsSnapshotUnauthorizedErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsSnapshotUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsSnapshotNotFoundErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsSnapshotNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsSnapshotMethodNotAllowedErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsSnapshotMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsSnapshotTooManyRequestsErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsSnapshotTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsSnapshotInternalServerErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsSnapshotInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsSnapshotNotImplementedErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsSnapshotNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsSnapshotBadGatewayErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsSnapshotBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsSnapshotServiceUnavailableErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsSnapshotServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsSnapshotGatewayTimeoutErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsSnapshotGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsSnapshotBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_trailer_stats_snapshot_async(
        self,
        *,
        types: str,
        tag_ids: Optional[str] = None,
        parent_tag_ids: Optional[str] = None,
        after: Optional[str] = None,
        trailer_ids: Optional[str] = None,
        time: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetTrailerStatsSnapshotResponse:
        r"""[beta] Get trailer stats

        Returns the last known stats of all trailers at the given `time`. If no `time` is specified, the current time is used.

        <b>Rate limit:</b> 25 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Trailer Statistics** under the Trailers category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param types: The stat types you want this endpoint to return information on.  You may list **up to 3** types using comma-separated format. For example: `types=gps,reeferAmbientAirTemperatureMilliC,gpsOdometerMeters`.  * `gps`: GPS data including lat/long, heading, speed, and a reverse geocode address. * `gpsOdometerMeters`: Odometer reading provided by GPS calculations. You must provide a manual odometer reading before this value is updated. Manual odometer readings can be provided via the PATCH /fleet/trailers/{id} endpoint or through the [cloud dashboard](https://kb.samsara.com/hc/en-us/articles/115005273667-Editing-Odometer-Reading). Odometer readings wthat are manually set will update as GPS trip data is gathered. * `reeferAmbientAirTemperatureMilliC`: The ambient air temperature reading of the reefer in millidegree Celsius. * `reeferObdEngineSeconds`: The cumulative number of seconds the reefer has run according to onboard diagnostics. Only supported on reefer solutions. * `reeferSupplyAirTemperatureMilliCZone1`: The supply or discharge air temperature zone 1 in millidegrees Celsius. For single zone reefers, this applies to the single zone. Only supported on multizone reefer solutions. * `reeferSupplyAirTemperatureMilliCZone2`: The supply or discharge air temperature zone 2 in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferSupplyAirTemperatureMilliCZone3`: The supply or discharge air temperature zone 3 in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferFuelPercent`: The fuel level of the reefer unit in percentage points (e.g. `99`, `50`, etc). Only supported on reefer solutions. * `carrierReeferState`: The overall state of the reefer (`Off`, `On`). Only supported on multizone Carrier reefer solutions. * `reeferStateZone1`: The state of the reefer in zone 1. For single zone reefers, this applies tot he single zone. Only supported on multizone reefer solutions. * `reeferStateZone2`: The state of the reefer in zone 2. Only supported on multizone reefer solutions. * `reeferStateZone3`: The state of the reefer in zone 3. Only supported on multizone reefer solutions. * `reeferRunMode`: The operational mode of the reefer (`Start/Stop`, `Continuous`) * `reeferAlarms`: Any alarms that are present on the reefer. Only supported on reefer solutions. * `reeferReturnAirTemperatureMilliCZone1`: The return air temperature in zone 1 of the reefer in millidegrees Celsius. For single zone reefers, this applies to the single zone. Only supported on multizone reefer solutions. * `reeferReturnAirTemperatureMilliCZone2`: The return air temperature in zone 2 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferReturnAirTemperatureMilliCZone3`: The return air temperature in zone 3 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferSetPointTemperatureMilliCZone1`: The set point temperature in zone 1 of the reefer in millidegrees Celsius. For single zone reefers, this applies to the single zone. Only supported on multizone reefer solutions. * `reeferSetPointTemperatureMilliCZone2`: The set point temperature in zone 2 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferSetPointTemperatureMilliCZone3`: The set point temperature in zone 3 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferDoorStateZone1`: The door status in zone 1 of the reefer. For single zone reefers, this applies to the single zone. * `reeferDoorStateZone2`: The door status in zone 2 of the reefer. Only supported on multizone reefer solutions. * `reeferDoorStateZone3`: The door status in zone 3 of the reefer. Only supported on multizone reefer solutions.
        :param tag_ids: A filter on the data based on this comma-separated list of tag IDs. Example: `tagIds=1234,5678`
        :param parent_tag_ids: A filter on the data based on this comma-separated list of parent tag IDs, for use by orgs with tag hierarchies. Specifying a parent tag will implicitly include all descendent tags of the parent tag. Example: `parentTagIds=345,678`
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param trailer_ids: A filter on the data based on this comma-separated list of trailer IDs and externalIds. Example: `trailerIds=1234,5678,samsara.vin:1HGBH41JXMN109186`
        :param time: A filter on the data that returns the last known data points with timestamps less than or equal to this value. Defaults to now if not provided. Must be a string in RFC 3339 Format. Millisecond precision and timezones are supported.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetTrailerStatsSnapshotRequest(
            types=types,
            tag_ids=tag_ids,
            parent_tag_ids=parent_tag_ids,
            after=after,
            trailer_ids=trailer_ids,
            time=time,
        )

        req = self._build_request_async(
            method="GET",
            path="/beta/fleet/trailers/stats",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getTrailerStatsSnapshot",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.TrailerStatsGetTrailerStatsSnapshotResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsSnapshotUnauthorizedErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsSnapshotUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsSnapshotNotFoundErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsSnapshotNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsSnapshotMethodNotAllowedErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsSnapshotMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsSnapshotTooManyRequestsErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsSnapshotTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsSnapshotInternalServerErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsSnapshotInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsSnapshotNotImplementedErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsSnapshotNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsSnapshotBadGatewayErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsSnapshotBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsSnapshotServiceUnavailableErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsSnapshotServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsSnapshotGatewayTimeoutErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsSnapshotGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsSnapshotBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_trailer_stats_feed(
        self,
        *,
        types: str,
        tag_ids: Optional[str] = None,
        parent_tag_ids: Optional[str] = None,
        after: Optional[str] = None,
        trailer_ids: Optional[str] = None,
        decorations: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetTrailerStatsFeedResponse:
        r"""[beta] Get trailer stats feed

        Follow a feed of trailer stats.

        The first call to this endpoint will provide the most recent stats for each trailer and an `endCursor`.

        Providing the `endCursor` value to the `after` query parameter will fetch all updates since the previous API call.

        If `hasNextPage` is false, no new data is immediately available. Please wait a minimum of 5 seconds before making a subsequent request.

        <b>Rate limit:</b> 25 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Trailer Statistics** under the Trailers category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param types: The stat types you want this endpoint to return information on.  You may list **up to 3** types using comma-separated format. For example: `types=gps,reeferAmbientAirTemperatureMilliC,gpsOdometerMeters`.  * `gps`: GPS data including lat/long, heading, speed, and a reverse geocode address. * `gpsOdometerMeters`: Odometer reading provided by GPS calculations. You must provide a manual odometer reading before this value is updated. Manual odometer readings can be provided via the PATCH /fleet/trailers/{id} endpoint or through the [cloud dashboard](https://kb.samsara.com/hc/en-us/articles/115005273667-Editing-Odometer-Reading). Odometer readings wthat are manually set will update as GPS trip data is gathered. * `reeferAmbientAirTemperatureMilliC`: The ambient air temperature reading of the reefer in millidegree Celsius. * `reeferObdEngineSeconds`: The cumulative number of seconds the reefer has run according to onboard diagnostics. Only supported on reefer solutions. * `reeferSupplyAirTemperatureMilliCZone1`: The supply or discharge air temperature zone 1 in millidegrees Celsius. For single zone reefers, this applies to the single zone. Only supported on multizone reefer solutions. * `reeferSupplyAirTemperatureMilliCZone2`: The supply or discharge air temperature zone 2 in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferSupplyAirTemperatureMilliCZone3`: The supply or discharge air temperature zone 3 in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferFuelPercent`: The fuel level of the reefer unit in percentage points (e.g. `99`, `50`, etc). Only supported on reefer solutions. * `carrierReeferState`: The overall state of the reefer (`Off`, `On`). Only supported on multizone Carrier reefer solutions. * `reeferStateZone1`: The state of the reefer in zone 1. For single zone reefers, this applies tot he single zone. Only supported on multizone reefer solutions. * `reeferStateZone2`: The state of the reefer in zone 2. Only supported on multizone reefer solutions. * `reeferStateZone3`: The state of the reefer in zone 3. Only supported on multizone reefer solutions. * `reeferRunMode`: The operational mode of the reefer (`Start/Stop`, `Continuous`) * `reeferAlarms`: Any alarms that are present on the reefer. Only supported on reefer solutions. * `reeferReturnAirTemperatureMilliCZone1`: The return air temperature in zone 1 of the reefer in millidegrees Celsius. For single zone reefers, this applies to the single zone. Only supported on multizone reefer solutions. * `reeferReturnAirTemperatureMilliCZone2`: The return air temperature in zone 2 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferReturnAirTemperatureMilliCZone3`: The return air temperature in zone 3 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferSetPointTemperatureMilliCZone1`: The set point temperature in zone 1 of the reefer in millidegrees Celsius. For single zone reefers, this applies to the single zone. Only supported on multizone reefer solutions. * `reeferSetPointTemperatureMilliCZone2`: The set point temperature in zone 2 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferSetPointTemperatureMilliCZone3`: The set point temperature in zone 3 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferDoorStateZone1`: The door status in zone 1 of the reefer. For single zone reefers, this applies to the single zone. * `reeferDoorStateZone2`: The door status in zone 2 of the reefer. Only supported on multizone reefer solutions. * `reeferDoorStateZone3`: The door status in zone 3 of the reefer. Only supported on multizone reefer solutions.
        :param tag_ids: A filter on the data based on this comma-separated list of tag IDs. Example: `tagIds=1234,5678`
        :param parent_tag_ids: A filter on the data based on this comma-separated list of parent tag IDs, for use by orgs with tag hierarchies. Specifying a parent tag will implicitly include all descendent tags of the parent tag. Example: `parentTagIds=345,678`
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param trailer_ids: A filter on the data based on this comma-separated list of trailer IDs and externalIds. Example: `trailerIds=1234,5678,samsara.vin:1HGBH41JXMN109186`
        :param decorations: Decorations add to the primary stats listed in the `types` parameter. For example, if you wish to know the trailer's location whenever the odometer updates, you may set `types=gpsOdometerMeters&decorations=gps`.  You may list **up to 2** types using comma-separated format. If multiple stats are listed in the types parameter, the decorations will be added to each type. For example: `types=reeferStateZone1,reeferAmbientAirTemperatureMilliC,gpsOdometerMeters&decorations=gps` will list GPS decorations for each reeferStateZone1 reading, each reeferAmbientAirTemperatureMilliC reding, and gpsOdometerMeters reading.  Note that decorations may significantly increase the response payload size.  * `gps`: GPS data including lat/long, heading, speed, and a reverse geocode address. * `gpsOdometerMeters`: Odometer reading provided by GPS calculations. You must provide a manual odometer reading before this value is updated. Manual odometer readings can be provided via the PATCH /fleet/trailers/{id} endpoint or through the [cloud dashboard](https://kb.samsara.com/hc/en-us/articles/115005273667-Editing-Odometer-Reading). Odometer readings wthat are manually set will update as GPS trip data is gathered. * `reeferAmbientAirTemperatureMilliC`: The ambient air temperature reading of the reefer in millidegree Celsius. * `reeferObdEngineSeconds`: The cumulative number of seconds the reefer has run according to onboard diagnostics. Only supported on reefer solutions. * `reeferSupplyAirTemperatureMilliCZone1`: The supply or discharge air temperature zone 1 in millidegrees Celsius. For single zone reefers, this applies to the single zone. Only supported on multizone reefer solutions. * `reeferSupplyAirTemperatureMilliCZone2`: The supply or discharge air temperature zone 2 in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferSupplyAirTemperatureMilliCZone3`: The supply or discharge air temperature zone 3 in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferFuelPercent`: The fuel level of the reefer unit in percentage points (e.g. `99`, `50`, etc). Only supported on reefer solutions. * `carrierReeferState`: The overall state of the reefer (`Off`, `On`). Only supported on multizone Carrier reefer solutions. * `reeferStateZone1`: The state of the reefer in zone 1. For single zone reefers, this applies tot he single zone. Only supported on multizone reefer solutions. * `reeferStateZone2`: The state of the reefer in zone 2. Only supported on multizone reefer solutions. * `reeferStateZone3`: The state of the reefer in zone 3. Only supported on multizone reefer solutions. * `reeferRunMode`: The operational mode of the reefer (`Start/Stop`, `Continuous`) * `reeferAlarms`: Any alarms that are present on the reefer. Only supported on reefer solutions. * `reeferReturnAirTemperatureMilliCZone1`: The return air temperature in zone 1 of the reefer in millidegrees Celsius. For single zone reefers, this applies to the single zone. Only supported on multizone reefer solutions. * `reeferReturnAirTemperatureMilliCZone2`: The return air temperature in zone 2 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferReturnAirTemperatureMilliCZone3`: The return air temperature in zone 3 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferSetPointTemperatureMilliCZone1`: The set point temperature in zone 1 of the reefer in millidegrees Celsius. For single zone reefers, this applies to the single zone. Only supported on multizone reefer solutions. * `reeferSetPointTemperatureMilliCZone2`: The set point temperature in zone 2 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferSetPointTemperatureMilliCZone3`: The set point temperature in zone 3 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferDoorStateZone1`: The door status in zone 1 of the reefer. For single zone reefers, this applies to the single zone. * `reeferDoorStateZone2`: The door status in zone 2 of the reefer. Only supported on multizone reefer solutions. * `reeferDoorStateZone3`: The door status in zone 3 of the reefer. Only supported on multizone reefer solutions.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetTrailerStatsFeedRequest(
            types=types,
            tag_ids=tag_ids,
            parent_tag_ids=parent_tag_ids,
            after=after,
            trailer_ids=trailer_ids,
            decorations=decorations,
        )

        req = self._build_request(
            method="GET",
            path="/beta/fleet/trailers/stats/feed",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getTrailerStatsFeed",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.TrailerStatsGetTrailerStatsFeedResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsFeedUnauthorizedErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsFeedUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsFeedNotFoundErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsFeedNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsFeedMethodNotAllowedErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsFeedMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsFeedTooManyRequestsErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsFeedTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsFeedInternalServerErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsFeedInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsFeedNotImplementedErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsFeedNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsFeedBadGatewayErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsFeedBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsFeedServiceUnavailableErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsFeedServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsFeedGatewayTimeoutErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsFeedGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsFeedBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_trailer_stats_feed_async(
        self,
        *,
        types: str,
        tag_ids: Optional[str] = None,
        parent_tag_ids: Optional[str] = None,
        after: Optional[str] = None,
        trailer_ids: Optional[str] = None,
        decorations: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetTrailerStatsFeedResponse:
        r"""[beta] Get trailer stats feed

        Follow a feed of trailer stats.

        The first call to this endpoint will provide the most recent stats for each trailer and an `endCursor`.

        Providing the `endCursor` value to the `after` query parameter will fetch all updates since the previous API call.

        If `hasNextPage` is false, no new data is immediately available. Please wait a minimum of 5 seconds before making a subsequent request.

        <b>Rate limit:</b> 25 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Trailer Statistics** under the Trailers category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param types: The stat types you want this endpoint to return information on.  You may list **up to 3** types using comma-separated format. For example: `types=gps,reeferAmbientAirTemperatureMilliC,gpsOdometerMeters`.  * `gps`: GPS data including lat/long, heading, speed, and a reverse geocode address. * `gpsOdometerMeters`: Odometer reading provided by GPS calculations. You must provide a manual odometer reading before this value is updated. Manual odometer readings can be provided via the PATCH /fleet/trailers/{id} endpoint or through the [cloud dashboard](https://kb.samsara.com/hc/en-us/articles/115005273667-Editing-Odometer-Reading). Odometer readings wthat are manually set will update as GPS trip data is gathered. * `reeferAmbientAirTemperatureMilliC`: The ambient air temperature reading of the reefer in millidegree Celsius. * `reeferObdEngineSeconds`: The cumulative number of seconds the reefer has run according to onboard diagnostics. Only supported on reefer solutions. * `reeferSupplyAirTemperatureMilliCZone1`: The supply or discharge air temperature zone 1 in millidegrees Celsius. For single zone reefers, this applies to the single zone. Only supported on multizone reefer solutions. * `reeferSupplyAirTemperatureMilliCZone2`: The supply or discharge air temperature zone 2 in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferSupplyAirTemperatureMilliCZone3`: The supply or discharge air temperature zone 3 in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferFuelPercent`: The fuel level of the reefer unit in percentage points (e.g. `99`, `50`, etc). Only supported on reefer solutions. * `carrierReeferState`: The overall state of the reefer (`Off`, `On`). Only supported on multizone Carrier reefer solutions. * `reeferStateZone1`: The state of the reefer in zone 1. For single zone reefers, this applies tot he single zone. Only supported on multizone reefer solutions. * `reeferStateZone2`: The state of the reefer in zone 2. Only supported on multizone reefer solutions. * `reeferStateZone3`: The state of the reefer in zone 3. Only supported on multizone reefer solutions. * `reeferRunMode`: The operational mode of the reefer (`Start/Stop`, `Continuous`) * `reeferAlarms`: Any alarms that are present on the reefer. Only supported on reefer solutions. * `reeferReturnAirTemperatureMilliCZone1`: The return air temperature in zone 1 of the reefer in millidegrees Celsius. For single zone reefers, this applies to the single zone. Only supported on multizone reefer solutions. * `reeferReturnAirTemperatureMilliCZone2`: The return air temperature in zone 2 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferReturnAirTemperatureMilliCZone3`: The return air temperature in zone 3 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferSetPointTemperatureMilliCZone1`: The set point temperature in zone 1 of the reefer in millidegrees Celsius. For single zone reefers, this applies to the single zone. Only supported on multizone reefer solutions. * `reeferSetPointTemperatureMilliCZone2`: The set point temperature in zone 2 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferSetPointTemperatureMilliCZone3`: The set point temperature in zone 3 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferDoorStateZone1`: The door status in zone 1 of the reefer. For single zone reefers, this applies to the single zone. * `reeferDoorStateZone2`: The door status in zone 2 of the reefer. Only supported on multizone reefer solutions. * `reeferDoorStateZone3`: The door status in zone 3 of the reefer. Only supported on multizone reefer solutions.
        :param tag_ids: A filter on the data based on this comma-separated list of tag IDs. Example: `tagIds=1234,5678`
        :param parent_tag_ids: A filter on the data based on this comma-separated list of parent tag IDs, for use by orgs with tag hierarchies. Specifying a parent tag will implicitly include all descendent tags of the parent tag. Example: `parentTagIds=345,678`
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param trailer_ids: A filter on the data based on this comma-separated list of trailer IDs and externalIds. Example: `trailerIds=1234,5678,samsara.vin:1HGBH41JXMN109186`
        :param decorations: Decorations add to the primary stats listed in the `types` parameter. For example, if you wish to know the trailer's location whenever the odometer updates, you may set `types=gpsOdometerMeters&decorations=gps`.  You may list **up to 2** types using comma-separated format. If multiple stats are listed in the types parameter, the decorations will be added to each type. For example: `types=reeferStateZone1,reeferAmbientAirTemperatureMilliC,gpsOdometerMeters&decorations=gps` will list GPS decorations for each reeferStateZone1 reading, each reeferAmbientAirTemperatureMilliC reding, and gpsOdometerMeters reading.  Note that decorations may significantly increase the response payload size.  * `gps`: GPS data including lat/long, heading, speed, and a reverse geocode address. * `gpsOdometerMeters`: Odometer reading provided by GPS calculations. You must provide a manual odometer reading before this value is updated. Manual odometer readings can be provided via the PATCH /fleet/trailers/{id} endpoint or through the [cloud dashboard](https://kb.samsara.com/hc/en-us/articles/115005273667-Editing-Odometer-Reading). Odometer readings wthat are manually set will update as GPS trip data is gathered. * `reeferAmbientAirTemperatureMilliC`: The ambient air temperature reading of the reefer in millidegree Celsius. * `reeferObdEngineSeconds`: The cumulative number of seconds the reefer has run according to onboard diagnostics. Only supported on reefer solutions. * `reeferSupplyAirTemperatureMilliCZone1`: The supply or discharge air temperature zone 1 in millidegrees Celsius. For single zone reefers, this applies to the single zone. Only supported on multizone reefer solutions. * `reeferSupplyAirTemperatureMilliCZone2`: The supply or discharge air temperature zone 2 in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferSupplyAirTemperatureMilliCZone3`: The supply or discharge air temperature zone 3 in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferFuelPercent`: The fuel level of the reefer unit in percentage points (e.g. `99`, `50`, etc). Only supported on reefer solutions. * `carrierReeferState`: The overall state of the reefer (`Off`, `On`). Only supported on multizone Carrier reefer solutions. * `reeferStateZone1`: The state of the reefer in zone 1. For single zone reefers, this applies tot he single zone. Only supported on multizone reefer solutions. * `reeferStateZone2`: The state of the reefer in zone 2. Only supported on multizone reefer solutions. * `reeferStateZone3`: The state of the reefer in zone 3. Only supported on multizone reefer solutions. * `reeferRunMode`: The operational mode of the reefer (`Start/Stop`, `Continuous`) * `reeferAlarms`: Any alarms that are present on the reefer. Only supported on reefer solutions. * `reeferReturnAirTemperatureMilliCZone1`: The return air temperature in zone 1 of the reefer in millidegrees Celsius. For single zone reefers, this applies to the single zone. Only supported on multizone reefer solutions. * `reeferReturnAirTemperatureMilliCZone2`: The return air temperature in zone 2 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferReturnAirTemperatureMilliCZone3`: The return air temperature in zone 3 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferSetPointTemperatureMilliCZone1`: The set point temperature in zone 1 of the reefer in millidegrees Celsius. For single zone reefers, this applies to the single zone. Only supported on multizone reefer solutions. * `reeferSetPointTemperatureMilliCZone2`: The set point temperature in zone 2 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferSetPointTemperatureMilliCZone3`: The set point temperature in zone 3 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferDoorStateZone1`: The door status in zone 1 of the reefer. For single zone reefers, this applies to the single zone. * `reeferDoorStateZone2`: The door status in zone 2 of the reefer. Only supported on multizone reefer solutions. * `reeferDoorStateZone3`: The door status in zone 3 of the reefer. Only supported on multizone reefer solutions.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetTrailerStatsFeedRequest(
            types=types,
            tag_ids=tag_ids,
            parent_tag_ids=parent_tag_ids,
            after=after,
            trailer_ids=trailer_ids,
            decorations=decorations,
        )

        req = self._build_request_async(
            method="GET",
            path="/beta/fleet/trailers/stats/feed",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getTrailerStatsFeed",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.TrailerStatsGetTrailerStatsFeedResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsFeedUnauthorizedErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsFeedUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsFeedNotFoundErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsFeedNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsFeedMethodNotAllowedErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsFeedMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsFeedTooManyRequestsErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsFeedTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsFeedInternalServerErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsFeedInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsFeedNotImplementedErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsFeedNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsFeedBadGatewayErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsFeedBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsFeedServiceUnavailableErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsFeedServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsFeedGatewayTimeoutErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsFeedGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsFeedBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_trailer_stats_history(
        self,
        *,
        start_time: str,
        end_time: str,
        types: str,
        tag_ids: Optional[str] = None,
        parent_tag_ids: Optional[str] = None,
        after: Optional[str] = None,
        trailer_ids: Optional[str] = None,
        decorations: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetTrailerStatsHistoryResponse:
        r"""[beta] Get trailer stats history

        Returns trailer stats during the given time range for all trailers. This can be optionally filtered by tags or specific trailer IDs.

        <b>Rate limit:</b> 10 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Trailer Statistics** under the Trailers category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param start_time: A start time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param end_time: An end time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param types: The stat types you want this endpoint to return information on.  You may list **up to 3** types using comma-separated format. For example: `types=gps,reeferAmbientAirTemperatureMilliC,gpsOdometerMeters`.  * `gps`: GPS data including lat/long, heading, speed, and a reverse geocode address. * `gpsOdometerMeters`: Odometer reading provided by GPS calculations. You must provide a manual odometer reading before this value is updated. Manual odometer readings can be provided via the PATCH /fleet/trailers/{id} endpoint or through the [cloud dashboard](https://kb.samsara.com/hc/en-us/articles/115005273667-Editing-Odometer-Reading). Odometer readings wthat are manually set will update as GPS trip data is gathered. * `reeferAmbientAirTemperatureMilliC`: The ambient air temperature reading of the reefer in millidegree Celsius. * `reeferObdEngineSeconds`: The cumulative number of seconds the reefer has run according to onboard diagnostics. Only supported on reefer solutions. * `reeferSupplyAirTemperatureMilliCZone1`: The supply or discharge air temperature zone 1 in millidegrees Celsius. For single zone reefers, this applies to the single zone. Only supported on multizone reefer solutions. * `reeferSupplyAirTemperatureMilliCZone2`: The supply or discharge air temperature zone 2 in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferSupplyAirTemperatureMilliCZone3`: The supply or discharge air temperature zone 3 in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferFuelPercent`: The fuel level of the reefer unit in percentage points (e.g. `99`, `50`, etc). Only supported on reefer solutions. * `carrierReeferState`: The overall state of the reefer (`Off`, `On`). Only supported on multizone Carrier reefer solutions. * `reeferStateZone1`: The state of the reefer in zone 1. For single zone reefers, this applies tot he single zone. Only supported on multizone reefer solutions. * `reeferStateZone2`: The state of the reefer in zone 2. Only supported on multizone reefer solutions. * `reeferStateZone3`: The state of the reefer in zone 3. Only supported on multizone reefer solutions. * `reeferRunMode`: The operational mode of the reefer (`Start/Stop`, `Continuous`) * `reeferAlarms`: Any alarms that are present on the reefer. Only supported on reefer solutions. * `reeferReturnAirTemperatureMilliCZone1`: The return air temperature in zone 1 of the reefer in millidegrees Celsius. For single zone reefers, this applies to the single zone. Only supported on multizone reefer solutions. * `reeferReturnAirTemperatureMilliCZone2`: The return air temperature in zone 2 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferReturnAirTemperatureMilliCZone3`: The return air temperature in zone 3 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferSetPointTemperatureMilliCZone1`: The set point temperature in zone 1 of the reefer in millidegrees Celsius. For single zone reefers, this applies to the single zone. Only supported on multizone reefer solutions. * `reeferSetPointTemperatureMilliCZone2`: The set point temperature in zone 2 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferSetPointTemperatureMilliCZone3`: The set point temperature in zone 3 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferDoorStateZone1`: The door status in zone 1 of the reefer. For single zone reefers, this applies to the single zone. * `reeferDoorStateZone2`: The door status in zone 2 of the reefer. Only supported on multizone reefer solutions. * `reeferDoorStateZone3`: The door status in zone 3 of the reefer. Only supported on multizone reefer solutions.
        :param tag_ids: A filter on the data based on this comma-separated list of tag IDs. Example: `tagIds=1234,5678`
        :param parent_tag_ids: A filter on the data based on this comma-separated list of parent tag IDs, for use by orgs with tag hierarchies. Specifying a parent tag will implicitly include all descendent tags of the parent tag. Example: `parentTagIds=345,678`
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param trailer_ids: A filter on the data based on this comma-separated list of trailer IDs and externalIds. Example: `trailerIds=1234,5678,samsara.vin:1HGBH41JXMN109186`
        :param decorations: Decorations add to the primary stats listed in the `types` parameter. For example, if you wish to know the trailer's location whenever the odometer updates, you may set `types=gpsOdometerMeters&decorations=gps`.  You may list **up to 2** types using comma-separated format. If multiple stats are listed in the types parameter, the decorations will be added to each type. For example: `types=reeferStateZone1,reeferAmbientAirTemperatureMilliC,gpsOdometerMeters&decorations=gps` will list GPS decorations for each reeferStateZone1 reading, each reeferAmbientAirTemperatureMilliC reding, and gpsOdometerMeters reading.  Note that decorations may significantly increase the response payload size.  * `gps`: GPS data including lat/long, heading, speed, and a reverse geocode address. * `gpsOdometerMeters`: Odometer reading provided by GPS calculations. You must provide a manual odometer reading before this value is updated. Manual odometer readings can be provided via the PATCH /fleet/trailers/{id} endpoint or through the [cloud dashboard](https://kb.samsara.com/hc/en-us/articles/115005273667-Editing-Odometer-Reading). Odometer readings wthat are manually set will update as GPS trip data is gathered. * `reeferAmbientAirTemperatureMilliC`: The ambient air temperature reading of the reefer in millidegree Celsius. * `reeferObdEngineSeconds`: The cumulative number of seconds the reefer has run according to onboard diagnostics. Only supported on reefer solutions. * `reeferSupplyAirTemperatureMilliCZone1`: The supply or discharge air temperature zone 1 in millidegrees Celsius. For single zone reefers, this applies to the single zone. Only supported on multizone reefer solutions. * `reeferSupplyAirTemperatureMilliCZone2`: The supply or discharge air temperature zone 2 in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferSupplyAirTemperatureMilliCZone3`: The supply or discharge air temperature zone 3 in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferFuelPercent`: The fuel level of the reefer unit in percentage points (e.g. `99`, `50`, etc). Only supported on reefer solutions. * `carrierReeferState`: The overall state of the reefer (`Off`, `On`). Only supported on multizone Carrier reefer solutions. * `reeferStateZone1`: The state of the reefer in zone 1. For single zone reefers, this applies tot he single zone. Only supported on multizone reefer solutions. * `reeferStateZone2`: The state of the reefer in zone 2. Only supported on multizone reefer solutions. * `reeferStateZone3`: The state of the reefer in zone 3. Only supported on multizone reefer solutions. * `reeferRunMode`: The operational mode of the reefer (`Start/Stop`, `Continuous`) * `reeferAlarms`: Any alarms that are present on the reefer. Only supported on reefer solutions. * `reeferReturnAirTemperatureMilliCZone1`: The return air temperature in zone 1 of the reefer in millidegrees Celsius. For single zone reefers, this applies to the single zone. Only supported on multizone reefer solutions. * `reeferReturnAirTemperatureMilliCZone2`: The return air temperature in zone 2 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferReturnAirTemperatureMilliCZone3`: The return air temperature in zone 3 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferSetPointTemperatureMilliCZone1`: The set point temperature in zone 1 of the reefer in millidegrees Celsius. For single zone reefers, this applies to the single zone. Only supported on multizone reefer solutions. * `reeferSetPointTemperatureMilliCZone2`: The set point temperature in zone 2 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferSetPointTemperatureMilliCZone3`: The set point temperature in zone 3 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferDoorStateZone1`: The door status in zone 1 of the reefer. For single zone reefers, this applies to the single zone. * `reeferDoorStateZone2`: The door status in zone 2 of the reefer. Only supported on multizone reefer solutions. * `reeferDoorStateZone3`: The door status in zone 3 of the reefer. Only supported on multizone reefer solutions.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetTrailerStatsHistoryRequest(
            start_time=start_time,
            end_time=end_time,
            types=types,
            tag_ids=tag_ids,
            parent_tag_ids=parent_tag_ids,
            after=after,
            trailer_ids=trailer_ids,
            decorations=decorations,
        )

        req = self._build_request(
            method="GET",
            path="/beta/fleet/trailers/stats/history",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getTrailerStatsHistory",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.TrailerStatsGetTrailerStatsHistoryResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsHistoryUnauthorizedErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsHistoryUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsHistoryNotFoundErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsHistoryNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsHistoryMethodNotAllowedErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsHistoryMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsHistoryTooManyRequestsErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsHistoryTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsHistoryInternalServerErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsHistoryInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsHistoryNotImplementedErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsHistoryNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsHistoryBadGatewayErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsHistoryBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsHistoryServiceUnavailableErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsHistoryServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsHistoryGatewayTimeoutErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsHistoryGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsHistoryBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_trailer_stats_history_async(
        self,
        *,
        start_time: str,
        end_time: str,
        types: str,
        tag_ids: Optional[str] = None,
        parent_tag_ids: Optional[str] = None,
        after: Optional[str] = None,
        trailer_ids: Optional[str] = None,
        decorations: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetTrailerStatsHistoryResponse:
        r"""[beta] Get trailer stats history

        Returns trailer stats during the given time range for all trailers. This can be optionally filtered by tags or specific trailer IDs.

        <b>Rate limit:</b> 10 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Trailer Statistics** under the Trailers category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param start_time: A start time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param end_time: An end time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param types: The stat types you want this endpoint to return information on.  You may list **up to 3** types using comma-separated format. For example: `types=gps,reeferAmbientAirTemperatureMilliC,gpsOdometerMeters`.  * `gps`: GPS data including lat/long, heading, speed, and a reverse geocode address. * `gpsOdometerMeters`: Odometer reading provided by GPS calculations. You must provide a manual odometer reading before this value is updated. Manual odometer readings can be provided via the PATCH /fleet/trailers/{id} endpoint or through the [cloud dashboard](https://kb.samsara.com/hc/en-us/articles/115005273667-Editing-Odometer-Reading). Odometer readings wthat are manually set will update as GPS trip data is gathered. * `reeferAmbientAirTemperatureMilliC`: The ambient air temperature reading of the reefer in millidegree Celsius. * `reeferObdEngineSeconds`: The cumulative number of seconds the reefer has run according to onboard diagnostics. Only supported on reefer solutions. * `reeferSupplyAirTemperatureMilliCZone1`: The supply or discharge air temperature zone 1 in millidegrees Celsius. For single zone reefers, this applies to the single zone. Only supported on multizone reefer solutions. * `reeferSupplyAirTemperatureMilliCZone2`: The supply or discharge air temperature zone 2 in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferSupplyAirTemperatureMilliCZone3`: The supply or discharge air temperature zone 3 in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferFuelPercent`: The fuel level of the reefer unit in percentage points (e.g. `99`, `50`, etc). Only supported on reefer solutions. * `carrierReeferState`: The overall state of the reefer (`Off`, `On`). Only supported on multizone Carrier reefer solutions. * `reeferStateZone1`: The state of the reefer in zone 1. For single zone reefers, this applies tot he single zone. Only supported on multizone reefer solutions. * `reeferStateZone2`: The state of the reefer in zone 2. Only supported on multizone reefer solutions. * `reeferStateZone3`: The state of the reefer in zone 3. Only supported on multizone reefer solutions. * `reeferRunMode`: The operational mode of the reefer (`Start/Stop`, `Continuous`) * `reeferAlarms`: Any alarms that are present on the reefer. Only supported on reefer solutions. * `reeferReturnAirTemperatureMilliCZone1`: The return air temperature in zone 1 of the reefer in millidegrees Celsius. For single zone reefers, this applies to the single zone. Only supported on multizone reefer solutions. * `reeferReturnAirTemperatureMilliCZone2`: The return air temperature in zone 2 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferReturnAirTemperatureMilliCZone3`: The return air temperature in zone 3 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferSetPointTemperatureMilliCZone1`: The set point temperature in zone 1 of the reefer in millidegrees Celsius. For single zone reefers, this applies to the single zone. Only supported on multizone reefer solutions. * `reeferSetPointTemperatureMilliCZone2`: The set point temperature in zone 2 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferSetPointTemperatureMilliCZone3`: The set point temperature in zone 3 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferDoorStateZone1`: The door status in zone 1 of the reefer. For single zone reefers, this applies to the single zone. * `reeferDoorStateZone2`: The door status in zone 2 of the reefer. Only supported on multizone reefer solutions. * `reeferDoorStateZone3`: The door status in zone 3 of the reefer. Only supported on multizone reefer solutions.
        :param tag_ids: A filter on the data based on this comma-separated list of tag IDs. Example: `tagIds=1234,5678`
        :param parent_tag_ids: A filter on the data based on this comma-separated list of parent tag IDs, for use by orgs with tag hierarchies. Specifying a parent tag will implicitly include all descendent tags of the parent tag. Example: `parentTagIds=345,678`
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param trailer_ids: A filter on the data based on this comma-separated list of trailer IDs and externalIds. Example: `trailerIds=1234,5678,samsara.vin:1HGBH41JXMN109186`
        :param decorations: Decorations add to the primary stats listed in the `types` parameter. For example, if you wish to know the trailer's location whenever the odometer updates, you may set `types=gpsOdometerMeters&decorations=gps`.  You may list **up to 2** types using comma-separated format. If multiple stats are listed in the types parameter, the decorations will be added to each type. For example: `types=reeferStateZone1,reeferAmbientAirTemperatureMilliC,gpsOdometerMeters&decorations=gps` will list GPS decorations for each reeferStateZone1 reading, each reeferAmbientAirTemperatureMilliC reding, and gpsOdometerMeters reading.  Note that decorations may significantly increase the response payload size.  * `gps`: GPS data including lat/long, heading, speed, and a reverse geocode address. * `gpsOdometerMeters`: Odometer reading provided by GPS calculations. You must provide a manual odometer reading before this value is updated. Manual odometer readings can be provided via the PATCH /fleet/trailers/{id} endpoint or through the [cloud dashboard](https://kb.samsara.com/hc/en-us/articles/115005273667-Editing-Odometer-Reading). Odometer readings wthat are manually set will update as GPS trip data is gathered. * `reeferAmbientAirTemperatureMilliC`: The ambient air temperature reading of the reefer in millidegree Celsius. * `reeferObdEngineSeconds`: The cumulative number of seconds the reefer has run according to onboard diagnostics. Only supported on reefer solutions. * `reeferSupplyAirTemperatureMilliCZone1`: The supply or discharge air temperature zone 1 in millidegrees Celsius. For single zone reefers, this applies to the single zone. Only supported on multizone reefer solutions. * `reeferSupplyAirTemperatureMilliCZone2`: The supply or discharge air temperature zone 2 in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferSupplyAirTemperatureMilliCZone3`: The supply or discharge air temperature zone 3 in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferFuelPercent`: The fuel level of the reefer unit in percentage points (e.g. `99`, `50`, etc). Only supported on reefer solutions. * `carrierReeferState`: The overall state of the reefer (`Off`, `On`). Only supported on multizone Carrier reefer solutions. * `reeferStateZone1`: The state of the reefer in zone 1. For single zone reefers, this applies tot he single zone. Only supported on multizone reefer solutions. * `reeferStateZone2`: The state of the reefer in zone 2. Only supported on multizone reefer solutions. * `reeferStateZone3`: The state of the reefer in zone 3. Only supported on multizone reefer solutions. * `reeferRunMode`: The operational mode of the reefer (`Start/Stop`, `Continuous`) * `reeferAlarms`: Any alarms that are present on the reefer. Only supported on reefer solutions. * `reeferReturnAirTemperatureMilliCZone1`: The return air temperature in zone 1 of the reefer in millidegrees Celsius. For single zone reefers, this applies to the single zone. Only supported on multizone reefer solutions. * `reeferReturnAirTemperatureMilliCZone2`: The return air temperature in zone 2 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferReturnAirTemperatureMilliCZone3`: The return air temperature in zone 3 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferSetPointTemperatureMilliCZone1`: The set point temperature in zone 1 of the reefer in millidegrees Celsius. For single zone reefers, this applies to the single zone. Only supported on multizone reefer solutions. * `reeferSetPointTemperatureMilliCZone2`: The set point temperature in zone 2 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferSetPointTemperatureMilliCZone3`: The set point temperature in zone 3 of the reefer in millidegrees Celsius. Only supported on multizone reefer solutions. * `reeferDoorStateZone1`: The door status in zone 1 of the reefer. For single zone reefers, this applies to the single zone. * `reeferDoorStateZone2`: The door status in zone 2 of the reefer. Only supported on multizone reefer solutions. * `reeferDoorStateZone3`: The door status in zone 3 of the reefer. Only supported on multizone reefer solutions.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetTrailerStatsHistoryRequest(
            start_time=start_time,
            end_time=end_time,
            types=types,
            tag_ids=tag_ids,
            parent_tag_ids=parent_tag_ids,
            after=after,
            trailer_ids=trailer_ids,
            decorations=decorations,
        )

        req = self._build_request_async(
            method="GET",
            path="/beta/fleet/trailers/stats/history",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getTrailerStatsHistory",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.TrailerStatsGetTrailerStatsHistoryResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsHistoryUnauthorizedErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsHistoryUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsHistoryNotFoundErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsHistoryNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsHistoryMethodNotAllowedErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsHistoryMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsHistoryTooManyRequestsErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsHistoryTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsHistoryInternalServerErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsHistoryInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsHistoryNotImplementedErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsHistoryNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsHistoryBadGatewayErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsHistoryBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsHistoryServiceUnavailableErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsHistoryServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsHistoryGatewayTimeoutErrorResponseBodyData,
            )
            raise models.TrailerStatsGetTrailerStatsHistoryGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.TrailerStatsGetTrailerStatsHistoryBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def update_engine_immobilizer_state(
        self,
        *,
        id: int,
        relay_states: Union[
            List[models.UpdateEngineImmobilizerRelayStateRequestBodyRequestBody],
            List[
                models.UpdateEngineImmobilizerRelayStateRequestBodyRequestBodyTypedDict
            ],
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[
        models.EngineImmobilizerUpdateEngineImmobilizerStateBadRequestErrorResponseBody
    ]:
        r"""[beta] Update engine immobilizer state of a vehicle.

        Update the engine immobilizer state of a vehicle. This requires an engine immobilizer to be installed on the vehicle gateway.

        <b>Rate limit:</b> 100 requests/min (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write Vehicle Immobilization** under the Vehicles category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param id: Vehicle ID
        :param relay_states: A list of relay states. If a relay is omitted, its state won't be updated. If the list is empty, a 400 bad request status code will be returned. If there are multiple states for the same relay, a 400 bad request status code will be returned.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.UpdateEngineImmobilizerStateRequest(
            id=id,
            engine_immobilizer_update_engine_immobilizer_state_request_body=models.EngineImmobilizerUpdateEngineImmobilizerStateRequestBody(
                relay_states=utils.get_pydantic_model(
                    relay_states,
                    List[
                        models.UpdateEngineImmobilizerRelayStateRequestBodyRequestBody
                    ],
                ),
            ),
        )

        req = self._build_request(
            method="PATCH",
            path="/beta/fleet/vehicles/{id}/immobilizer",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.engine_immobilizer_update_engine_immobilizer_state_request_body,
                False,
                False,
                "json",
                models.EngineImmobilizerUpdateEngineImmobilizerStateRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="updateEngineImmobilizerState",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "202", "*"):
            return None
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerUpdateEngineImmobilizerStateUnauthorizedErrorResponseBodyData,
            )
            raise models.EngineImmobilizerUpdateEngineImmobilizerStateUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerUpdateEngineImmobilizerStateNotFoundErrorResponseBodyData,
            )
            raise models.EngineImmobilizerUpdateEngineImmobilizerStateNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerUpdateEngineImmobilizerStateMethodNotAllowedErrorResponseBodyData,
            )
            raise models.EngineImmobilizerUpdateEngineImmobilizerStateMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerUpdateEngineImmobilizerStateTooManyRequestsErrorResponseBodyData,
            )
            raise models.EngineImmobilizerUpdateEngineImmobilizerStateTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerUpdateEngineImmobilizerStateInternalServerErrorResponseBodyData,
            )
            raise models.EngineImmobilizerUpdateEngineImmobilizerStateInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerUpdateEngineImmobilizerStateNotImplementedErrorResponseBodyData,
            )
            raise models.EngineImmobilizerUpdateEngineImmobilizerStateNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerUpdateEngineImmobilizerStateBadGatewayErrorResponseBodyData,
            )
            raise models.EngineImmobilizerUpdateEngineImmobilizerStateBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerUpdateEngineImmobilizerStateServiceUnavailableErrorResponseBodyData,
            )
            raise models.EngineImmobilizerUpdateEngineImmobilizerStateServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerUpdateEngineImmobilizerStateGatewayTimeoutErrorResponseBodyData,
            )
            raise models.EngineImmobilizerUpdateEngineImmobilizerStateGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerUpdateEngineImmobilizerStateBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def update_engine_immobilizer_state_async(
        self,
        *,
        id: int,
        relay_states: Union[
            List[models.UpdateEngineImmobilizerRelayStateRequestBodyRequestBody],
            List[
                models.UpdateEngineImmobilizerRelayStateRequestBodyRequestBodyTypedDict
            ],
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[
        models.EngineImmobilizerUpdateEngineImmobilizerStateBadRequestErrorResponseBody
    ]:
        r"""[beta] Update engine immobilizer state of a vehicle.

        Update the engine immobilizer state of a vehicle. This requires an engine immobilizer to be installed on the vehicle gateway.

        <b>Rate limit:</b> 100 requests/min (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write Vehicle Immobilization** under the Vehicles category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param id: Vehicle ID
        :param relay_states: A list of relay states. If a relay is omitted, its state won't be updated. If the list is empty, a 400 bad request status code will be returned. If there are multiple states for the same relay, a 400 bad request status code will be returned.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.UpdateEngineImmobilizerStateRequest(
            id=id,
            engine_immobilizer_update_engine_immobilizer_state_request_body=models.EngineImmobilizerUpdateEngineImmobilizerStateRequestBody(
                relay_states=utils.get_pydantic_model(
                    relay_states,
                    List[
                        models.UpdateEngineImmobilizerRelayStateRequestBodyRequestBody
                    ],
                ),
            ),
        )

        req = self._build_request_async(
            method="PATCH",
            path="/beta/fleet/vehicles/{id}/immobilizer",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.engine_immobilizer_update_engine_immobilizer_state_request_body,
                False,
                False,
                "json",
                models.EngineImmobilizerUpdateEngineImmobilizerStateRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="updateEngineImmobilizerState",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "202", "*"):
            return None
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerUpdateEngineImmobilizerStateUnauthorizedErrorResponseBodyData,
            )
            raise models.EngineImmobilizerUpdateEngineImmobilizerStateUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerUpdateEngineImmobilizerStateNotFoundErrorResponseBodyData,
            )
            raise models.EngineImmobilizerUpdateEngineImmobilizerStateNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerUpdateEngineImmobilizerStateMethodNotAllowedErrorResponseBodyData,
            )
            raise models.EngineImmobilizerUpdateEngineImmobilizerStateMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerUpdateEngineImmobilizerStateTooManyRequestsErrorResponseBodyData,
            )
            raise models.EngineImmobilizerUpdateEngineImmobilizerStateTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerUpdateEngineImmobilizerStateInternalServerErrorResponseBodyData,
            )
            raise models.EngineImmobilizerUpdateEngineImmobilizerStateInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerUpdateEngineImmobilizerStateNotImplementedErrorResponseBodyData,
            )
            raise models.EngineImmobilizerUpdateEngineImmobilizerStateNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerUpdateEngineImmobilizerStateBadGatewayErrorResponseBodyData,
            )
            raise models.EngineImmobilizerUpdateEngineImmobilizerStateBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerUpdateEngineImmobilizerStateServiceUnavailableErrorResponseBodyData,
            )
            raise models.EngineImmobilizerUpdateEngineImmobilizerStateServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerUpdateEngineImmobilizerStateGatewayTimeoutErrorResponseBodyData,
            )
            raise models.EngineImmobilizerUpdateEngineImmobilizerStateGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerUpdateEngineImmobilizerStateBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def delete_job(
        self,
        *,
        id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DeleteJobResponse:
        r"""[beta] Deletes an existing job

        Deletes an existing job.

        To use this endpoint, select **Write Jobs** under the Equipment category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param id: A jobId or uuid in STRING format. JobId must be prefixed with `jobId:`(Examples: `\"8d218e6c-7a16-4f9f-90f7-cc1d93b9e596\"`, `\"jobId:98765\"`).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.DeleteJobRequest(
            id=id,
        )

        req = self._build_request(
            method="DELETE",
            path="/beta/industrial/jobs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="deleteJob",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.JobsDeleteJobResponseBody)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsDeleteJobUnauthorizedErrorResponseBodyData
            )
            raise models.JobsDeleteJobUnauthorizedErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsDeleteJobNotFoundErrorResponseBodyData
            )
            raise models.JobsDeleteJobNotFoundErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsDeleteJobMethodNotAllowedErrorResponseBodyData
            )
            raise models.JobsDeleteJobMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsDeleteJobTooManyRequestsErrorResponseBodyData
            )
            raise models.JobsDeleteJobTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsDeleteJobInternalServerErrorResponseBodyData
            )
            raise models.JobsDeleteJobInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsDeleteJobNotImplementedErrorResponseBodyData
            )
            raise models.JobsDeleteJobNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsDeleteJobBadGatewayErrorResponseBodyData
            )
            raise models.JobsDeleteJobBadGatewayErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.JobsDeleteJobServiceUnavailableErrorResponseBodyData,
            )
            raise models.JobsDeleteJobServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsDeleteJobGatewayTimeoutErrorResponseBodyData
            )
            raise models.JobsDeleteJobGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.JobsDeleteJobBadRequestErrorResponseBody
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def delete_job_async(
        self,
        *,
        id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DeleteJobResponse:
        r"""[beta] Deletes an existing job

        Deletes an existing job.

        To use this endpoint, select **Write Jobs** under the Equipment category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param id: A jobId or uuid in STRING format. JobId must be prefixed with `jobId:`(Examples: `\"8d218e6c-7a16-4f9f-90f7-cc1d93b9e596\"`, `\"jobId:98765\"`).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.DeleteJobRequest(
            id=id,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/beta/industrial/jobs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="deleteJob",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.JobsDeleteJobResponseBody)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsDeleteJobUnauthorizedErrorResponseBodyData
            )
            raise models.JobsDeleteJobUnauthorizedErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsDeleteJobNotFoundErrorResponseBodyData
            )
            raise models.JobsDeleteJobNotFoundErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsDeleteJobMethodNotAllowedErrorResponseBodyData
            )
            raise models.JobsDeleteJobMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsDeleteJobTooManyRequestsErrorResponseBodyData
            )
            raise models.JobsDeleteJobTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsDeleteJobInternalServerErrorResponseBodyData
            )
            raise models.JobsDeleteJobInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsDeleteJobNotImplementedErrorResponseBodyData
            )
            raise models.JobsDeleteJobNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsDeleteJobBadGatewayErrorResponseBodyData
            )
            raise models.JobsDeleteJobBadGatewayErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.JobsDeleteJobServiceUnavailableErrorResponseBodyData,
            )
            raise models.JobsDeleteJobServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsDeleteJobGatewayTimeoutErrorResponseBodyData
            )
            raise models.JobsDeleteJobGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.JobsDeleteJobBadRequestErrorResponseBody
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_jobs(
        self,
        *,
        id: Optional[str] = None,
        start_date: Optional[str] = None,
        end_date: Optional[str] = None,
        industrial_asset_ids: Optional[List[str]] = None,
        fleet_device_ids: Optional[List[int]] = None,
        status: Optional[models.GetJobsQueryParamStatus] = None,
        customer_name: Optional[str] = None,
        after: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetJobsResponse:
        r"""[beta] Fetches all jobs

        Fetches jobs based on id/uuid or provided filters.

        To use this endpoint, select **Read Jobs** under the Equipment category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param id: A jobId or uuid in STRING format. JobId must be prefixed with `jobId:`(Examples: `\"8d218e6c-7a16-4f9f-90f7-cc1d93b9e596\"`, `\"jobId:98765\"`).
        :param start_date: A start time in RFC 3339 format. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param end_date: An end time in RFC 3339 format. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param industrial_asset_ids: IndustrialAssetId in STRING format. (Example: `\"8d218e6c-7a16-4f9f-90f7-cc1d93b9e596\"`).
        :param fleet_device_ids: FleetDeviceId in INTEGER format. (Example: `123456`).
        :param status: A job status in STRING format. Job statuses can be one of three (ignores case): `\"active\", \"scheduled\", \"completed\"`  Valid values: `active`, `scheduled`, `completed`
        :param customer_name: Customer name to filter by
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetJobsRequest(
            id=id,
            start_date=start_date,
            end_date=end_date,
            industrial_asset_ids=industrial_asset_ids,
            fleet_device_ids=fleet_device_ids,
            status=status,
            customer_name=customer_name,
            after=after,
        )

        req = self._build_request(
            method="GET",
            path="/beta/industrial/jobs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getJobs",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.JobsGetJobsResponseBody)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsGetJobsUnauthorizedErrorResponseBodyData
            )
            raise models.JobsGetJobsUnauthorizedErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsGetJobsNotFoundErrorResponseBodyData
            )
            raise models.JobsGetJobsNotFoundErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsGetJobsMethodNotAllowedErrorResponseBodyData
            )
            raise models.JobsGetJobsMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsGetJobsTooManyRequestsErrorResponseBodyData
            )
            raise models.JobsGetJobsTooManyRequestsErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsGetJobsInternalServerErrorResponseBodyData
            )
            raise models.JobsGetJobsInternalServerErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsGetJobsNotImplementedErrorResponseBodyData
            )
            raise models.JobsGetJobsNotImplementedErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsGetJobsBadGatewayErrorResponseBodyData
            )
            raise models.JobsGetJobsBadGatewayErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsGetJobsServiceUnavailableErrorResponseBodyData
            )
            raise models.JobsGetJobsServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsGetJobsGatewayTimeoutErrorResponseBodyData
            )
            raise models.JobsGetJobsGatewayTimeoutErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.JobsGetJobsBadRequestErrorResponseBody
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_jobs_async(
        self,
        *,
        id: Optional[str] = None,
        start_date: Optional[str] = None,
        end_date: Optional[str] = None,
        industrial_asset_ids: Optional[List[str]] = None,
        fleet_device_ids: Optional[List[int]] = None,
        status: Optional[models.GetJobsQueryParamStatus] = None,
        customer_name: Optional[str] = None,
        after: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetJobsResponse:
        r"""[beta] Fetches all jobs

        Fetches jobs based on id/uuid or provided filters.

        To use this endpoint, select **Read Jobs** under the Equipment category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param id: A jobId or uuid in STRING format. JobId must be prefixed with `jobId:`(Examples: `\"8d218e6c-7a16-4f9f-90f7-cc1d93b9e596\"`, `\"jobId:98765\"`).
        :param start_date: A start time in RFC 3339 format. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param end_date: An end time in RFC 3339 format. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param industrial_asset_ids: IndustrialAssetId in STRING format. (Example: `\"8d218e6c-7a16-4f9f-90f7-cc1d93b9e596\"`).
        :param fleet_device_ids: FleetDeviceId in INTEGER format. (Example: `123456`).
        :param status: A job status in STRING format. Job statuses can be one of three (ignores case): `\"active\", \"scheduled\", \"completed\"`  Valid values: `active`, `scheduled`, `completed`
        :param customer_name: Customer name to filter by
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetJobsRequest(
            id=id,
            start_date=start_date,
            end_date=end_date,
            industrial_asset_ids=industrial_asset_ids,
            fleet_device_ids=fleet_device_ids,
            status=status,
            customer_name=customer_name,
            after=after,
        )

        req = self._build_request_async(
            method="GET",
            path="/beta/industrial/jobs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getJobs",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.JobsGetJobsResponseBody)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsGetJobsUnauthorizedErrorResponseBodyData
            )
            raise models.JobsGetJobsUnauthorizedErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsGetJobsNotFoundErrorResponseBodyData
            )
            raise models.JobsGetJobsNotFoundErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsGetJobsMethodNotAllowedErrorResponseBodyData
            )
            raise models.JobsGetJobsMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsGetJobsTooManyRequestsErrorResponseBodyData
            )
            raise models.JobsGetJobsTooManyRequestsErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsGetJobsInternalServerErrorResponseBodyData
            )
            raise models.JobsGetJobsInternalServerErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsGetJobsNotImplementedErrorResponseBodyData
            )
            raise models.JobsGetJobsNotImplementedErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsGetJobsBadGatewayErrorResponseBodyData
            )
            raise models.JobsGetJobsBadGatewayErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsGetJobsServiceUnavailableErrorResponseBodyData
            )
            raise models.JobsGetJobsServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsGetJobsGatewayTimeoutErrorResponseBodyData
            )
            raise models.JobsGetJobsGatewayTimeoutErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.JobsGetJobsBadRequestErrorResponseBody
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def patch_job(
        self,
        *,
        id: str,
        job: Union[
            models.PatchJobObjectRequestBody, models.PatchJobObjectRequestBodyTypedDict
        ],
        keep_history: Optional[bool] = True,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PatchJobResponse:
        r"""[beta] Patches a job

        Patches an existing job and returns it.

        To use this endpoint, select **Write Jobs** under the Equipment category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param id: A jobId or uuid in STRING format. JobId must be prefixed with `jobId:`(Examples: `\"8d218e6c-7a16-4f9f-90f7-cc1d93b9e596\"`, `\"jobId:98765\"`).
        :param job: Job object with fields to update. If a field is not provided, it will not be updated
        :param keep_history: Defaults to true if user does not want to overwrite entire history for an active job (irrelevant for scheduled/completed jobs)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.PatchJobRequest(
            id=id,
            jobs_patch_job_request_body=models.JobsPatchJobRequestBody(
                job=utils.get_pydantic_model(job, models.PatchJobObjectRequestBody),
                keep_history=keep_history,
            ),
        )

        req = self._build_request(
            method="PATCH",
            path="/beta/industrial/jobs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.jobs_patch_job_request_body,
                False,
                False,
                "json",
                models.JobsPatchJobRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="patchJob",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.JobsPatchJobResponseBody)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsPatchJobUnauthorizedErrorResponseBodyData
            )
            raise models.JobsPatchJobUnauthorizedErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsPatchJobNotFoundErrorResponseBodyData
            )
            raise models.JobsPatchJobNotFoundErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsPatchJobMethodNotAllowedErrorResponseBodyData
            )
            raise models.JobsPatchJobMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsPatchJobTooManyRequestsErrorResponseBodyData
            )
            raise models.JobsPatchJobTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsPatchJobInternalServerErrorResponseBodyData
            )
            raise models.JobsPatchJobInternalServerErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsPatchJobNotImplementedErrorResponseBodyData
            )
            raise models.JobsPatchJobNotImplementedErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsPatchJobBadGatewayErrorResponseBodyData
            )
            raise models.JobsPatchJobBadGatewayErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.JobsPatchJobServiceUnavailableErrorResponseBodyData,
            )
            raise models.JobsPatchJobServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsPatchJobGatewayTimeoutErrorResponseBodyData
            )
            raise models.JobsPatchJobGatewayTimeoutErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.JobsPatchJobBadRequestErrorResponseBody
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def patch_job_async(
        self,
        *,
        id: str,
        job: Union[
            models.PatchJobObjectRequestBody, models.PatchJobObjectRequestBodyTypedDict
        ],
        keep_history: Optional[bool] = True,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PatchJobResponse:
        r"""[beta] Patches a job

        Patches an existing job and returns it.

        To use this endpoint, select **Write Jobs** under the Equipment category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param id: A jobId or uuid in STRING format. JobId must be prefixed with `jobId:`(Examples: `\"8d218e6c-7a16-4f9f-90f7-cc1d93b9e596\"`, `\"jobId:98765\"`).
        :param job: Job object with fields to update. If a field is not provided, it will not be updated
        :param keep_history: Defaults to true if user does not want to overwrite entire history for an active job (irrelevant for scheduled/completed jobs)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.PatchJobRequest(
            id=id,
            jobs_patch_job_request_body=models.JobsPatchJobRequestBody(
                job=utils.get_pydantic_model(job, models.PatchJobObjectRequestBody),
                keep_history=keep_history,
            ),
        )

        req = self._build_request_async(
            method="PATCH",
            path="/beta/industrial/jobs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.jobs_patch_job_request_body,
                False,
                False,
                "json",
                models.JobsPatchJobRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="patchJob",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.JobsPatchJobResponseBody)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsPatchJobUnauthorizedErrorResponseBodyData
            )
            raise models.JobsPatchJobUnauthorizedErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsPatchJobNotFoundErrorResponseBodyData
            )
            raise models.JobsPatchJobNotFoundErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsPatchJobMethodNotAllowedErrorResponseBodyData
            )
            raise models.JobsPatchJobMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsPatchJobTooManyRequestsErrorResponseBodyData
            )
            raise models.JobsPatchJobTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsPatchJobInternalServerErrorResponseBodyData
            )
            raise models.JobsPatchJobInternalServerErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsPatchJobNotImplementedErrorResponseBodyData
            )
            raise models.JobsPatchJobNotImplementedErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsPatchJobBadGatewayErrorResponseBodyData
            )
            raise models.JobsPatchJobBadGatewayErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.JobsPatchJobServiceUnavailableErrorResponseBodyData,
            )
            raise models.JobsPatchJobServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsPatchJobGatewayTimeoutErrorResponseBodyData
            )
            raise models.JobsPatchJobGatewayTimeoutErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.JobsPatchJobBadRequestErrorResponseBody
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def create_job(
        self,
        *,
        job: Union[
            models.PostJobObjectRequestBody, models.PostJobObjectRequestBodyTypedDict
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CreateJobResponse:
        r"""[beta] Create a job

        Creates a new job and returns it.

        To use this endpoint, select **Write Jobs** under the Equipment category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param job: Job object to be created
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.JobsCreateJobRequestBody(
            job=utils.get_pydantic_model(job, models.PostJobObjectRequestBody),
        )

        req = self._build_request(
            method="POST",
            path="/beta/industrial/jobs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.JobsCreateJobRequestBody
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="createJob",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.JobsCreateJobResponseBody)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsCreateJobUnauthorizedErrorResponseBodyData
            )
            raise models.JobsCreateJobUnauthorizedErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsCreateJobNotFoundErrorResponseBodyData
            )
            raise models.JobsCreateJobNotFoundErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsCreateJobMethodNotAllowedErrorResponseBodyData
            )
            raise models.JobsCreateJobMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsCreateJobTooManyRequestsErrorResponseBodyData
            )
            raise models.JobsCreateJobTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsCreateJobInternalServerErrorResponseBodyData
            )
            raise models.JobsCreateJobInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsCreateJobNotImplementedErrorResponseBodyData
            )
            raise models.JobsCreateJobNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsCreateJobBadGatewayErrorResponseBodyData
            )
            raise models.JobsCreateJobBadGatewayErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.JobsCreateJobServiceUnavailableErrorResponseBodyData,
            )
            raise models.JobsCreateJobServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsCreateJobGatewayTimeoutErrorResponseBodyData
            )
            raise models.JobsCreateJobGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.JobsCreateJobBadRequestErrorResponseBody
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def create_job_async(
        self,
        *,
        job: Union[
            models.PostJobObjectRequestBody, models.PostJobObjectRequestBodyTypedDict
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CreateJobResponse:
        r"""[beta] Create a job

        Creates a new job and returns it.

        To use this endpoint, select **Write Jobs** under the Equipment category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param job: Job object to be created
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.JobsCreateJobRequestBody(
            job=utils.get_pydantic_model(job, models.PostJobObjectRequestBody),
        )

        req = self._build_request_async(
            method="POST",
            path="/beta/industrial/jobs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.JobsCreateJobRequestBody
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="createJob",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.JobsCreateJobResponseBody)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsCreateJobUnauthorizedErrorResponseBodyData
            )
            raise models.JobsCreateJobUnauthorizedErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsCreateJobNotFoundErrorResponseBodyData
            )
            raise models.JobsCreateJobNotFoundErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsCreateJobMethodNotAllowedErrorResponseBodyData
            )
            raise models.JobsCreateJobMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsCreateJobTooManyRequestsErrorResponseBodyData
            )
            raise models.JobsCreateJobTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsCreateJobInternalServerErrorResponseBodyData
            )
            raise models.JobsCreateJobInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsCreateJobNotImplementedErrorResponseBodyData
            )
            raise models.JobsCreateJobNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsCreateJobBadGatewayErrorResponseBodyData
            )
            raise models.JobsCreateJobBadGatewayErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.JobsCreateJobServiceUnavailableErrorResponseBodyData,
            )
            raise models.JobsCreateJobServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.JobsCreateJobGatewayTimeoutErrorResponseBodyData
            )
            raise models.JobsCreateJobGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.JobsCreateJobBadRequestErrorResponseBody
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_media_retrieval(
        self,
        *,
        retrieval_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetMediaRetrievalResponse:
        r"""[beta] Get details for a media retrieval request

        This endpoint returns media information corresponding to a retrieval ID. Retrieval IDs are associated to prior [media retrieval requests](https://developers.samsara.com/reference/postmediaretrieval). Urls provided by this endpoint expire in 8 hours.

        <b>Rate limit:</b> 100 requests/min (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Media Retrieval** under the Safety & Cameras category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param retrieval_id: Retrieval ID associated with this media capture request. Examples: 2308cec4-82e0-46f1-8b3c-a3592e5cc21e
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetMediaRetrievalRequest(
            retrieval_id=retrieval_id,
        )

        req = self._build_request(
            method="GET",
            path="/cameras/media/retrieval",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getMediaRetrieval",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.MediaRetrievalGetMediaRetrievalResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalGetMediaRetrievalUnauthorizedErrorResponseBodyData,
            )
            raise models.MediaRetrievalGetMediaRetrievalUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalGetMediaRetrievalNotFoundErrorResponseBodyData,
            )
            raise models.MediaRetrievalGetMediaRetrievalNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalGetMediaRetrievalMethodNotAllowedErrorResponseBodyData,
            )
            raise models.MediaRetrievalGetMediaRetrievalMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalGetMediaRetrievalTooManyRequestsErrorResponseBodyData,
            )
            raise models.MediaRetrievalGetMediaRetrievalTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalGetMediaRetrievalInternalServerErrorResponseBodyData,
            )
            raise models.MediaRetrievalGetMediaRetrievalInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalGetMediaRetrievalNotImplementedErrorResponseBodyData,
            )
            raise models.MediaRetrievalGetMediaRetrievalNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalGetMediaRetrievalBadGatewayErrorResponseBodyData,
            )
            raise models.MediaRetrievalGetMediaRetrievalBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalGetMediaRetrievalServiceUnavailableErrorResponseBodyData,
            )
            raise models.MediaRetrievalGetMediaRetrievalServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalGetMediaRetrievalGatewayTimeoutErrorResponseBodyData,
            )
            raise models.MediaRetrievalGetMediaRetrievalGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalGetMediaRetrievalBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_media_retrieval_async(
        self,
        *,
        retrieval_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetMediaRetrievalResponse:
        r"""[beta] Get details for a media retrieval request

        This endpoint returns media information corresponding to a retrieval ID. Retrieval IDs are associated to prior [media retrieval requests](https://developers.samsara.com/reference/postmediaretrieval). Urls provided by this endpoint expire in 8 hours.

        <b>Rate limit:</b> 100 requests/min (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Media Retrieval** under the Safety & Cameras category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param retrieval_id: Retrieval ID associated with this media capture request. Examples: 2308cec4-82e0-46f1-8b3c-a3592e5cc21e
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetMediaRetrievalRequest(
            retrieval_id=retrieval_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/cameras/media/retrieval",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getMediaRetrieval",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.MediaRetrievalGetMediaRetrievalResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalGetMediaRetrievalUnauthorizedErrorResponseBodyData,
            )
            raise models.MediaRetrievalGetMediaRetrievalUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalGetMediaRetrievalNotFoundErrorResponseBodyData,
            )
            raise models.MediaRetrievalGetMediaRetrievalNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalGetMediaRetrievalMethodNotAllowedErrorResponseBodyData,
            )
            raise models.MediaRetrievalGetMediaRetrievalMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalGetMediaRetrievalTooManyRequestsErrorResponseBodyData,
            )
            raise models.MediaRetrievalGetMediaRetrievalTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalGetMediaRetrievalInternalServerErrorResponseBodyData,
            )
            raise models.MediaRetrievalGetMediaRetrievalInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalGetMediaRetrievalNotImplementedErrorResponseBodyData,
            )
            raise models.MediaRetrievalGetMediaRetrievalNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalGetMediaRetrievalBadGatewayErrorResponseBodyData,
            )
            raise models.MediaRetrievalGetMediaRetrievalBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalGetMediaRetrievalServiceUnavailableErrorResponseBodyData,
            )
            raise models.MediaRetrievalGetMediaRetrievalServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalGetMediaRetrievalGatewayTimeoutErrorResponseBodyData,
            )
            raise models.MediaRetrievalGetMediaRetrievalGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalGetMediaRetrievalBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def post_media_retrieval(
        self,
        *,
        end_time: str,
        inputs: List[models.Inputs],
        media_type: models.MediaRetrievalPostMediaRetrievalRequestBodyMediaType,
        start_time: str,
        vehicle_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PostMediaRetrievalResponse:
        r"""[beta] Create a media retrieval request

        This endpoint creates an asynchronous request to upload certain media from a device. Currently, images and videos can be requested for timestamps when there's high resolution footage stored on the device, even if low resolution footage exists on the device during that timestamp. The closest available media to the requested timestamp is returned. Other types of media (e.g. hyperlapse) are planned to be supported in the future. Currently, only unblurred media is supported; orgs with blurring enabled will not be able to retrieve media. If a device is offline, the requested media will be uploaded once it comes back online. Quota limits for media requests will be enforced in GA, but not in closed beta.

        <b>Rate limit:</b> 100 requests/min (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write Media Retrieval** under the Safety & Cameras category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param end_time: An end time in RFC 3339 format. If endTime is the same as startTime, an image will be captured at startTime. Must be equal to or after startTime and no more than 60 seconds after startTime (Examples: 2019-06-13T19:08:55Z, 2019-06-13T19:08:55.455Z, OR 2015-09-15T14:00:42-04:00).
        :param inputs: A list of desired camera inputs for which to capture media. Only media with valid inputs (e.g. device has that input stream and device was recording at the time) will be uploaded. An empty list is invalid.
        :param media_type: The desired media type. If a video is requested, endTime must be after startTime. If an image is requested, endTime must be the same as startTime. Must be one of: IMAGE, VIDEO_HIGH_RES, VIDEO_LOW_RES. Examples: IMAGE, VIDEO_HIGH_RES, VIDEO_LOW_RES  Valid values: `IMAGE`, `VIDEO_HIGH_RES`, `VIDEO_LOW_RES`
        :param start_time: A start time in RFC 3339 format. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param vehicle_id: Vehicle ID for which to initiate media capture. Examples: 1234
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.MediaRetrievalPostMediaRetrievalRequestBody(
            end_time=end_time,
            inputs=inputs,
            media_type=media_type,
            start_time=start_time,
            vehicle_id=vehicle_id,
        )

        req = self._build_request(
            method="POST",
            path="/cameras/media/retrieval",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request,
                False,
                False,
                "json",
                models.MediaRetrievalPostMediaRetrievalRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="postMediaRetrieval",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.MediaRetrievalPostMediaRetrievalResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalPostMediaRetrievalUnauthorizedErrorResponseBodyData,
            )
            raise models.MediaRetrievalPostMediaRetrievalUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalPostMediaRetrievalNotFoundErrorResponseBodyData,
            )
            raise models.MediaRetrievalPostMediaRetrievalNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalPostMediaRetrievalMethodNotAllowedErrorResponseBodyData,
            )
            raise models.MediaRetrievalPostMediaRetrievalMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalPostMediaRetrievalTooManyRequestsErrorResponseBodyData,
            )
            raise models.MediaRetrievalPostMediaRetrievalTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalPostMediaRetrievalInternalServerErrorResponseBodyData,
            )
            raise models.MediaRetrievalPostMediaRetrievalInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalPostMediaRetrievalNotImplementedErrorResponseBodyData,
            )
            raise models.MediaRetrievalPostMediaRetrievalNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalPostMediaRetrievalBadGatewayErrorResponseBodyData,
            )
            raise models.MediaRetrievalPostMediaRetrievalBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalPostMediaRetrievalServiceUnavailableErrorResponseBodyData,
            )
            raise models.MediaRetrievalPostMediaRetrievalServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalPostMediaRetrievalGatewayTimeoutErrorResponseBodyData,
            )
            raise models.MediaRetrievalPostMediaRetrievalGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalPostMediaRetrievalBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def post_media_retrieval_async(
        self,
        *,
        end_time: str,
        inputs: List[models.Inputs],
        media_type: models.MediaRetrievalPostMediaRetrievalRequestBodyMediaType,
        start_time: str,
        vehicle_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PostMediaRetrievalResponse:
        r"""[beta] Create a media retrieval request

        This endpoint creates an asynchronous request to upload certain media from a device. Currently, images and videos can be requested for timestamps when there's high resolution footage stored on the device, even if low resolution footage exists on the device during that timestamp. The closest available media to the requested timestamp is returned. Other types of media (e.g. hyperlapse) are planned to be supported in the future. Currently, only unblurred media is supported; orgs with blurring enabled will not be able to retrieve media. If a device is offline, the requested media will be uploaded once it comes back online. Quota limits for media requests will be enforced in GA, but not in closed beta.

        <b>Rate limit:</b> 100 requests/min (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write Media Retrieval** under the Safety & Cameras category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param end_time: An end time in RFC 3339 format. If endTime is the same as startTime, an image will be captured at startTime. Must be equal to or after startTime and no more than 60 seconds after startTime (Examples: 2019-06-13T19:08:55Z, 2019-06-13T19:08:55.455Z, OR 2015-09-15T14:00:42-04:00).
        :param inputs: A list of desired camera inputs for which to capture media. Only media with valid inputs (e.g. device has that input stream and device was recording at the time) will be uploaded. An empty list is invalid.
        :param media_type: The desired media type. If a video is requested, endTime must be after startTime. If an image is requested, endTime must be the same as startTime. Must be one of: IMAGE, VIDEO_HIGH_RES, VIDEO_LOW_RES. Examples: IMAGE, VIDEO_HIGH_RES, VIDEO_LOW_RES  Valid values: `IMAGE`, `VIDEO_HIGH_RES`, `VIDEO_LOW_RES`
        :param start_time: A start time in RFC 3339 format. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param vehicle_id: Vehicle ID for which to initiate media capture. Examples: 1234
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.MediaRetrievalPostMediaRetrievalRequestBody(
            end_time=end_time,
            inputs=inputs,
            media_type=media_type,
            start_time=start_time,
            vehicle_id=vehicle_id,
        )

        req = self._build_request_async(
            method="POST",
            path="/cameras/media/retrieval",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request,
                False,
                False,
                "json",
                models.MediaRetrievalPostMediaRetrievalRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="postMediaRetrieval",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.MediaRetrievalPostMediaRetrievalResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalPostMediaRetrievalUnauthorizedErrorResponseBodyData,
            )
            raise models.MediaRetrievalPostMediaRetrievalUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalPostMediaRetrievalNotFoundErrorResponseBodyData,
            )
            raise models.MediaRetrievalPostMediaRetrievalNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalPostMediaRetrievalMethodNotAllowedErrorResponseBodyData,
            )
            raise models.MediaRetrievalPostMediaRetrievalMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalPostMediaRetrievalTooManyRequestsErrorResponseBodyData,
            )
            raise models.MediaRetrievalPostMediaRetrievalTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalPostMediaRetrievalInternalServerErrorResponseBodyData,
            )
            raise models.MediaRetrievalPostMediaRetrievalInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalPostMediaRetrievalNotImplementedErrorResponseBodyData,
            )
            raise models.MediaRetrievalPostMediaRetrievalNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalPostMediaRetrievalBadGatewayErrorResponseBodyData,
            )
            raise models.MediaRetrievalPostMediaRetrievalBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalPostMediaRetrievalServiceUnavailableErrorResponseBodyData,
            )
            raise models.MediaRetrievalPostMediaRetrievalServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalPostMediaRetrievalGatewayTimeoutErrorResponseBodyData,
            )
            raise models.MediaRetrievalPostMediaRetrievalGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.MediaRetrievalPostMediaRetrievalBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_devices(
        self,
        *,
        models: Optional[List[str]] = None,
        health_statuses: Optional[List[str]] = None,
        include_health: Optional[bool] = None,
        after: Optional[str] = None,
        limit: Optional[int] = 100,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetDevicesResponse:
        r"""[beta] List devices.

        Returns all installed cameras (CM3x), vehicle gateways (VGs), and asset gateways (AGs) and their health information within an organization.

        **Beta:** This endpoint is in beta and is likely to change before being broadly available. Reach out to your Samsara Representative to have Devices API enabled for your organization.

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Devices** under the Closed Beta category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param models: Optional string of comma separated device models. Valid values: `CM31`, `CM32`, `CM33`, `CM34`, `VG34`, `VG34M`, `VG34EU`, `VG34FN`, `VG54NA`, `VG54EU`, `VG55NA`, `VG55EU`, `AG24`, `AG24EU`, `AG26`, `AG26EU`, `AG45`, `AG45EU`, `AG46`, `AG46EU`, `AG46P`, `AG46PEU`, `AG51`, `AG51EU`, `AG52`, `AG52EU`, `AG53`, `AG53EU`
        :param health_statuses: Optional string of comma separated device health statuses. Valid values: `healthy`, `needsAttention`, `needsReplacement`, `dataPending`.
        :param include_health: Optional boolean to control whether device health information is returned in the response. Defaults to false.
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param limit: The limit for how many objects will be in the response. Default and max for this value is 100 objects.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetDevicesRequest(
            models=models,
            health_statuses=health_statuses,
            include_health=include_health,
            after=after,
            limit=limit,
        )

        req = self._build_request(
            method="GET",
            path="/devices",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getDevices",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.DevicesGetDevicesResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.DevicesGetDevicesUnauthorizedErrorResponseBodyData
            )
            raise models.DevicesGetDevicesUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.DevicesGetDevicesNotFoundErrorResponseBodyData
            )
            raise models.DevicesGetDevicesNotFoundErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DevicesGetDevicesMethodNotAllowedErrorResponseBodyData,
            )
            raise models.DevicesGetDevicesMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DevicesGetDevicesTooManyRequestsErrorResponseBodyData,
            )
            raise models.DevicesGetDevicesTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DevicesGetDevicesInternalServerErrorResponseBodyData,
            )
            raise models.DevicesGetDevicesInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DevicesGetDevicesNotImplementedErrorResponseBodyData,
            )
            raise models.DevicesGetDevicesNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.DevicesGetDevicesBadGatewayErrorResponseBodyData
            )
            raise models.DevicesGetDevicesBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DevicesGetDevicesServiceUnavailableErrorResponseBodyData,
            )
            raise models.DevicesGetDevicesServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DevicesGetDevicesGatewayTimeoutErrorResponseBodyData,
            )
            raise models.DevicesGetDevicesGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.DevicesGetDevicesBadRequestErrorResponseBody
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_devices_async(
        self,
        *,
        models: Optional[List[str]] = None,
        health_statuses: Optional[List[str]] = None,
        include_health: Optional[bool] = None,
        after: Optional[str] = None,
        limit: Optional[int] = 100,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetDevicesResponse:
        r"""[beta] List devices.

        Returns all installed cameras (CM3x), vehicle gateways (VGs), and asset gateways (AGs) and their health information within an organization.

        **Beta:** This endpoint is in beta and is likely to change before being broadly available. Reach out to your Samsara Representative to have Devices API enabled for your organization.

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Devices** under the Closed Beta category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param models: Optional string of comma separated device models. Valid values: `CM31`, `CM32`, `CM33`, `CM34`, `VG34`, `VG34M`, `VG34EU`, `VG34FN`, `VG54NA`, `VG54EU`, `VG55NA`, `VG55EU`, `AG24`, `AG24EU`, `AG26`, `AG26EU`, `AG45`, `AG45EU`, `AG46`, `AG46EU`, `AG46P`, `AG46PEU`, `AG51`, `AG51EU`, `AG52`, `AG52EU`, `AG53`, `AG53EU`
        :param health_statuses: Optional string of comma separated device health statuses. Valid values: `healthy`, `needsAttention`, `needsReplacement`, `dataPending`.
        :param include_health: Optional boolean to control whether device health information is returned in the response. Defaults to false.
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param limit: The limit for how many objects will be in the response. Default and max for this value is 100 objects.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetDevicesRequest(
            models=models,
            health_statuses=health_statuses,
            include_health=include_health,
            after=after,
            limit=limit,
        )

        req = self._build_request_async(
            method="GET",
            path="/devices",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getDevices",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.DevicesGetDevicesResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.DevicesGetDevicesUnauthorizedErrorResponseBodyData
            )
            raise models.DevicesGetDevicesUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.DevicesGetDevicesNotFoundErrorResponseBodyData
            )
            raise models.DevicesGetDevicesNotFoundErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DevicesGetDevicesMethodNotAllowedErrorResponseBodyData,
            )
            raise models.DevicesGetDevicesMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DevicesGetDevicesTooManyRequestsErrorResponseBodyData,
            )
            raise models.DevicesGetDevicesTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DevicesGetDevicesInternalServerErrorResponseBodyData,
            )
            raise models.DevicesGetDevicesInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DevicesGetDevicesNotImplementedErrorResponseBodyData,
            )
            raise models.DevicesGetDevicesNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.DevicesGetDevicesBadGatewayErrorResponseBodyData
            )
            raise models.DevicesGetDevicesBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DevicesGetDevicesServiceUnavailableErrorResponseBodyData,
            )
            raise models.DevicesGetDevicesServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DevicesGetDevicesGatewayTimeoutErrorResponseBodyData,
            )
            raise models.DevicesGetDevicesGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.DevicesGetDevicesBadRequestErrorResponseBody
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_driver_trailer_assignments(
        self,
        *,
        driver_ids: List[str],
        after: Optional[str] = None,
        include_external_ids: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetDriverTrailerAssignmentsResponse:
        r"""[beta] Get currently active driver-trailer assignments for driver.

        Get currently active driver-trailer assignments for driver.

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Assignments** under the Assignments category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param driver_ids: A filter on the data based on this comma-separated list of driver IDs and externalIds. Example: `driverIds=1234,5678,payroll:4841`
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param include_external_ids: Optional boolean indicating whether to return external IDs on supported entities
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetDriverTrailerAssignmentsRequest(
            driver_ids=driver_ids,
            after=after,
            include_external_ids=include_external_ids,
        )

        req = self._build_request(
            method="GET",
            path="/driver-trailer-assignments",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getDriverTrailerAssignments",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsGetDriverTrailerAssignmentsResponseBody,
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsGetDriverTrailerAssignmentsUnauthorizedErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsGetDriverTrailerAssignmentsUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsGetDriverTrailerAssignmentsNotFoundErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsGetDriverTrailerAssignmentsNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsGetDriverTrailerAssignmentsMethodNotAllowedErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsGetDriverTrailerAssignmentsMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsGetDriverTrailerAssignmentsTooManyRequestsErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsGetDriverTrailerAssignmentsTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsGetDriverTrailerAssignmentsInternalServerErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsGetDriverTrailerAssignmentsInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsGetDriverTrailerAssignmentsNotImplementedErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsGetDriverTrailerAssignmentsNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsGetDriverTrailerAssignmentsBadGatewayErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsGetDriverTrailerAssignmentsBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsGetDriverTrailerAssignmentsServiceUnavailableErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsGetDriverTrailerAssignmentsServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsGetDriverTrailerAssignmentsGatewayTimeoutErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsGetDriverTrailerAssignmentsGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsGetDriverTrailerAssignmentsBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_driver_trailer_assignments_async(
        self,
        *,
        driver_ids: List[str],
        after: Optional[str] = None,
        include_external_ids: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetDriverTrailerAssignmentsResponse:
        r"""[beta] Get currently active driver-trailer assignments for driver.

        Get currently active driver-trailer assignments for driver.

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Assignments** under the Assignments category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param driver_ids: A filter on the data based on this comma-separated list of driver IDs and externalIds. Example: `driverIds=1234,5678,payroll:4841`
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param include_external_ids: Optional boolean indicating whether to return external IDs on supported entities
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetDriverTrailerAssignmentsRequest(
            driver_ids=driver_ids,
            after=after,
            include_external_ids=include_external_ids,
        )

        req = self._build_request_async(
            method="GET",
            path="/driver-trailer-assignments",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getDriverTrailerAssignments",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsGetDriverTrailerAssignmentsResponseBody,
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsGetDriverTrailerAssignmentsUnauthorizedErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsGetDriverTrailerAssignmentsUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsGetDriverTrailerAssignmentsNotFoundErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsGetDriverTrailerAssignmentsNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsGetDriverTrailerAssignmentsMethodNotAllowedErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsGetDriverTrailerAssignmentsMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsGetDriverTrailerAssignmentsTooManyRequestsErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsGetDriverTrailerAssignmentsTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsGetDriverTrailerAssignmentsInternalServerErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsGetDriverTrailerAssignmentsInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsGetDriverTrailerAssignmentsNotImplementedErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsGetDriverTrailerAssignmentsNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsGetDriverTrailerAssignmentsBadGatewayErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsGetDriverTrailerAssignmentsBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsGetDriverTrailerAssignmentsServiceUnavailableErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsGetDriverTrailerAssignmentsServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsGetDriverTrailerAssignmentsGatewayTimeoutErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsGetDriverTrailerAssignmentsGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsGetDriverTrailerAssignmentsBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def update_driver_trailer_assignment(
        self,
        *,
        id: str,
        end_time: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.UpdateDriverTrailerAssignmentResponse:
        r"""[beta] Update an existing driver-trailer assignment.

        Update an existing driver-trailer assignment.

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write Assignments** under the Assignments category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param id: Samsara ID for the assignment.
        :param end_time: The end time in RFC 3339 format. The end time should not be in the future
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.UpdateDriverTrailerAssignmentRequest(
            id=id,
            trailer_assignments_update_driver_trailer_assignment_request_body=models.TrailerAssignmentsUpdateDriverTrailerAssignmentRequestBody(
                end_time=end_time,
            ),
        )

        req = self._build_request(
            method="PATCH",
            path="/driver-trailer-assignments",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.trailer_assignments_update_driver_trailer_assignment_request_body,
                False,
                False,
                "json",
                models.TrailerAssignmentsUpdateDriverTrailerAssignmentRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="updateDriverTrailerAssignment",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsUpdateDriverTrailerAssignmentResponseBody,
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsUpdateDriverTrailerAssignmentUnauthorizedErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsUpdateDriverTrailerAssignmentUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsUpdateDriverTrailerAssignmentNotFoundErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsUpdateDriverTrailerAssignmentNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsUpdateDriverTrailerAssignmentMethodNotAllowedErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsUpdateDriverTrailerAssignmentMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsUpdateDriverTrailerAssignmentTooManyRequestsErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsUpdateDriverTrailerAssignmentTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsUpdateDriverTrailerAssignmentInternalServerErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsUpdateDriverTrailerAssignmentInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsUpdateDriverTrailerAssignmentNotImplementedErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsUpdateDriverTrailerAssignmentNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsUpdateDriverTrailerAssignmentBadGatewayErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsUpdateDriverTrailerAssignmentBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsUpdateDriverTrailerAssignmentServiceUnavailableErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsUpdateDriverTrailerAssignmentServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsUpdateDriverTrailerAssignmentGatewayTimeoutErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsUpdateDriverTrailerAssignmentGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsUpdateDriverTrailerAssignmentBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def update_driver_trailer_assignment_async(
        self,
        *,
        id: str,
        end_time: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.UpdateDriverTrailerAssignmentResponse:
        r"""[beta] Update an existing driver-trailer assignment.

        Update an existing driver-trailer assignment.

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write Assignments** under the Assignments category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param id: Samsara ID for the assignment.
        :param end_time: The end time in RFC 3339 format. The end time should not be in the future
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.UpdateDriverTrailerAssignmentRequest(
            id=id,
            trailer_assignments_update_driver_trailer_assignment_request_body=models.TrailerAssignmentsUpdateDriverTrailerAssignmentRequestBody(
                end_time=end_time,
            ),
        )

        req = self._build_request_async(
            method="PATCH",
            path="/driver-trailer-assignments",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.trailer_assignments_update_driver_trailer_assignment_request_body,
                False,
                False,
                "json",
                models.TrailerAssignmentsUpdateDriverTrailerAssignmentRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="updateDriverTrailerAssignment",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsUpdateDriverTrailerAssignmentResponseBody,
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsUpdateDriverTrailerAssignmentUnauthorizedErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsUpdateDriverTrailerAssignmentUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsUpdateDriverTrailerAssignmentNotFoundErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsUpdateDriverTrailerAssignmentNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsUpdateDriverTrailerAssignmentMethodNotAllowedErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsUpdateDriverTrailerAssignmentMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsUpdateDriverTrailerAssignmentTooManyRequestsErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsUpdateDriverTrailerAssignmentTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsUpdateDriverTrailerAssignmentInternalServerErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsUpdateDriverTrailerAssignmentInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsUpdateDriverTrailerAssignmentNotImplementedErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsUpdateDriverTrailerAssignmentNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsUpdateDriverTrailerAssignmentBadGatewayErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsUpdateDriverTrailerAssignmentBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsUpdateDriverTrailerAssignmentServiceUnavailableErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsUpdateDriverTrailerAssignmentServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsUpdateDriverTrailerAssignmentGatewayTimeoutErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsUpdateDriverTrailerAssignmentGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsUpdateDriverTrailerAssignmentBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def create_driver_trailer_assignment(
        self,
        *,
        driver_id: str,
        trailer_id: str,
        start_time: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CreateDriverTrailerAssignmentResponse:
        r"""[beta] Create a new driver-trailer assignment

        Create a new driver-trailer assignment

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write Assignments** under the Assignments category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param driver_id: ID of the driver. This can be either a unique Samsara ID or an [external ID](https://developers.samsara.com/docs/external-ids) for the driver.
        :param trailer_id: ID of the trailer. This can be either a unique Samsara ID or an [external ID](https://developers.samsara.com/docs/external-ids) for the trailer.
        :param start_time: The start time in RFC 3339 format. The time needs to be current or within the past 7 days. Defaults to now if not provided
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.TrailerAssignmentsCreateDriverTrailerAssignmentRequestBody(
            driver_id=driver_id,
            start_time=start_time,
            trailer_id=trailer_id,
        )

        req = self._build_request(
            method="POST",
            path="/driver-trailer-assignments",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request,
                False,
                False,
                "json",
                models.TrailerAssignmentsCreateDriverTrailerAssignmentRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="createDriverTrailerAssignment",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsCreateDriverTrailerAssignmentResponseBody,
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsCreateDriverTrailerAssignmentUnauthorizedErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsCreateDriverTrailerAssignmentUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsCreateDriverTrailerAssignmentNotFoundErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsCreateDriverTrailerAssignmentNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsCreateDriverTrailerAssignmentMethodNotAllowedErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsCreateDriverTrailerAssignmentMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsCreateDriverTrailerAssignmentTooManyRequestsErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsCreateDriverTrailerAssignmentTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsCreateDriverTrailerAssignmentInternalServerErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsCreateDriverTrailerAssignmentInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsCreateDriverTrailerAssignmentNotImplementedErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsCreateDriverTrailerAssignmentNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsCreateDriverTrailerAssignmentBadGatewayErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsCreateDriverTrailerAssignmentBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsCreateDriverTrailerAssignmentServiceUnavailableErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsCreateDriverTrailerAssignmentServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsCreateDriverTrailerAssignmentGatewayTimeoutErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsCreateDriverTrailerAssignmentGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsCreateDriverTrailerAssignmentBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def create_driver_trailer_assignment_async(
        self,
        *,
        driver_id: str,
        trailer_id: str,
        start_time: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CreateDriverTrailerAssignmentResponse:
        r"""[beta] Create a new driver-trailer assignment

        Create a new driver-trailer assignment

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write Assignments** under the Assignments category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param driver_id: ID of the driver. This can be either a unique Samsara ID or an [external ID](https://developers.samsara.com/docs/external-ids) for the driver.
        :param trailer_id: ID of the trailer. This can be either a unique Samsara ID or an [external ID](https://developers.samsara.com/docs/external-ids) for the trailer.
        :param start_time: The start time in RFC 3339 format. The time needs to be current or within the past 7 days. Defaults to now if not provided
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.TrailerAssignmentsCreateDriverTrailerAssignmentRequestBody(
            driver_id=driver_id,
            start_time=start_time,
            trailer_id=trailer_id,
        )

        req = self._build_request_async(
            method="POST",
            path="/driver-trailer-assignments",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request,
                False,
                False,
                "json",
                models.TrailerAssignmentsCreateDriverTrailerAssignmentRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="createDriverTrailerAssignment",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsCreateDriverTrailerAssignmentResponseBody,
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsCreateDriverTrailerAssignmentUnauthorizedErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsCreateDriverTrailerAssignmentUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsCreateDriverTrailerAssignmentNotFoundErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsCreateDriverTrailerAssignmentNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsCreateDriverTrailerAssignmentMethodNotAllowedErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsCreateDriverTrailerAssignmentMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsCreateDriverTrailerAssignmentTooManyRequestsErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsCreateDriverTrailerAssignmentTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsCreateDriverTrailerAssignmentInternalServerErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsCreateDriverTrailerAssignmentInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsCreateDriverTrailerAssignmentNotImplementedErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsCreateDriverTrailerAssignmentNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsCreateDriverTrailerAssignmentBadGatewayErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsCreateDriverTrailerAssignmentBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsCreateDriverTrailerAssignmentServiceUnavailableErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsCreateDriverTrailerAssignmentServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsCreateDriverTrailerAssignmentGatewayTimeoutErrorResponseBodyData,
            )
            raise models.TrailerAssignmentsCreateDriverTrailerAssignmentGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.TrailerAssignmentsCreateDriverTrailerAssignmentBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def post_driver_remote_signout(
        self,
        *,
        driver_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PostDriverRemoteSignoutResponse:
        r"""[beta] Sign out a driver

        Sign out a driver from the Samsara Driver App

        To access this endpoint, your organization must have the Samsara Platform Premier license.

        Note: Sign out requests made while a logged-in driver does not have internet connection will not log the driver out. A success response will still be provided and the driver will be logged out once they have internet connection.

        <b>Rate limit:</b> 100 requests/min (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write Driver Remote Signout** under the Closed Beta category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param driver_id: ID of the driver.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.DriverRemoteSignoutPostDriverRemoteSignoutRequestBody(
            driver_id=driver_id,
        )

        req = self._build_request(
            method="POST",
            path="/fleet/drivers/remote-sign-out",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request,
                False,
                False,
                "json",
                models.DriverRemoteSignoutPostDriverRemoteSignoutRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="postDriverRemoteSignout",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.DriverRemoteSignoutPostDriverRemoteSignoutResponseBody,
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverRemoteSignoutPostDriverRemoteSignoutUnauthorizedErrorResponseBodyData,
            )
            raise models.DriverRemoteSignoutPostDriverRemoteSignoutUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverRemoteSignoutPostDriverRemoteSignoutNotFoundErrorResponseBodyData,
            )
            raise models.DriverRemoteSignoutPostDriverRemoteSignoutNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverRemoteSignoutPostDriverRemoteSignoutMethodNotAllowedErrorResponseBodyData,
            )
            raise models.DriverRemoteSignoutPostDriverRemoteSignoutMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverRemoteSignoutPostDriverRemoteSignoutTooManyRequestsErrorResponseBodyData,
            )
            raise models.DriverRemoteSignoutPostDriverRemoteSignoutTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverRemoteSignoutPostDriverRemoteSignoutInternalServerErrorResponseBodyData,
            )
            raise models.DriverRemoteSignoutPostDriverRemoteSignoutInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverRemoteSignoutPostDriverRemoteSignoutNotImplementedErrorResponseBodyData,
            )
            raise models.DriverRemoteSignoutPostDriverRemoteSignoutNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverRemoteSignoutPostDriverRemoteSignoutBadGatewayErrorResponseBodyData,
            )
            raise models.DriverRemoteSignoutPostDriverRemoteSignoutBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverRemoteSignoutPostDriverRemoteSignoutServiceUnavailableErrorResponseBodyData,
            )
            raise models.DriverRemoteSignoutPostDriverRemoteSignoutServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverRemoteSignoutPostDriverRemoteSignoutGatewayTimeoutErrorResponseBodyData,
            )
            raise models.DriverRemoteSignoutPostDriverRemoteSignoutGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.DriverRemoteSignoutPostDriverRemoteSignoutBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def post_driver_remote_signout_async(
        self,
        *,
        driver_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PostDriverRemoteSignoutResponse:
        r"""[beta] Sign out a driver

        Sign out a driver from the Samsara Driver App

        To access this endpoint, your organization must have the Samsara Platform Premier license.

        Note: Sign out requests made while a logged-in driver does not have internet connection will not log the driver out. A success response will still be provided and the driver will be logged out once they have internet connection.

        <b>Rate limit:</b> 100 requests/min (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write Driver Remote Signout** under the Closed Beta category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param driver_id: ID of the driver.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.DriverRemoteSignoutPostDriverRemoteSignoutRequestBody(
            driver_id=driver_id,
        )

        req = self._build_request_async(
            method="POST",
            path="/fleet/drivers/remote-sign-out",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request,
                False,
                False,
                "json",
                models.DriverRemoteSignoutPostDriverRemoteSignoutRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="postDriverRemoteSignout",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.DriverRemoteSignoutPostDriverRemoteSignoutResponseBody,
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverRemoteSignoutPostDriverRemoteSignoutUnauthorizedErrorResponseBodyData,
            )
            raise models.DriverRemoteSignoutPostDriverRemoteSignoutUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverRemoteSignoutPostDriverRemoteSignoutNotFoundErrorResponseBodyData,
            )
            raise models.DriverRemoteSignoutPostDriverRemoteSignoutNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverRemoteSignoutPostDriverRemoteSignoutMethodNotAllowedErrorResponseBodyData,
            )
            raise models.DriverRemoteSignoutPostDriverRemoteSignoutMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverRemoteSignoutPostDriverRemoteSignoutTooManyRequestsErrorResponseBodyData,
            )
            raise models.DriverRemoteSignoutPostDriverRemoteSignoutTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverRemoteSignoutPostDriverRemoteSignoutInternalServerErrorResponseBodyData,
            )
            raise models.DriverRemoteSignoutPostDriverRemoteSignoutInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverRemoteSignoutPostDriverRemoteSignoutNotImplementedErrorResponseBodyData,
            )
            raise models.DriverRemoteSignoutPostDriverRemoteSignoutNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverRemoteSignoutPostDriverRemoteSignoutBadGatewayErrorResponseBodyData,
            )
            raise models.DriverRemoteSignoutPostDriverRemoteSignoutBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverRemoteSignoutPostDriverRemoteSignoutServiceUnavailableErrorResponseBodyData,
            )
            raise models.DriverRemoteSignoutPostDriverRemoteSignoutServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.DriverRemoteSignoutPostDriverRemoteSignoutGatewayTimeoutErrorResponseBodyData,
            )
            raise models.DriverRemoteSignoutPostDriverRemoteSignoutGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.DriverRemoteSignoutPostDriverRemoteSignoutBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_engine_immobilizer_states(
        self,
        *,
        vehicle_ids: str,
        start_time: str,
        end_time: Optional[str] = None,
        after: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetEngineImmobilizerStatesResponse:
        r"""[beta] Get engine immobilizer states

        Get the engine immobilizer states of the queried vehicles. If a vehicle has never had an engine immobilizer connected, there won't be any state returned for that vehicle.

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Vehicle Immobilization** under the Vehicles category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param vehicle_ids: A filter on the data based on this comma-separated list of vehicle IDs and externalIds. Example: `vehicleIds=1234,5678,samsara.vin:1HGBH41JXMN109186`
        :param start_time: A start time in RFC 3339 format. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param end_time: An end time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetEngineImmobilizerStatesRequest(
            vehicle_ids=vehicle_ids,
            start_time=start_time,
            end_time=end_time,
            after=after,
        )

        req = self._build_request(
            method="GET",
            path="/fleet/vehicles/immobilizer/stream",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getEngineImmobilizerStates",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerGetEngineImmobilizerStatesResponseBody,
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerGetEngineImmobilizerStatesUnauthorizedErrorResponseBodyData,
            )
            raise models.EngineImmobilizerGetEngineImmobilizerStatesUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerGetEngineImmobilizerStatesNotFoundErrorResponseBodyData,
            )
            raise models.EngineImmobilizerGetEngineImmobilizerStatesNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerGetEngineImmobilizerStatesMethodNotAllowedErrorResponseBodyData,
            )
            raise models.EngineImmobilizerGetEngineImmobilizerStatesMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerGetEngineImmobilizerStatesTooManyRequestsErrorResponseBodyData,
            )
            raise models.EngineImmobilizerGetEngineImmobilizerStatesTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerGetEngineImmobilizerStatesInternalServerErrorResponseBodyData,
            )
            raise models.EngineImmobilizerGetEngineImmobilizerStatesInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerGetEngineImmobilizerStatesNotImplementedErrorResponseBodyData,
            )
            raise models.EngineImmobilizerGetEngineImmobilizerStatesNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerGetEngineImmobilizerStatesBadGatewayErrorResponseBodyData,
            )
            raise models.EngineImmobilizerGetEngineImmobilizerStatesBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerGetEngineImmobilizerStatesServiceUnavailableErrorResponseBodyData,
            )
            raise models.EngineImmobilizerGetEngineImmobilizerStatesServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerGetEngineImmobilizerStatesGatewayTimeoutErrorResponseBodyData,
            )
            raise models.EngineImmobilizerGetEngineImmobilizerStatesGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerGetEngineImmobilizerStatesBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_engine_immobilizer_states_async(
        self,
        *,
        vehicle_ids: str,
        start_time: str,
        end_time: Optional[str] = None,
        after: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetEngineImmobilizerStatesResponse:
        r"""[beta] Get engine immobilizer states

        Get the engine immobilizer states of the queried vehicles. If a vehicle has never had an engine immobilizer connected, there won't be any state returned for that vehicle.

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Vehicle Immobilization** under the Vehicles category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param vehicle_ids: A filter on the data based on this comma-separated list of vehicle IDs and externalIds. Example: `vehicleIds=1234,5678,samsara.vin:1HGBH41JXMN109186`
        :param start_time: A start time in RFC 3339 format. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param end_time: An end time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetEngineImmobilizerStatesRequest(
            vehicle_ids=vehicle_ids,
            start_time=start_time,
            end_time=end_time,
            after=after,
        )

        req = self._build_request_async(
            method="GET",
            path="/fleet/vehicles/immobilizer/stream",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getEngineImmobilizerStates",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerGetEngineImmobilizerStatesResponseBody,
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerGetEngineImmobilizerStatesUnauthorizedErrorResponseBodyData,
            )
            raise models.EngineImmobilizerGetEngineImmobilizerStatesUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerGetEngineImmobilizerStatesNotFoundErrorResponseBodyData,
            )
            raise models.EngineImmobilizerGetEngineImmobilizerStatesNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerGetEngineImmobilizerStatesMethodNotAllowedErrorResponseBodyData,
            )
            raise models.EngineImmobilizerGetEngineImmobilizerStatesMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerGetEngineImmobilizerStatesTooManyRequestsErrorResponseBodyData,
            )
            raise models.EngineImmobilizerGetEngineImmobilizerStatesTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerGetEngineImmobilizerStatesInternalServerErrorResponseBodyData,
            )
            raise models.EngineImmobilizerGetEngineImmobilizerStatesInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerGetEngineImmobilizerStatesNotImplementedErrorResponseBodyData,
            )
            raise models.EngineImmobilizerGetEngineImmobilizerStatesNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerGetEngineImmobilizerStatesBadGatewayErrorResponseBodyData,
            )
            raise models.EngineImmobilizerGetEngineImmobilizerStatesBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerGetEngineImmobilizerStatesServiceUnavailableErrorResponseBodyData,
            )
            raise models.EngineImmobilizerGetEngineImmobilizerStatesServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerGetEngineImmobilizerStatesGatewayTimeoutErrorResponseBodyData,
            )
            raise models.EngineImmobilizerGetEngineImmobilizerStatesGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.EngineImmobilizerGetEngineImmobilizerStatesBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_form_submissions(
        self,
        *,
        ids: List[str],
        include: Optional[List[str]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetFormSubmissionsResponse:
        r"""[beta] Get a list of specified form submissions.

        Returns all form submissions data for the specified IDs.

        **Beta:** This endpoint is in beta and is likely to change before being broadly available. Reach out to your Samsara Representative to have Forms APIs enabled for your organization.

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Form Submissions** under the Closed Beta category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param ids: A comma-separated list containing up to 100 form submission IDs to filter on. Can be either a unique Samsara ID or an [external ID](https://developers.samsara.com/docs/external-ids) for the form submission.
        :param include: A comma-separated list of strings indicating whether to return additional information. Valid values: `externalIds`, `fieldLabels`
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetFormSubmissionsRequest(
            ids=ids,
            include=include,
        )

        req = self._build_request(
            method="GET",
            path="/form-submissions",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getFormSubmissions",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.FormSubmissionsGetFormSubmissionsResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsUnauthorizedErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsNotFoundErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsMethodNotAllowedErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsTooManyRequestsErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsInternalServerErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsNotImplementedErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsBadGatewayErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsServiceUnavailableErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsGatewayTimeoutErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_form_submissions_async(
        self,
        *,
        ids: List[str],
        include: Optional[List[str]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetFormSubmissionsResponse:
        r"""[beta] Get a list of specified form submissions.

        Returns all form submissions data for the specified IDs.

        **Beta:** This endpoint is in beta and is likely to change before being broadly available. Reach out to your Samsara Representative to have Forms APIs enabled for your organization.

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Form Submissions** under the Closed Beta category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param ids: A comma-separated list containing up to 100 form submission IDs to filter on. Can be either a unique Samsara ID or an [external ID](https://developers.samsara.com/docs/external-ids) for the form submission.
        :param include: A comma-separated list of strings indicating whether to return additional information. Valid values: `externalIds`, `fieldLabels`
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetFormSubmissionsRequest(
            ids=ids,
            include=include,
        )

        req = self._build_request_async(
            method="GET",
            path="/form-submissions",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getFormSubmissions",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.FormSubmissionsGetFormSubmissionsResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsUnauthorizedErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsNotFoundErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsMethodNotAllowedErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsTooManyRequestsErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsInternalServerErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsNotImplementedErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsBadGatewayErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsServiceUnavailableErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsGatewayTimeoutErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def patch_form_submission(
        self,
        *,
        id: str,
        assigned_to: Optional[
            Union[
                models.FormSubmissionRequestAssignedToRequestBody,
                models.FormSubmissionRequestAssignedToRequestBodyTypedDict,
            ]
        ] = None,
        due_at_time: Optional[datetime] = None,
        is_required: Optional[bool] = None,
        route_stop_id: Optional[str] = None,
        status: Optional[
            models.FormSubmissionsPatchFormSubmissionRequestBodyStatus
        ] = None,
        title: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PatchFormSubmissionResponse:
        r"""[beta] Update a single form submission.

        Updates an instance of a form submission.

        **Beta:** This endpoint is in beta and is likely to change before being broadly available. Reach out to your Samsara Representative to have Forms APIs enabled for your organization.

        <b>Rate limit:</b> 100 requests/min (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write Form Submissions** under the Closed Beta category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param id: ID of the form submission.
        :param assigned_to: Form submission assignee update object
        :param due_at_time: Due date of the form submission. UTC timestamp in RFC 3339 format.
        :param is_required: Indicates whether the worker is required to complete this form or not at a specific route stop. Defaults to `true` if the form is assigned to a user or driver. When true, the worker cannot depart the route stop until this form submission is `submitted`.
        :param route_stop_id: ID of the route stop the form submission is assigned to. Must be a unique Samsara ID.
        :param status: Status of the form submission.  Valid values: `toDo`, `dismissed`, `inProgress`
        :param title: Title of the form submission.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.FormSubmissionsPatchFormSubmissionRequestBody(
            assigned_to=utils.get_pydantic_model(
                assigned_to, Optional[models.FormSubmissionRequestAssignedToRequestBody]
            ),
            due_at_time=due_at_time,
            id=id,
            is_required=is_required,
            route_stop_id=route_stop_id,
            status=status,
            title=title,
        )

        req = self._build_request(
            method="PATCH",
            path="/form-submissions",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request,
                False,
                False,
                "json",
                models.FormSubmissionsPatchFormSubmissionRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="patchFormSubmission",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.FormSubmissionsPatchFormSubmissionResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPatchFormSubmissionUnauthorizedErrorResponseBodyData,
            )
            raise models.FormSubmissionsPatchFormSubmissionUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPatchFormSubmissionNotFoundErrorResponseBodyData,
            )
            raise models.FormSubmissionsPatchFormSubmissionNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPatchFormSubmissionMethodNotAllowedErrorResponseBodyData,
            )
            raise models.FormSubmissionsPatchFormSubmissionMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPatchFormSubmissionTooManyRequestsErrorResponseBodyData,
            )
            raise models.FormSubmissionsPatchFormSubmissionTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPatchFormSubmissionInternalServerErrorResponseBodyData,
            )
            raise models.FormSubmissionsPatchFormSubmissionInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPatchFormSubmissionNotImplementedErrorResponseBodyData,
            )
            raise models.FormSubmissionsPatchFormSubmissionNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPatchFormSubmissionBadGatewayErrorResponseBodyData,
            )
            raise models.FormSubmissionsPatchFormSubmissionBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPatchFormSubmissionServiceUnavailableErrorResponseBodyData,
            )
            raise models.FormSubmissionsPatchFormSubmissionServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPatchFormSubmissionGatewayTimeoutErrorResponseBodyData,
            )
            raise models.FormSubmissionsPatchFormSubmissionGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPatchFormSubmissionBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def patch_form_submission_async(
        self,
        *,
        id: str,
        assigned_to: Optional[
            Union[
                models.FormSubmissionRequestAssignedToRequestBody,
                models.FormSubmissionRequestAssignedToRequestBodyTypedDict,
            ]
        ] = None,
        due_at_time: Optional[datetime] = None,
        is_required: Optional[bool] = None,
        route_stop_id: Optional[str] = None,
        status: Optional[
            models.FormSubmissionsPatchFormSubmissionRequestBodyStatus
        ] = None,
        title: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PatchFormSubmissionResponse:
        r"""[beta] Update a single form submission.

        Updates an instance of a form submission.

        **Beta:** This endpoint is in beta and is likely to change before being broadly available. Reach out to your Samsara Representative to have Forms APIs enabled for your organization.

        <b>Rate limit:</b> 100 requests/min (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write Form Submissions** under the Closed Beta category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param id: ID of the form submission.
        :param assigned_to: Form submission assignee update object
        :param due_at_time: Due date of the form submission. UTC timestamp in RFC 3339 format.
        :param is_required: Indicates whether the worker is required to complete this form or not at a specific route stop. Defaults to `true` if the form is assigned to a user or driver. When true, the worker cannot depart the route stop until this form submission is `submitted`.
        :param route_stop_id: ID of the route stop the form submission is assigned to. Must be a unique Samsara ID.
        :param status: Status of the form submission.  Valid values: `toDo`, `dismissed`, `inProgress`
        :param title: Title of the form submission.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.FormSubmissionsPatchFormSubmissionRequestBody(
            assigned_to=utils.get_pydantic_model(
                assigned_to, Optional[models.FormSubmissionRequestAssignedToRequestBody]
            ),
            due_at_time=due_at_time,
            id=id,
            is_required=is_required,
            route_stop_id=route_stop_id,
            status=status,
            title=title,
        )

        req = self._build_request_async(
            method="PATCH",
            path="/form-submissions",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request,
                False,
                False,
                "json",
                models.FormSubmissionsPatchFormSubmissionRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="patchFormSubmission",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.FormSubmissionsPatchFormSubmissionResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPatchFormSubmissionUnauthorizedErrorResponseBodyData,
            )
            raise models.FormSubmissionsPatchFormSubmissionUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPatchFormSubmissionNotFoundErrorResponseBodyData,
            )
            raise models.FormSubmissionsPatchFormSubmissionNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPatchFormSubmissionMethodNotAllowedErrorResponseBodyData,
            )
            raise models.FormSubmissionsPatchFormSubmissionMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPatchFormSubmissionTooManyRequestsErrorResponseBodyData,
            )
            raise models.FormSubmissionsPatchFormSubmissionTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPatchFormSubmissionInternalServerErrorResponseBodyData,
            )
            raise models.FormSubmissionsPatchFormSubmissionInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPatchFormSubmissionNotImplementedErrorResponseBodyData,
            )
            raise models.FormSubmissionsPatchFormSubmissionNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPatchFormSubmissionBadGatewayErrorResponseBodyData,
            )
            raise models.FormSubmissionsPatchFormSubmissionBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPatchFormSubmissionServiceUnavailableErrorResponseBodyData,
            )
            raise models.FormSubmissionsPatchFormSubmissionServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPatchFormSubmissionGatewayTimeoutErrorResponseBodyData,
            )
            raise models.FormSubmissionsPatchFormSubmissionGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPatchFormSubmissionBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def post_form_submission(
        self,
        *,
        form_template: Union[
            models.FormTemplateReferenceObjectRequestBody,
            models.FormTemplateReferenceObjectRequestBodyTypedDict,
        ],
        status: models.FormSubmissionsPostFormSubmissionRequestBodyStatus,
        assigned_to: Optional[
            Union[
                models.FormSubmissionRequestAssignedToRequestBody,
                models.FormSubmissionRequestAssignedToRequestBodyTypedDict,
            ]
        ] = None,
        due_at_time: Optional[datetime] = None,
        fields: Optional[
            Union[
                List[models.FormSubmissionRequestFieldInputObjectRequestBody],
                List[models.FormSubmissionRequestFieldInputObjectRequestBodyTypedDict],
            ]
        ] = None,
        is_required: Optional[bool] = None,
        route_stop_id: Optional[str] = None,
        title: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PostFormSubmissionResponse:
        r"""[beta] Create a form submission.

        Creates a form submission.

        **Beta:** This endpoint is in beta and is likely to change before being broadly available. Reach out to your Samsara Representative to have Forms APIs enabled for your organization.

        <b>Rate limit:</b> 100 requests/min (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write Form Submissions** under the Closed Beta category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param form_template: Form template reference object.
        :param status: Status of the form submission.  Valid values: `toDo`
        :param assigned_to: Form submission assignee update object
        :param due_at_time: Due date of the form submission. UTC timestamp in RFC 3339 format.
        :param fields: List of field inputs in a form submission.
        :param is_required: Indicates whether the worker is required to complete this form or not at a specific route stop. Defaults to `true` if the form is assigned to a user or driver. When true, the worker cannot depart the route stop until this form submission is `submitted`.
        :param route_stop_id: ID of the route stop the form submission is assigned to. Must be a unique Samsara ID.
        :param title: Title of the form submission.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.FormSubmissionsPostFormSubmissionRequestBody(
            assigned_to=utils.get_pydantic_model(
                assigned_to, Optional[models.FormSubmissionRequestAssignedToRequestBody]
            ),
            due_at_time=due_at_time,
            fields=utils.get_pydantic_model(
                fields,
                Optional[List[models.FormSubmissionRequestFieldInputObjectRequestBody]],
            ),
            form_template=utils.get_pydantic_model(
                form_template, models.FormTemplateReferenceObjectRequestBody
            ),
            is_required=is_required,
            route_stop_id=route_stop_id,
            status=status,
            title=title,
        )

        req = self._build_request(
            method="POST",
            path="/form-submissions",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request,
                False,
                False,
                "json",
                models.FormSubmissionsPostFormSubmissionRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="postFormSubmission",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.FormSubmissionsPostFormSubmissionResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionUnauthorizedErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionNotFoundErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionMethodNotAllowedErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionTooManyRequestsErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionInternalServerErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionNotImplementedErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionBadGatewayErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionServiceUnavailableErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionGatewayTimeoutErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def post_form_submission_async(
        self,
        *,
        form_template: Union[
            models.FormTemplateReferenceObjectRequestBody,
            models.FormTemplateReferenceObjectRequestBodyTypedDict,
        ],
        status: models.FormSubmissionsPostFormSubmissionRequestBodyStatus,
        assigned_to: Optional[
            Union[
                models.FormSubmissionRequestAssignedToRequestBody,
                models.FormSubmissionRequestAssignedToRequestBodyTypedDict,
            ]
        ] = None,
        due_at_time: Optional[datetime] = None,
        fields: Optional[
            Union[
                List[models.FormSubmissionRequestFieldInputObjectRequestBody],
                List[models.FormSubmissionRequestFieldInputObjectRequestBodyTypedDict],
            ]
        ] = None,
        is_required: Optional[bool] = None,
        route_stop_id: Optional[str] = None,
        title: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PostFormSubmissionResponse:
        r"""[beta] Create a form submission.

        Creates a form submission.

        **Beta:** This endpoint is in beta and is likely to change before being broadly available. Reach out to your Samsara Representative to have Forms APIs enabled for your organization.

        <b>Rate limit:</b> 100 requests/min (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write Form Submissions** under the Closed Beta category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param form_template: Form template reference object.
        :param status: Status of the form submission.  Valid values: `toDo`
        :param assigned_to: Form submission assignee update object
        :param due_at_time: Due date of the form submission. UTC timestamp in RFC 3339 format.
        :param fields: List of field inputs in a form submission.
        :param is_required: Indicates whether the worker is required to complete this form or not at a specific route stop. Defaults to `true` if the form is assigned to a user or driver. When true, the worker cannot depart the route stop until this form submission is `submitted`.
        :param route_stop_id: ID of the route stop the form submission is assigned to. Must be a unique Samsara ID.
        :param title: Title of the form submission.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.FormSubmissionsPostFormSubmissionRequestBody(
            assigned_to=utils.get_pydantic_model(
                assigned_to, Optional[models.FormSubmissionRequestAssignedToRequestBody]
            ),
            due_at_time=due_at_time,
            fields=utils.get_pydantic_model(
                fields,
                Optional[List[models.FormSubmissionRequestFieldInputObjectRequestBody]],
            ),
            form_template=utils.get_pydantic_model(
                form_template, models.FormTemplateReferenceObjectRequestBody
            ),
            is_required=is_required,
            route_stop_id=route_stop_id,
            status=status,
            title=title,
        )

        req = self._build_request_async(
            method="POST",
            path="/form-submissions",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request,
                False,
                False,
                "json",
                models.FormSubmissionsPostFormSubmissionRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="postFormSubmission",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.FormSubmissionsPostFormSubmissionResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionUnauthorizedErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionNotFoundErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionMethodNotAllowedErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionTooManyRequestsErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionInternalServerErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionNotImplementedErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionBadGatewayErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionServiceUnavailableErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionGatewayTimeoutErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_form_submissions_pdf_exports(
        self,
        *,
        pdf_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetFormSubmissionsPdfExportsResponse:
        r"""[beta] Return a PDF export for a form submission.

        Returns a PDF export for a form submission.

        **Beta:** This endpoint is in beta and is likely to change before being broadly available. Reach out to your Samsara Representative to have Forms APIs enabled for your organization.

        <b>Rate limit:</b> 100 requests/min (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Form Submissions** under the Closed Beta category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param pdf_id: ID of the form submission PDF export.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetFormSubmissionsPdfExportsRequest(
            pdf_id=pdf_id,
        )

        req = self._build_request(
            method="GET",
            path="/form-submissions/pdf-exports",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getFormSubmissionsPdfExports",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsPdfExportsResponseBody,
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsPdfExportsUnauthorizedErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsPdfExportsUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsPdfExportsNotFoundErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsPdfExportsNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsPdfExportsMethodNotAllowedErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsPdfExportsMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsPdfExportsTooManyRequestsErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsPdfExportsTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsPdfExportsInternalServerErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsPdfExportsInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsPdfExportsNotImplementedErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsPdfExportsNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsPdfExportsBadGatewayErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsPdfExportsBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsPdfExportsServiceUnavailableErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsPdfExportsServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsPdfExportsGatewayTimeoutErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsPdfExportsGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsPdfExportsBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_form_submissions_pdf_exports_async(
        self,
        *,
        pdf_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetFormSubmissionsPdfExportsResponse:
        r"""[beta] Return a PDF export for a form submission.

        Returns a PDF export for a form submission.

        **Beta:** This endpoint is in beta and is likely to change before being broadly available. Reach out to your Samsara Representative to have Forms APIs enabled for your organization.

        <b>Rate limit:</b> 100 requests/min (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Form Submissions** under the Closed Beta category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param pdf_id: ID of the form submission PDF export.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetFormSubmissionsPdfExportsRequest(
            pdf_id=pdf_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/form-submissions/pdf-exports",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getFormSubmissionsPdfExports",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsPdfExportsResponseBody,
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsPdfExportsUnauthorizedErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsPdfExportsUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsPdfExportsNotFoundErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsPdfExportsNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsPdfExportsMethodNotAllowedErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsPdfExportsMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsPdfExportsTooManyRequestsErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsPdfExportsTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsPdfExportsInternalServerErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsPdfExportsInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsPdfExportsNotImplementedErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsPdfExportsNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsPdfExportsBadGatewayErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsPdfExportsBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsPdfExportsServiceUnavailableErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsPdfExportsServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsPdfExportsGatewayTimeoutErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsPdfExportsGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsPdfExportsBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def post_form_submissions_pdf_exports(
        self,
        *,
        id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PostFormSubmissionsPdfExportsResponse:
        r"""[beta] Create a PDF export for a form submission.

        Creates a PDF export for a form submission.

        **Beta:** This endpoint is in beta and is likely to change before being broadly available. Reach out to your Samsara Representative to have Forms APIs enabled for your organization.

        <b>Rate limit:</b> 100 requests/min (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write Form Submissions** under the Closed Beta category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param id: ID of the form submission to create a PDF export from.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.PostFormSubmissionsPdfExportsRequest(
            id=id,
        )

        req = self._build_request(
            method="POST",
            path="/form-submissions/pdf-exports",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="postFormSubmissionsPdfExports",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "202", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionsPdfExportsResponseBody,
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionsPdfExportsUnauthorizedErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionsPdfExportsUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionsPdfExportsNotFoundErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionsPdfExportsNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionsPdfExportsMethodNotAllowedErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionsPdfExportsMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionsPdfExportsTooManyRequestsErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionsPdfExportsTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionsPdfExportsInternalServerErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionsPdfExportsInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionsPdfExportsNotImplementedErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionsPdfExportsNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionsPdfExportsBadGatewayErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionsPdfExportsBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionsPdfExportsServiceUnavailableErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionsPdfExportsServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionsPdfExportsGatewayTimeoutErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionsPdfExportsGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionsPdfExportsBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def post_form_submissions_pdf_exports_async(
        self,
        *,
        id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PostFormSubmissionsPdfExportsResponse:
        r"""[beta] Create a PDF export for a form submission.

        Creates a PDF export for a form submission.

        **Beta:** This endpoint is in beta and is likely to change before being broadly available. Reach out to your Samsara Representative to have Forms APIs enabled for your organization.

        <b>Rate limit:</b> 100 requests/min (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write Form Submissions** under the Closed Beta category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param id: ID of the form submission to create a PDF export from.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.PostFormSubmissionsPdfExportsRequest(
            id=id,
        )

        req = self._build_request_async(
            method="POST",
            path="/form-submissions/pdf-exports",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="postFormSubmissionsPdfExports",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "202", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionsPdfExportsResponseBody,
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionsPdfExportsUnauthorizedErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionsPdfExportsUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionsPdfExportsNotFoundErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionsPdfExportsNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionsPdfExportsMethodNotAllowedErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionsPdfExportsMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionsPdfExportsTooManyRequestsErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionsPdfExportsTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionsPdfExportsInternalServerErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionsPdfExportsInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionsPdfExportsNotImplementedErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionsPdfExportsNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionsPdfExportsBadGatewayErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionsPdfExportsBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionsPdfExportsServiceUnavailableErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionsPdfExportsServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionsPdfExportsGatewayTimeoutErrorResponseBodyData,
            )
            raise models.FormSubmissionsPostFormSubmissionsPdfExportsGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsPostFormSubmissionsPdfExportsBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_form_submissions_stream(
        self,
        *,
        start_time: str,
        end_time: Optional[str] = None,
        after: Optional[str] = None,
        form_template_ids: Optional[List[str]] = None,
        user_ids: Optional[List[str]] = None,
        driver_ids: Optional[List[str]] = None,
        include: Optional[List[str]] = None,
        assigned_to_route_stop_ids: Optional[List[str]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetFormSubmissionsStreamResponse:
        r"""[beta] Get a stream of filtered form submissions.

        Returns all form submissions data that has been created or modified for your organization based on the time parameters passed in. Results are paginated and are sorted by last modified date. If you include an endTime, the endpoint will return data up until that point (exclusive). If you don’t include an endTime, you can continue to poll the API real-time with the pagination cursor that gets returned on every call.

        **Beta:** This endpoint is in beta and is likely to change before being broadly available. Reach out to your Samsara Representative to have Forms APIs enabled for your organization.

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Form Submissions** under the Closed Beta category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param start_time: A start time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param end_time: An end time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param form_template_ids: A comma-separated list containing up to 50 template IDs to filter data to.
        :param user_ids: A comma-separated list containing up to 50 user IDs to filter data to.
        :param driver_ids: A comma-separated list containing up to 50 user IDs to filter data to.
        :param include: A comma-separated list of strings indicating whether to return additional information. Valid values: `externalIds`, `fieldLabels`
        :param assigned_to_route_stop_ids: A comma-separated list containing up to 50 route stop IDs to filter data to.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetFormSubmissionsStreamRequest(
            start_time=start_time,
            end_time=end_time,
            after=after,
            form_template_ids=form_template_ids,
            user_ids=user_ids,
            driver_ids=driver_ids,
            include=include,
            assigned_to_route_stop_ids=assigned_to_route_stop_ids,
        )

        req = self._build_request(
            method="GET",
            path="/form-submissions/stream",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getFormSubmissionsStream",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsStreamResponseBody,
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsStreamUnauthorizedErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsStreamUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsStreamNotFoundErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsStreamNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsStreamMethodNotAllowedErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsStreamMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsStreamTooManyRequestsErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsStreamTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsStreamInternalServerErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsStreamInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsStreamNotImplementedErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsStreamNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsStreamBadGatewayErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsStreamBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsStreamServiceUnavailableErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsStreamServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsStreamGatewayTimeoutErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsStreamGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsStreamBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_form_submissions_stream_async(
        self,
        *,
        start_time: str,
        end_time: Optional[str] = None,
        after: Optional[str] = None,
        form_template_ids: Optional[List[str]] = None,
        user_ids: Optional[List[str]] = None,
        driver_ids: Optional[List[str]] = None,
        include: Optional[List[str]] = None,
        assigned_to_route_stop_ids: Optional[List[str]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetFormSubmissionsStreamResponse:
        r"""[beta] Get a stream of filtered form submissions.

        Returns all form submissions data that has been created or modified for your organization based on the time parameters passed in. Results are paginated and are sorted by last modified date. If you include an endTime, the endpoint will return data up until that point (exclusive). If you don’t include an endTime, you can continue to poll the API real-time with the pagination cursor that gets returned on every call.

        **Beta:** This endpoint is in beta and is likely to change before being broadly available. Reach out to your Samsara Representative to have Forms APIs enabled for your organization.

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Form Submissions** under the Closed Beta category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param start_time: A start time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param end_time: An end time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param form_template_ids: A comma-separated list containing up to 50 template IDs to filter data to.
        :param user_ids: A comma-separated list containing up to 50 user IDs to filter data to.
        :param driver_ids: A comma-separated list containing up to 50 user IDs to filter data to.
        :param include: A comma-separated list of strings indicating whether to return additional information. Valid values: `externalIds`, `fieldLabels`
        :param assigned_to_route_stop_ids: A comma-separated list containing up to 50 route stop IDs to filter data to.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetFormSubmissionsStreamRequest(
            start_time=start_time,
            end_time=end_time,
            after=after,
            form_template_ids=form_template_ids,
            user_ids=user_ids,
            driver_ids=driver_ids,
            include=include,
            assigned_to_route_stop_ids=assigned_to_route_stop_ids,
        )

        req = self._build_request_async(
            method="GET",
            path="/form-submissions/stream",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getFormSubmissionsStream",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsStreamResponseBody,
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsStreamUnauthorizedErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsStreamUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsStreamNotFoundErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsStreamNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsStreamMethodNotAllowedErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsStreamMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsStreamTooManyRequestsErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsStreamTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsStreamInternalServerErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsStreamInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsStreamNotImplementedErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsStreamNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsStreamBadGatewayErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsStreamBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsStreamServiceUnavailableErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsStreamServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsStreamGatewayTimeoutErrorResponseBodyData,
            )
            raise models.FormSubmissionsGetFormSubmissionsStreamGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.FormSubmissionsGetFormSubmissionsStreamBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def update_shipping_docs(
        self,
        *,
        hos_date: str,
        driver_id: str,
        shipping_docs: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.UpdateShippingDocsResponse:
        r"""[beta] Update the shippingDocs field of an existing assignment.

        Update the shippingDocs field of an existing assignment.

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write ELD Hours of Service (US)** under the Compliance category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param hos_date: A start date in yyyy-mm-dd format. Required.
        :param driver_id: ID of the driver for whom the duty status is being set.
        :param shipping_docs: ShippingDocs associated with the driver for the day.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.UpdateShippingDocsRequest(
            hos_date=hos_date,
            driver_id=driver_id,
            hos_daily_logs_update_shipping_docs_request_body=models.HosDailyLogsUpdateShippingDocsRequestBody(
                shipping_docs=shipping_docs,
            ),
        )

        req = self._build_request(
            method="PATCH",
            path="/hos/daily-logs/log-meta-data",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.hos_daily_logs_update_shipping_docs_request_body,
                False,
                False,
                "json",
                models.HosDailyLogsUpdateShippingDocsRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="updateShippingDocs",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.HosDailyLogsUpdateShippingDocsResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsUpdateShippingDocsUnauthorizedErrorResponseBodyData,
            )
            raise models.HosDailyLogsUpdateShippingDocsUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsUpdateShippingDocsNotFoundErrorResponseBodyData,
            )
            raise models.HosDailyLogsUpdateShippingDocsNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsUpdateShippingDocsMethodNotAllowedErrorResponseBodyData,
            )
            raise models.HosDailyLogsUpdateShippingDocsMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsUpdateShippingDocsTooManyRequestsErrorResponseBodyData,
            )
            raise models.HosDailyLogsUpdateShippingDocsTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsUpdateShippingDocsInternalServerErrorResponseBodyData,
            )
            raise models.HosDailyLogsUpdateShippingDocsInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsUpdateShippingDocsNotImplementedErrorResponseBodyData,
            )
            raise models.HosDailyLogsUpdateShippingDocsNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsUpdateShippingDocsBadGatewayErrorResponseBodyData,
            )
            raise models.HosDailyLogsUpdateShippingDocsBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsUpdateShippingDocsServiceUnavailableErrorResponseBodyData,
            )
            raise models.HosDailyLogsUpdateShippingDocsServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsUpdateShippingDocsGatewayTimeoutErrorResponseBodyData,
            )
            raise models.HosDailyLogsUpdateShippingDocsGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsUpdateShippingDocsBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def update_shipping_docs_async(
        self,
        *,
        hos_date: str,
        driver_id: str,
        shipping_docs: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.UpdateShippingDocsResponse:
        r"""[beta] Update the shippingDocs field of an existing assignment.

        Update the shippingDocs field of an existing assignment.

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write ELD Hours of Service (US)** under the Compliance category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param hos_date: A start date in yyyy-mm-dd format. Required.
        :param driver_id: ID of the driver for whom the duty status is being set.
        :param shipping_docs: ShippingDocs associated with the driver for the day.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.UpdateShippingDocsRequest(
            hos_date=hos_date,
            driver_id=driver_id,
            hos_daily_logs_update_shipping_docs_request_body=models.HosDailyLogsUpdateShippingDocsRequestBody(
                shipping_docs=shipping_docs,
            ),
        )

        req = self._build_request_async(
            method="PATCH",
            path="/hos/daily-logs/log-meta-data",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.hos_daily_logs_update_shipping_docs_request_body,
                False,
                False,
                "json",
                models.HosDailyLogsUpdateShippingDocsRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="updateShippingDocs",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.HosDailyLogsUpdateShippingDocsResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsUpdateShippingDocsUnauthorizedErrorResponseBodyData,
            )
            raise models.HosDailyLogsUpdateShippingDocsUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsUpdateShippingDocsNotFoundErrorResponseBodyData,
            )
            raise models.HosDailyLogsUpdateShippingDocsNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsUpdateShippingDocsMethodNotAllowedErrorResponseBodyData,
            )
            raise models.HosDailyLogsUpdateShippingDocsMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsUpdateShippingDocsTooManyRequestsErrorResponseBodyData,
            )
            raise models.HosDailyLogsUpdateShippingDocsTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsUpdateShippingDocsInternalServerErrorResponseBodyData,
            )
            raise models.HosDailyLogsUpdateShippingDocsInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsUpdateShippingDocsNotImplementedErrorResponseBodyData,
            )
            raise models.HosDailyLogsUpdateShippingDocsNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsUpdateShippingDocsBadGatewayErrorResponseBodyData,
            )
            raise models.HosDailyLogsUpdateShippingDocsBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsUpdateShippingDocsServiceUnavailableErrorResponseBodyData,
            )
            raise models.HosDailyLogsUpdateShippingDocsServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsUpdateShippingDocsGatewayTimeoutErrorResponseBodyData,
            )
            raise models.HosDailyLogsUpdateShippingDocsGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsUpdateShippingDocsBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_issues(
        self,
        *,
        ids: List[str],
        include: Optional[List[str]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetIssuesResponse:
        r"""[beta] Get a list of specified issues.

        Returns all issues data for the specified IDs.

        **Beta:** This endpoint is in beta and is likely to change before being broadly available. Reach out to your Samsara Representative to have Forms APIs enabled for your organization.

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Issues** under the Closed Beta category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param ids: A comma-separated list containing up to 100 issue IDs to filter on. Can be either a unique Samsara ID or an [external ID](https://developers.samsara.com/docs/external-ids) for the issue.
        :param include: A comma separated list of additional fields to include on requested objects. Valid values: `externalIds`
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetIssuesRequest(
            ids=ids,
            include=include,
        )

        req = self._build_request(
            method="GET",
            path="/issues",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getIssues",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.IssuesGetIssuesResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.IssuesGetIssuesUnauthorizedErrorResponseBodyData
            )
            raise models.IssuesGetIssuesUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.IssuesGetIssuesNotFoundErrorResponseBodyData
            )
            raise models.IssuesGetIssuesNotFoundErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.IssuesGetIssuesMethodNotAllowedErrorResponseBodyData,
            )
            raise models.IssuesGetIssuesMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.IssuesGetIssuesTooManyRequestsErrorResponseBodyData,
            )
            raise models.IssuesGetIssuesTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.IssuesGetIssuesInternalServerErrorResponseBodyData
            )
            raise models.IssuesGetIssuesInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.IssuesGetIssuesNotImplementedErrorResponseBodyData
            )
            raise models.IssuesGetIssuesNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.IssuesGetIssuesBadGatewayErrorResponseBodyData
            )
            raise models.IssuesGetIssuesBadGatewayErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.IssuesGetIssuesServiceUnavailableErrorResponseBodyData,
            )
            raise models.IssuesGetIssuesServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.IssuesGetIssuesGatewayTimeoutErrorResponseBodyData
            )
            raise models.IssuesGetIssuesGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.IssuesGetIssuesBadRequestErrorResponseBody
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_issues_async(
        self,
        *,
        ids: List[str],
        include: Optional[List[str]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetIssuesResponse:
        r"""[beta] Get a list of specified issues.

        Returns all issues data for the specified IDs.

        **Beta:** This endpoint is in beta and is likely to change before being broadly available. Reach out to your Samsara Representative to have Forms APIs enabled for your organization.

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Issues** under the Closed Beta category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param ids: A comma-separated list containing up to 100 issue IDs to filter on. Can be either a unique Samsara ID or an [external ID](https://developers.samsara.com/docs/external-ids) for the issue.
        :param include: A comma separated list of additional fields to include on requested objects. Valid values: `externalIds`
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetIssuesRequest(
            ids=ids,
            include=include,
        )

        req = self._build_request_async(
            method="GET",
            path="/issues",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getIssues",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.IssuesGetIssuesResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.IssuesGetIssuesUnauthorizedErrorResponseBodyData
            )
            raise models.IssuesGetIssuesUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.IssuesGetIssuesNotFoundErrorResponseBodyData
            )
            raise models.IssuesGetIssuesNotFoundErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.IssuesGetIssuesMethodNotAllowedErrorResponseBodyData,
            )
            raise models.IssuesGetIssuesMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.IssuesGetIssuesTooManyRequestsErrorResponseBodyData,
            )
            raise models.IssuesGetIssuesTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.IssuesGetIssuesInternalServerErrorResponseBodyData
            )
            raise models.IssuesGetIssuesInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.IssuesGetIssuesNotImplementedErrorResponseBodyData
            )
            raise models.IssuesGetIssuesNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.IssuesGetIssuesBadGatewayErrorResponseBodyData
            )
            raise models.IssuesGetIssuesBadGatewayErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.IssuesGetIssuesServiceUnavailableErrorResponseBodyData,
            )
            raise models.IssuesGetIssuesServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.IssuesGetIssuesGatewayTimeoutErrorResponseBodyData
            )
            raise models.IssuesGetIssuesGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.IssuesGetIssuesBadRequestErrorResponseBody
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def patch_issue(
        self,
        *,
        id: str,
        assigned_to: Optional[
            Union[
                models.PatchIssueRequestBodyAssignedToRequestBody,
                models.PatchIssueRequestBodyAssignedToRequestBodyTypedDict,
            ]
        ] = None,
        due_date: Optional[datetime] = None,
        external_ids: Optional[Dict[str, str]] = None,
        status: Optional[models.IssuesPatchIssueRequestBodyStatus] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PatchIssueResponse:
        r"""[beta] Update a single issue.

        Updates an instance of an issue.

        **Beta:** This endpoint is in beta and is likely to change before being broadly available. Reach out to your Samsara Representative to have Forms APIs enabled for your organization.

        <b>Rate limit:</b> 100 requests/min (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write Issues** under the Closed Beta category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param id: ID of the issue. Can be either a unique Samsara ID or an [external ID](https://developers.samsara.com/docs/external-ids) for the issue.
        :param assigned_to: Issue assignee update object
        :param due_date: Due date of the issue. UTC timestamp in RFC 3339 format.
        :param external_ids: A map of external ids
        :param status: Status of the issue.  Valid values: `open`, `inProgress`, `resolved`, `dismissed`
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.IssuesPatchIssueRequestBody(
            assigned_to=utils.get_pydantic_model(
                assigned_to, Optional[models.PatchIssueRequestBodyAssignedToRequestBody]
            ),
            due_date=due_date,
            external_ids=external_ids,
            id=id,
            status=status,
        )

        req = self._build_request(
            method="PATCH",
            path="/issues",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.IssuesPatchIssueRequestBody
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="patchIssue",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.IssuesPatchIssueResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.IssuesPatchIssueUnauthorizedErrorResponseBodyData
            )
            raise models.IssuesPatchIssueUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.IssuesPatchIssueNotFoundErrorResponseBodyData
            )
            raise models.IssuesPatchIssueNotFoundErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.IssuesPatchIssueMethodNotAllowedErrorResponseBodyData,
            )
            raise models.IssuesPatchIssueMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.IssuesPatchIssueTooManyRequestsErrorResponseBodyData,
            )
            raise models.IssuesPatchIssueTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.IssuesPatchIssueInternalServerErrorResponseBodyData,
            )
            raise models.IssuesPatchIssueInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.IssuesPatchIssueNotImplementedErrorResponseBodyData,
            )
            raise models.IssuesPatchIssueNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.IssuesPatchIssueBadGatewayErrorResponseBodyData
            )
            raise models.IssuesPatchIssueBadGatewayErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.IssuesPatchIssueServiceUnavailableErrorResponseBodyData,
            )
            raise models.IssuesPatchIssueServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.IssuesPatchIssueGatewayTimeoutErrorResponseBodyData,
            )
            raise models.IssuesPatchIssueGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.IssuesPatchIssueBadRequestErrorResponseBody
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def patch_issue_async(
        self,
        *,
        id: str,
        assigned_to: Optional[
            Union[
                models.PatchIssueRequestBodyAssignedToRequestBody,
                models.PatchIssueRequestBodyAssignedToRequestBodyTypedDict,
            ]
        ] = None,
        due_date: Optional[datetime] = None,
        external_ids: Optional[Dict[str, str]] = None,
        status: Optional[models.IssuesPatchIssueRequestBodyStatus] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PatchIssueResponse:
        r"""[beta] Update a single issue.

        Updates an instance of an issue.

        **Beta:** This endpoint is in beta and is likely to change before being broadly available. Reach out to your Samsara Representative to have Forms APIs enabled for your organization.

        <b>Rate limit:</b> 100 requests/min (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write Issues** under the Closed Beta category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param id: ID of the issue. Can be either a unique Samsara ID or an [external ID](https://developers.samsara.com/docs/external-ids) for the issue.
        :param assigned_to: Issue assignee update object
        :param due_date: Due date of the issue. UTC timestamp in RFC 3339 format.
        :param external_ids: A map of external ids
        :param status: Status of the issue.  Valid values: `open`, `inProgress`, `resolved`, `dismissed`
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.IssuesPatchIssueRequestBody(
            assigned_to=utils.get_pydantic_model(
                assigned_to, Optional[models.PatchIssueRequestBodyAssignedToRequestBody]
            ),
            due_date=due_date,
            external_ids=external_ids,
            id=id,
            status=status,
        )

        req = self._build_request_async(
            method="PATCH",
            path="/issues",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.IssuesPatchIssueRequestBody
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="patchIssue",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.IssuesPatchIssueResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.IssuesPatchIssueUnauthorizedErrorResponseBodyData
            )
            raise models.IssuesPatchIssueUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.IssuesPatchIssueNotFoundErrorResponseBodyData
            )
            raise models.IssuesPatchIssueNotFoundErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.IssuesPatchIssueMethodNotAllowedErrorResponseBodyData,
            )
            raise models.IssuesPatchIssueMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.IssuesPatchIssueTooManyRequestsErrorResponseBodyData,
            )
            raise models.IssuesPatchIssueTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.IssuesPatchIssueInternalServerErrorResponseBodyData,
            )
            raise models.IssuesPatchIssueInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.IssuesPatchIssueNotImplementedErrorResponseBodyData,
            )
            raise models.IssuesPatchIssueNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.IssuesPatchIssueBadGatewayErrorResponseBodyData
            )
            raise models.IssuesPatchIssueBadGatewayErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.IssuesPatchIssueServiceUnavailableErrorResponseBodyData,
            )
            raise models.IssuesPatchIssueServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.IssuesPatchIssueGatewayTimeoutErrorResponseBodyData,
            )
            raise models.IssuesPatchIssueGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.IssuesPatchIssueBadRequestErrorResponseBody
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_issues_stream(
        self,
        *,
        start_time: str,
        end_time: Optional[str] = None,
        after: Optional[str] = None,
        status: Optional[List[str]] = None,
        asset_ids: Optional[List[str]] = None,
        include: Optional[List[str]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetIssuesStreamResponse:
        r"""[beta] Get a stream of filtered issues.

        Returns all issues data that has been created or modified for your organization based on the time parameters passed in. Results are paginated and are sorted by last modified date. If you include an endTime, the endpoint will return data up until that point (exclusive). If you don’t include an endTime, you can continue to poll the API real-time with the pagination cursor that gets returned on every call.

        **Beta:** This endpoint is in beta and is likely to change before being broadly available. Reach out to your Samsara Representative to have Forms APIs enabled for your organization.

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Issues** under the Closed Beta category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param start_time: A start time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param end_time: An end time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param status: A comma-separated list containing status values to filter issues on. Valid values: `open`, `inProgress`, `resolved`, `dismissed`
        :param asset_ids: A comma-separated list containing up to 50 asset IDs to filter issues on. Issues with untracked assets can also be included by passing the value: 'untracked'.
        :param include: A comma separated list of additional fields to include on requested objects. Valid values: `externalIds`
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetIssuesStreamRequest(
            start_time=start_time,
            end_time=end_time,
            after=after,
            status=status,
            asset_ids=asset_ids,
            include=include,
        )

        req = self._build_request(
            method="GET",
            path="/issues/stream",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getIssuesStream",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.IssuesGetIssuesStreamResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.IssuesGetIssuesStreamUnauthorizedErrorResponseBodyData,
            )
            raise models.IssuesGetIssuesStreamUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.IssuesGetIssuesStreamNotFoundErrorResponseBodyData
            )
            raise models.IssuesGetIssuesStreamNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.IssuesGetIssuesStreamMethodNotAllowedErrorResponseBodyData,
            )
            raise models.IssuesGetIssuesStreamMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.IssuesGetIssuesStreamTooManyRequestsErrorResponseBodyData,
            )
            raise models.IssuesGetIssuesStreamTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.IssuesGetIssuesStreamInternalServerErrorResponseBodyData,
            )
            raise models.IssuesGetIssuesStreamInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.IssuesGetIssuesStreamNotImplementedErrorResponseBodyData,
            )
            raise models.IssuesGetIssuesStreamNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.IssuesGetIssuesStreamBadGatewayErrorResponseBodyData,
            )
            raise models.IssuesGetIssuesStreamBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.IssuesGetIssuesStreamServiceUnavailableErrorResponseBodyData,
            )
            raise models.IssuesGetIssuesStreamServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.IssuesGetIssuesStreamGatewayTimeoutErrorResponseBodyData,
            )
            raise models.IssuesGetIssuesStreamGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.IssuesGetIssuesStreamBadRequestErrorResponseBody
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_issues_stream_async(
        self,
        *,
        start_time: str,
        end_time: Optional[str] = None,
        after: Optional[str] = None,
        status: Optional[List[str]] = None,
        asset_ids: Optional[List[str]] = None,
        include: Optional[List[str]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetIssuesStreamResponse:
        r"""[beta] Get a stream of filtered issues.

        Returns all issues data that has been created or modified for your organization based on the time parameters passed in. Results are paginated and are sorted by last modified date. If you include an endTime, the endpoint will return data up until that point (exclusive). If you don’t include an endTime, you can continue to poll the API real-time with the pagination cursor that gets returned on every call.

        **Beta:** This endpoint is in beta and is likely to change before being broadly available. Reach out to your Samsara Representative to have Forms APIs enabled for your organization.

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Issues** under the Closed Beta category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param start_time: A start time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param end_time: An end time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param status: A comma-separated list containing status values to filter issues on. Valid values: `open`, `inProgress`, `resolved`, `dismissed`
        :param asset_ids: A comma-separated list containing up to 50 asset IDs to filter issues on. Issues with untracked assets can also be included by passing the value: 'untracked'.
        :param include: A comma separated list of additional fields to include on requested objects. Valid values: `externalIds`
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetIssuesStreamRequest(
            start_time=start_time,
            end_time=end_time,
            after=after,
            status=status,
            asset_ids=asset_ids,
            include=include,
        )

        req = self._build_request_async(
            method="GET",
            path="/issues/stream",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getIssuesStream",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.IssuesGetIssuesStreamResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.IssuesGetIssuesStreamUnauthorizedErrorResponseBodyData,
            )
            raise models.IssuesGetIssuesStreamUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.IssuesGetIssuesStreamNotFoundErrorResponseBodyData
            )
            raise models.IssuesGetIssuesStreamNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.IssuesGetIssuesStreamMethodNotAllowedErrorResponseBodyData,
            )
            raise models.IssuesGetIssuesStreamMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.IssuesGetIssuesStreamTooManyRequestsErrorResponseBodyData,
            )
            raise models.IssuesGetIssuesStreamTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.IssuesGetIssuesStreamInternalServerErrorResponseBodyData,
            )
            raise models.IssuesGetIssuesStreamInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.IssuesGetIssuesStreamNotImplementedErrorResponseBodyData,
            )
            raise models.IssuesGetIssuesStreamNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.IssuesGetIssuesStreamBadGatewayErrorResponseBodyData,
            )
            raise models.IssuesGetIssuesStreamBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.IssuesGetIssuesStreamServiceUnavailableErrorResponseBodyData,
            )
            raise models.IssuesGetIssuesStreamServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.IssuesGetIssuesStreamGatewayTimeoutErrorResponseBodyData,
            )
            raise models.IssuesGetIssuesStreamGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.IssuesGetIssuesStreamBadRequestErrorResponseBody
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_speeding_intervals(
        self,
        *,
        asset_ids: List[str],
        start_time: str,
        end_time: Optional[str] = None,
        query_by: Optional[models.QueryBy] = models.QueryBy.UPDATED_AT_TIME,
        include_asset: Optional[bool] = False,
        include_driver_id: Optional[bool] = False,
        after: Optional[str] = None,
        severity_levels: Optional[List[str]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetSpeedingIntervalsResponse:
        r"""[beta] Get Speeding Intervals

        This endpoint will return all speeding intervals associated with trips that have been collected for your organization based on the time parameters passed in. Only completed trips are included. Results are paginated.

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Speeding Intervals** under the Speeding Intervals category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param asset_ids: Comma-separated list of asset IDs. Include up to 50 asset IDs.
        :param start_time: RFC 3339 timestamp that indicates when to begin receiving data. Value is compared against `updatedAtTime` or `tripStartTime` depending on the queryBy parameter.
        :param end_time: RFC 3339 timestamp which is compared against `updatedAtTime` or `tripStartTime` depending on the queryBy parameter. If not provided then the endpoint behaves as an unending feed of changes.
        :param query_by: Decide which timestamp the `startTime` and `endTime` are compared to.  Valid values: `updatedAtTime`, `tripStartTime`
        :param include_asset: Indicates whether or not to return expanded “asset” data
        :param include_driver_id: Indicates whether or not to return trip's driver id
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param severity_levels: Optional string of comma-separated severity levels to filter speeding intervals by. Valid values:  “light”, ”moderate”, ”heavy”, “severe”.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetSpeedingIntervalsRequest(
            asset_ids=asset_ids,
            start_time=start_time,
            end_time=end_time,
            query_by=query_by,
            include_asset=include_asset,
            include_driver_id=include_driver_id,
            after=after,
            severity_levels=severity_levels,
        )

        req = self._build_request(
            method="GET",
            path="/speeding-intervals/stream",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getSpeedingIntervals",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.SpeedingIntervalsGetSpeedingIntervalsResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.SpeedingIntervalsGetSpeedingIntervalsUnauthorizedErrorResponseBodyData,
            )
            raise models.SpeedingIntervalsGetSpeedingIntervalsUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.SpeedingIntervalsGetSpeedingIntervalsNotFoundErrorResponseBodyData,
            )
            raise models.SpeedingIntervalsGetSpeedingIntervalsNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.SpeedingIntervalsGetSpeedingIntervalsMethodNotAllowedErrorResponseBodyData,
            )
            raise models.SpeedingIntervalsGetSpeedingIntervalsMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.SpeedingIntervalsGetSpeedingIntervalsTooManyRequestsErrorResponseBodyData,
            )
            raise models.SpeedingIntervalsGetSpeedingIntervalsTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.SpeedingIntervalsGetSpeedingIntervalsInternalServerErrorResponseBodyData,
            )
            raise models.SpeedingIntervalsGetSpeedingIntervalsInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.SpeedingIntervalsGetSpeedingIntervalsNotImplementedErrorResponseBodyData,
            )
            raise models.SpeedingIntervalsGetSpeedingIntervalsNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.SpeedingIntervalsGetSpeedingIntervalsBadGatewayErrorResponseBodyData,
            )
            raise models.SpeedingIntervalsGetSpeedingIntervalsBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.SpeedingIntervalsGetSpeedingIntervalsServiceUnavailableErrorResponseBodyData,
            )
            raise models.SpeedingIntervalsGetSpeedingIntervalsServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.SpeedingIntervalsGetSpeedingIntervalsGatewayTimeoutErrorResponseBodyData,
            )
            raise models.SpeedingIntervalsGetSpeedingIntervalsGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.SpeedingIntervalsGetSpeedingIntervalsBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_speeding_intervals_async(
        self,
        *,
        asset_ids: List[str],
        start_time: str,
        end_time: Optional[str] = None,
        query_by: Optional[models.QueryBy] = models.QueryBy.UPDATED_AT_TIME,
        include_asset: Optional[bool] = False,
        include_driver_id: Optional[bool] = False,
        after: Optional[str] = None,
        severity_levels: Optional[List[str]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetSpeedingIntervalsResponse:
        r"""[beta] Get Speeding Intervals

        This endpoint will return all speeding intervals associated with trips that have been collected for your organization based on the time parameters passed in. Only completed trips are included. Results are paginated.

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Speeding Intervals** under the Speeding Intervals category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param asset_ids: Comma-separated list of asset IDs. Include up to 50 asset IDs.
        :param start_time: RFC 3339 timestamp that indicates when to begin receiving data. Value is compared against `updatedAtTime` or `tripStartTime` depending on the queryBy parameter.
        :param end_time: RFC 3339 timestamp which is compared against `updatedAtTime` or `tripStartTime` depending on the queryBy parameter. If not provided then the endpoint behaves as an unending feed of changes.
        :param query_by: Decide which timestamp the `startTime` and `endTime` are compared to.  Valid values: `updatedAtTime`, `tripStartTime`
        :param include_asset: Indicates whether or not to return expanded “asset” data
        :param include_driver_id: Indicates whether or not to return trip's driver id
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param severity_levels: Optional string of comma-separated severity levels to filter speeding intervals by. Valid values:  “light”, ”moderate”, ”heavy”, “severe”.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetSpeedingIntervalsRequest(
            asset_ids=asset_ids,
            start_time=start_time,
            end_time=end_time,
            query_by=query_by,
            include_asset=include_asset,
            include_driver_id=include_driver_id,
            after=after,
            severity_levels=severity_levels,
        )

        req = self._build_request_async(
            method="GET",
            path="/speeding-intervals/stream",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getSpeedingIntervals",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.SpeedingIntervalsGetSpeedingIntervalsResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.SpeedingIntervalsGetSpeedingIntervalsUnauthorizedErrorResponseBodyData,
            )
            raise models.SpeedingIntervalsGetSpeedingIntervalsUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.SpeedingIntervalsGetSpeedingIntervalsNotFoundErrorResponseBodyData,
            )
            raise models.SpeedingIntervalsGetSpeedingIntervalsNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.SpeedingIntervalsGetSpeedingIntervalsMethodNotAllowedErrorResponseBodyData,
            )
            raise models.SpeedingIntervalsGetSpeedingIntervalsMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.SpeedingIntervalsGetSpeedingIntervalsTooManyRequestsErrorResponseBodyData,
            )
            raise models.SpeedingIntervalsGetSpeedingIntervalsTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.SpeedingIntervalsGetSpeedingIntervalsInternalServerErrorResponseBodyData,
            )
            raise models.SpeedingIntervalsGetSpeedingIntervalsInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.SpeedingIntervalsGetSpeedingIntervalsNotImplementedErrorResponseBodyData,
            )
            raise models.SpeedingIntervalsGetSpeedingIntervalsNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.SpeedingIntervalsGetSpeedingIntervalsBadGatewayErrorResponseBodyData,
            )
            raise models.SpeedingIntervalsGetSpeedingIntervalsBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.SpeedingIntervalsGetSpeedingIntervalsServiceUnavailableErrorResponseBodyData,
            )
            raise models.SpeedingIntervalsGetSpeedingIntervalsServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.SpeedingIntervalsGetSpeedingIntervalsGatewayTimeoutErrorResponseBodyData,
            )
            raise models.SpeedingIntervalsGetSpeedingIntervalsGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.SpeedingIntervalsGetSpeedingIntervalsBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def post_training_assignments(
        self,
        *,
        course_id: str,
        due_at_time: str,
        learner_ids: List[str],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PostTrainingAssignmentsResponse:
        r"""[beta] Create training assignments.

        Create training assignments. Existing assignments will remain unchanged.

        **Beta:** This endpoint is in beta and is likely to change before being broadly available. Reach out to your Samsara Representative to have Training APIs enabled for your organization.

        <b>Rate limit:</b> 10 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write Training Assignments** under the Closed Beta category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param course_id: String for the course ID.
        :param due_at_time: Due date of the training assignment in RFC 3339 format. Millisecond precision and timezones are supported.
        :param learner_ids: Optional string of comma separated learner IDs. If learner ID is present, training assignments for the specified learner(s) will be returned. Max value for this value is 100 objects. Example: `learnerIds=driver-281474,driver-46282156`
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.PostTrainingAssignmentsRequest(
            course_id=course_id,
            due_at_time=due_at_time,
            learner_ids=learner_ids,
        )

        req = self._build_request(
            method="POST",
            path="/training-assignments",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="postTrainingAssignments",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsPostTrainingAssignmentsResponseBody,
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsPostTrainingAssignmentsUnauthorizedErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsPostTrainingAssignmentsUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsPostTrainingAssignmentsNotFoundErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsPostTrainingAssignmentsNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsPostTrainingAssignmentsMethodNotAllowedErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsPostTrainingAssignmentsMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsPostTrainingAssignmentsTooManyRequestsErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsPostTrainingAssignmentsTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsPostTrainingAssignmentsInternalServerErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsPostTrainingAssignmentsInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsPostTrainingAssignmentsNotImplementedErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsPostTrainingAssignmentsNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsPostTrainingAssignmentsBadGatewayErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsPostTrainingAssignmentsBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsPostTrainingAssignmentsServiceUnavailableErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsPostTrainingAssignmentsServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsPostTrainingAssignmentsGatewayTimeoutErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsPostTrainingAssignmentsGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsPostTrainingAssignmentsBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def post_training_assignments_async(
        self,
        *,
        course_id: str,
        due_at_time: str,
        learner_ids: List[str],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PostTrainingAssignmentsResponse:
        r"""[beta] Create training assignments.

        Create training assignments. Existing assignments will remain unchanged.

        **Beta:** This endpoint is in beta and is likely to change before being broadly available. Reach out to your Samsara Representative to have Training APIs enabled for your organization.

        <b>Rate limit:</b> 10 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Write Training Assignments** under the Closed Beta category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param course_id: String for the course ID.
        :param due_at_time: Due date of the training assignment in RFC 3339 format. Millisecond precision and timezones are supported.
        :param learner_ids: Optional string of comma separated learner IDs. If learner ID is present, training assignments for the specified learner(s) will be returned. Max value for this value is 100 objects. Example: `learnerIds=driver-281474,driver-46282156`
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.PostTrainingAssignmentsRequest(
            course_id=course_id,
            due_at_time=due_at_time,
            learner_ids=learner_ids,
        )

        req = self._build_request_async(
            method="POST",
            path="/training-assignments",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="postTrainingAssignments",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsPostTrainingAssignmentsResponseBody,
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsPostTrainingAssignmentsUnauthorizedErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsPostTrainingAssignmentsUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsPostTrainingAssignmentsNotFoundErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsPostTrainingAssignmentsNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsPostTrainingAssignmentsMethodNotAllowedErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsPostTrainingAssignmentsMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsPostTrainingAssignmentsTooManyRequestsErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsPostTrainingAssignmentsTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsPostTrainingAssignmentsInternalServerErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsPostTrainingAssignmentsInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsPostTrainingAssignmentsNotImplementedErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsPostTrainingAssignmentsNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsPostTrainingAssignmentsBadGatewayErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsPostTrainingAssignmentsBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsPostTrainingAssignmentsServiceUnavailableErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsPostTrainingAssignmentsServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsPostTrainingAssignmentsGatewayTimeoutErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsPostTrainingAssignmentsGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsPostTrainingAssignmentsBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_training_assignments_stream(
        self,
        *,
        start_time: str,
        after: Optional[str] = None,
        end_time: Optional[str] = None,
        learner_ids: Optional[List[str]] = None,
        course_ids: Optional[List[str]] = None,
        status: Optional[List[str]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetTrainingAssignmentsStreamResponse:
        r"""[beta] Get a stream of filtered training assignments.

        Returns all training assignments data that has been created or modified for your organization based on the time parameters passed in. Results are paginated and are sorted by last modified date. If you include an endTime, the endpoint will return data up until that point (exclusive). If you don't include an endTime, you can continue to poll the API real-time with the pagination cursor that gets returned on every call.

        **Beta:** This endpoint is in beta and is likely to change before being broadly available. Reach out to your Samsara Representative to have Training APIs enabled for your organization.

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Training Assignments** under the Closed Beta category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param start_time: A start time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param end_time: An end time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param learner_ids: Optional string of comma separated learner IDs. If learner ID is present, training assignments for the specified learner(s) will be returned. Max value for this value is 100 objects. Example: `learnerIds=driver-281474,driver-46282156`
        :param course_ids: Optional string of comma separated course IDs. If course ID is present, training assignments for the specified course ID(s) will be returned. Max value for this value is 100 objects. Defaults to returning all courses. Example: `courseIds=a4db8702-79d5-4396-a717-e301d52ecc11,c6490f6a-d84e-49b5-b0ad-b6baae304075`
        :param status: Optional string of comma separated values. If status is present, training assignments for the specified status(s) will be returned. Valid values: \"notStarted\", \"inProgress\", \"completed\". Defaults to returning all courses.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetTrainingAssignmentsStreamRequest(
            after=after,
            start_time=start_time,
            end_time=end_time,
            learner_ids=learner_ids,
            course_ids=course_ids,
            status=status,
        )

        req = self._build_request(
            method="GET",
            path="/training-assignments/stream",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getTrainingAssignmentsStream",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsGetTrainingAssignmentsStreamResponseBody,
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsGetTrainingAssignmentsStreamUnauthorizedErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsGetTrainingAssignmentsStreamUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsGetTrainingAssignmentsStreamNotFoundErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsGetTrainingAssignmentsStreamNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsGetTrainingAssignmentsStreamMethodNotAllowedErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsGetTrainingAssignmentsStreamMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsGetTrainingAssignmentsStreamTooManyRequestsErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsGetTrainingAssignmentsStreamTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsGetTrainingAssignmentsStreamInternalServerErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsGetTrainingAssignmentsStreamInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsGetTrainingAssignmentsStreamNotImplementedErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsGetTrainingAssignmentsStreamNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsGetTrainingAssignmentsStreamBadGatewayErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsGetTrainingAssignmentsStreamBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsGetTrainingAssignmentsStreamServiceUnavailableErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsGetTrainingAssignmentsStreamServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsGetTrainingAssignmentsStreamGatewayTimeoutErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsGetTrainingAssignmentsStreamGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsGetTrainingAssignmentsStreamBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_training_assignments_stream_async(
        self,
        *,
        start_time: str,
        after: Optional[str] = None,
        end_time: Optional[str] = None,
        learner_ids: Optional[List[str]] = None,
        course_ids: Optional[List[str]] = None,
        status: Optional[List[str]] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetTrainingAssignmentsStreamResponse:
        r"""[beta] Get a stream of filtered training assignments.

        Returns all training assignments data that has been created or modified for your organization based on the time parameters passed in. Results are paginated and are sorted by last modified date. If you include an endTime, the endpoint will return data up until that point (exclusive). If you don't include an endTime, you can continue to poll the API real-time with the pagination cursor that gets returned on every call.

        **Beta:** This endpoint is in beta and is likely to change before being broadly available. Reach out to your Samsara Representative to have Training APIs enabled for your organization.

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Training Assignments** under the Closed Beta category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param start_time: A start time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param end_time: An end time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param learner_ids: Optional string of comma separated learner IDs. If learner ID is present, training assignments for the specified learner(s) will be returned. Max value for this value is 100 objects. Example: `learnerIds=driver-281474,driver-46282156`
        :param course_ids: Optional string of comma separated course IDs. If course ID is present, training assignments for the specified course ID(s) will be returned. Max value for this value is 100 objects. Defaults to returning all courses. Example: `courseIds=a4db8702-79d5-4396-a717-e301d52ecc11,c6490f6a-d84e-49b5-b0ad-b6baae304075`
        :param status: Optional string of comma separated values. If status is present, training assignments for the specified status(s) will be returned. Valid values: \"notStarted\", \"inProgress\", \"completed\". Defaults to returning all courses.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetTrainingAssignmentsStreamRequest(
            after=after,
            start_time=start_time,
            end_time=end_time,
            learner_ids=learner_ids,
            course_ids=course_ids,
            status=status,
        )

        req = self._build_request_async(
            method="GET",
            path="/training-assignments/stream",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getTrainingAssignmentsStream",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsGetTrainingAssignmentsStreamResponseBody,
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsGetTrainingAssignmentsStreamUnauthorizedErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsGetTrainingAssignmentsStreamUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsGetTrainingAssignmentsStreamNotFoundErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsGetTrainingAssignmentsStreamNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsGetTrainingAssignmentsStreamMethodNotAllowedErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsGetTrainingAssignmentsStreamMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsGetTrainingAssignmentsStreamTooManyRequestsErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsGetTrainingAssignmentsStreamTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsGetTrainingAssignmentsStreamInternalServerErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsGetTrainingAssignmentsStreamInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsGetTrainingAssignmentsStreamNotImplementedErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsGetTrainingAssignmentsStreamNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsGetTrainingAssignmentsStreamBadGatewayErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsGetTrainingAssignmentsStreamBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsGetTrainingAssignmentsStreamServiceUnavailableErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsGetTrainingAssignmentsStreamServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsGetTrainingAssignmentsStreamGatewayTimeoutErrorResponseBodyData,
            )
            raise models.TrainingAssignmentsGetTrainingAssignmentsStreamGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.TrainingAssignmentsGetTrainingAssignmentsStreamBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_trips(
        self,
        *,
        start_time: str,
        ids: List[str],
        include_asset: Optional[bool] = False,
        completion_status: Optional[
            models.QueryParamCompletionStatus
        ] = models.QueryParamCompletionStatus.ALL,
        end_time: Optional[str] = None,
        query_by: Optional[
            models.QueryParamQueryBy
        ] = models.QueryParamQueryBy.UPDATED_AT_TIME,
        after: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetTripsResponse:
        r"""[beta] Get trips

        This endpoint will return trips that have been collected for your organization based on the time parameters passed in. Results are paginated. Reach out to your Samsara Representative to have this API enabled for your organization.

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Trips** under the Trips category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param start_time: RFC 3339 timestamp that indicates when to begin receiving data. Value is compared against `updatedAtTime` or `tripStartTime` depending on the queryBy parameter.
        :param ids: Comma-separated list of asset IDs. Include up to 50 asset IDs.
        :param include_asset: Indicates whether or not to return expanded “asset” data
        :param completion_status: Filters trips based on a specific completion status  Valid values: `inProgress`, `completed`, `all`
        :param end_time: RFC 3339 timestamp which is compared against `updatedAtTime` or `tripStartTime` depending on the queryBy parameter. If not provided then the endpoint behaves as an unending feed of changes.
        :param query_by: Decide which timestamp the `startTime` and `endTime` are compared to.  Valid values: `updatedAtTime`, `tripStartTime`
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetTripsRequest(
            include_asset=include_asset,
            completion_status=completion_status,
            start_time=start_time,
            end_time=end_time,
            query_by=query_by,
            after=after,
            ids=ids,
        )

        req = self._build_request(
            method="GET",
            path="/trips/stream",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getTrips",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.TripsGetTripsResponseBody)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.TripsGetTripsUnauthorizedErrorResponseBodyData
            )
            raise models.TripsGetTripsUnauthorizedErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.TripsGetTripsNotFoundErrorResponseBodyData
            )
            raise models.TripsGetTripsNotFoundErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.TripsGetTripsMethodNotAllowedErrorResponseBodyData
            )
            raise models.TripsGetTripsMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.TripsGetTripsTooManyRequestsErrorResponseBodyData
            )
            raise models.TripsGetTripsTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.TripsGetTripsInternalServerErrorResponseBodyData
            )
            raise models.TripsGetTripsInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.TripsGetTripsNotImplementedErrorResponseBodyData
            )
            raise models.TripsGetTripsNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.TripsGetTripsBadGatewayErrorResponseBodyData
            )
            raise models.TripsGetTripsBadGatewayErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TripsGetTripsServiceUnavailableErrorResponseBodyData,
            )
            raise models.TripsGetTripsServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.TripsGetTripsGatewayTimeoutErrorResponseBodyData
            )
            raise models.TripsGetTripsGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.TripsGetTripsBadRequestErrorResponseBody
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_trips_async(
        self,
        *,
        start_time: str,
        ids: List[str],
        include_asset: Optional[bool] = False,
        completion_status: Optional[
            models.QueryParamCompletionStatus
        ] = models.QueryParamCompletionStatus.ALL,
        end_time: Optional[str] = None,
        query_by: Optional[
            models.QueryParamQueryBy
        ] = models.QueryParamQueryBy.UPDATED_AT_TIME,
        after: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetTripsResponse:
        r"""[beta] Get trips

        This endpoint will return trips that have been collected for your organization based on the time parameters passed in. Results are paginated. Reach out to your Samsara Representative to have this API enabled for your organization.

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read Trips** under the Trips category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param start_time: RFC 3339 timestamp that indicates when to begin receiving data. Value is compared against `updatedAtTime` or `tripStartTime` depending on the queryBy parameter.
        :param ids: Comma-separated list of asset IDs. Include up to 50 asset IDs.
        :param include_asset: Indicates whether or not to return expanded “asset” data
        :param completion_status: Filters trips based on a specific completion status  Valid values: `inProgress`, `completed`, `all`
        :param end_time: RFC 3339 timestamp which is compared against `updatedAtTime` or `tripStartTime` depending on the queryBy parameter. If not provided then the endpoint behaves as an unending feed of changes.
        :param query_by: Decide which timestamp the `startTime` and `endTime` are compared to.  Valid values: `updatedAtTime`, `tripStartTime`
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetTripsRequest(
            include_asset=include_asset,
            completion_status=completion_status,
            start_time=start_time,
            end_time=end_time,
            query_by=query_by,
            after=after,
            ids=ids,
        )

        req = self._build_request_async(
            method="GET",
            path="/trips/stream",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getTrips",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.TripsGetTripsResponseBody)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.TripsGetTripsUnauthorizedErrorResponseBodyData
            )
            raise models.TripsGetTripsUnauthorizedErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.TripsGetTripsNotFoundErrorResponseBodyData
            )
            raise models.TripsGetTripsNotFoundErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.TripsGetTripsMethodNotAllowedErrorResponseBodyData
            )
            raise models.TripsGetTripsMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.TripsGetTripsTooManyRequestsErrorResponseBodyData
            )
            raise models.TripsGetTripsTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.TripsGetTripsInternalServerErrorResponseBodyData
            )
            raise models.TripsGetTripsInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.TripsGetTripsNotImplementedErrorResponseBodyData
            )
            raise models.TripsGetTripsNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.TripsGetTripsBadGatewayErrorResponseBodyData
            )
            raise models.TripsGetTripsBadGatewayErrorResponseBody(data=response_data)
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.TripsGetTripsServiceUnavailableErrorResponseBodyData,
            )
            raise models.TripsGetTripsServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text, models.TripsGetTripsGatewayTimeoutErrorResponseBodyData
            )
            raise models.TripsGetTripsGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.TripsGetTripsBadRequestErrorResponseBody
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )
