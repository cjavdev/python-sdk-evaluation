"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .goaaddresstinyresponseresponsebody import (
    GoaAddressTinyResponseResponseBody,
    GoaAddressTinyResponseResponseBodyTypedDict,
)
from .goadocumenttinyresponseresponsebody import (
    GoaDocumentTinyResponseResponseBody,
    GoaDocumentTinyResponseResponseBodyTypedDict,
)
from .livesharinglinkresponseobjectresponsebody import (
    LiveSharingLinkResponseObjectResponseBody,
    LiveSharingLinkResponseObjectResponseBodyTypedDict,
)
from .routessingleuseaddressobjectresponsebody import (
    RoutesSingleUseAddressObjectResponseBody,
    RoutesSingleUseAddressObjectResponseBodyTypedDict,
)
from datetime import datetime
from enum import Enum
import pydantic
from samsara.types import BaseModel
from typing import Dict, List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class RoutesStopResponseObjectResponseBodyState(str, Enum):
    r"""The current state of the route stop.  Valid values: `unassigned`, `scheduled`, `en route`, `skipped`, `arrived`, `departed`"""

    UNASSIGNED = "unassigned"
    SCHEDULED = "scheduled"
    EN_ROUTE = "en route"
    SKIPPED = "skipped"
    ARRIVED = "arrived"
    DEPARTED = "departed"


class RoutesStopResponseObjectResponseBodyTypedDict(TypedDict):
    id: str
    r"""Id of the stop"""
    name: str
    r"""Name of the stop"""
    state: RoutesStopResponseObjectResponseBodyState
    r"""The current state of the route stop.  Valid values: `unassigned`, `scheduled`, `en route`, `skipped`, `arrived`, `departed`"""
    actual_arrival_time: NotRequired[datetime]
    r"""Actual arrival time, if it exists, for the route stop in RFC 3339 format."""
    actual_departure_time: NotRequired[datetime]
    r"""Actual departure time, if it exists, for the route stop in RFC 3339 format."""
    address: NotRequired[GoaAddressTinyResponseResponseBodyTypedDict]
    r"""A minified Address object"""
    documents: NotRequired[List[GoaDocumentTinyResponseResponseBodyTypedDict]]
    r"""List of documents associated with the stop."""
    en_route_time: NotRequired[datetime]
    r"""The time the stop became en-route, in RFC 3339 format."""
    eta: NotRequired[datetime]
    r"""Estimated time of arrival, if this stop is currently en-route, in RFC 3339 format."""
    external_ids: NotRequired[Dict[str, str]]
    r"""A map of external ids"""
    live_sharing_url: NotRequired[str]
    r"""The shareable url of the stop's current status."""
    location_live_sharing_links: NotRequired[
        List[LiveSharingLinkResponseObjectResponseBodyTypedDict]
    ]
    r"""List of shareable, non-expired 'By Location' Live Sharing Links."""
    notes: NotRequired[str]
    r"""Notes for the stop"""
    ontime_window_after_arrival_ms: NotRequired[int]
    r"""Specifies the time window (in milliseconds) after a stop's scheduled arrival time during which the stop is considered 'on-time'."""
    ontime_window_before_arrival_ms: NotRequired[int]
    r"""Specifies the time window (in milliseconds) before a stop's scheduled arrival time during which the stop is considered 'on-time'."""
    scheduled_arrival_time: NotRequired[datetime]
    r"""Scheduled arrival time, if it exists, for the stop in RFC 3339 format."""
    scheduled_departure_time: NotRequired[datetime]
    r"""Scheduled departure time, if it exists, for the stop in RFC 3339 format."""
    single_use_location: NotRequired[RoutesSingleUseAddressObjectResponseBodyTypedDict]
    r"""This field is used to indicate stops along the route for which an address has not been persisted. This field is mutually exclusive with addressId."""
    skipped_time: NotRequired[datetime]
    r"""Skipped time, if it exists, for the route stop in RFC 3339 format."""


class RoutesStopResponseObjectResponseBody(BaseModel):
    id: str
    r"""Id of the stop"""

    name: str
    r"""Name of the stop"""

    state: RoutesStopResponseObjectResponseBodyState
    r"""The current state of the route stop.  Valid values: `unassigned`, `scheduled`, `en route`, `skipped`, `arrived`, `departed`"""

    actual_arrival_time: Annotated[
        Optional[datetime], pydantic.Field(alias="actualArrivalTime")
    ] = None
    r"""Actual arrival time, if it exists, for the route stop in RFC 3339 format."""

    actual_departure_time: Annotated[
        Optional[datetime], pydantic.Field(alias="actualDepartureTime")
    ] = None
    r"""Actual departure time, if it exists, for the route stop in RFC 3339 format."""

    address: Optional[GoaAddressTinyResponseResponseBody] = None
    r"""A minified Address object"""

    documents: Optional[List[GoaDocumentTinyResponseResponseBody]] = None
    r"""List of documents associated with the stop."""

    en_route_time: Annotated[
        Optional[datetime], pydantic.Field(alias="enRouteTime")
    ] = None
    r"""The time the stop became en-route, in RFC 3339 format."""

    eta: Optional[datetime] = None
    r"""Estimated time of arrival, if this stop is currently en-route, in RFC 3339 format."""

    external_ids: Annotated[
        Optional[Dict[str, str]], pydantic.Field(alias="externalIds")
    ] = None
    r"""A map of external ids"""

    live_sharing_url: Annotated[
        Optional[str], pydantic.Field(alias="liveSharingUrl")
    ] = None
    r"""The shareable url of the stop's current status."""

    location_live_sharing_links: Annotated[
        Optional[List[LiveSharingLinkResponseObjectResponseBody]],
        pydantic.Field(alias="locationLiveSharingLinks"),
    ] = None
    r"""List of shareable, non-expired 'By Location' Live Sharing Links."""

    notes: Optional[str] = None
    r"""Notes for the stop"""

    ontime_window_after_arrival_ms: Annotated[
        Optional[int], pydantic.Field(alias="ontimeWindowAfterArrivalMs")
    ] = None
    r"""Specifies the time window (in milliseconds) after a stop's scheduled arrival time during which the stop is considered 'on-time'."""

    ontime_window_before_arrival_ms: Annotated[
        Optional[int], pydantic.Field(alias="ontimeWindowBeforeArrivalMs")
    ] = None
    r"""Specifies the time window (in milliseconds) before a stop's scheduled arrival time during which the stop is considered 'on-time'."""

    scheduled_arrival_time: Annotated[
        Optional[datetime], pydantic.Field(alias="scheduledArrivalTime")
    ] = None
    r"""Scheduled arrival time, if it exists, for the stop in RFC 3339 format."""

    scheduled_departure_time: Annotated[
        Optional[datetime], pydantic.Field(alias="scheduledDepartureTime")
    ] = None
    r"""Scheduled departure time, if it exists, for the stop in RFC 3339 format."""

    single_use_location: Annotated[
        Optional[RoutesSingleUseAddressObjectResponseBody],
        pydantic.Field(alias="singleUseLocation"),
    ] = None
    r"""This field is used to indicate stops along the route for which an address has not been persisted. This field is mutually exclusive with addressId."""

    skipped_time: Annotated[Optional[datetime], pydantic.Field(alias="skippedTime")] = (
        None
    )
    r"""Skipped time, if it exists, for the route stop in RFC 3339 format."""
