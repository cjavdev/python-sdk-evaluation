"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from samsara import models, utils
from samsara._hooks import HookContext
from samsara.types import OptionalNullable, UNSET
from samsara.utils import get_security_from_env
from typing import Any, List, Mapping, Optional


class HoursOfService(BaseSDK):
    def get_hos_clocks(
        self,
        *,
        tag_ids: Optional[List[str]] = None,
        parent_tag_ids: Optional[List[str]] = None,
        driver_ids: Optional[List[str]] = None,
        after: Optional[str] = None,
        limit: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetHosClocksResponse:
        r"""Get HOS clocks

        Get the current HOS status for all drivers. Note that this includes inactive as well as active drivers. The legacy version of this endpoint can be found at [samsara.com/api-legacy](https://www.samsara.com/api-legacy#operation/getFleetHosLogsSummary).

        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        To use this endpoint, select **Read ELD Compliance Settings (US)** under the Compliance category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>

        :param tag_ids: A filter on the data based on this comma-separated list of tag IDs. Example: `tagIds=1234,5678`
        :param parent_tag_ids: A filter on the data based on this comma-separated list of parent tag IDs, for use by orgs with tag hierarchies. Specifying a parent tag will implicitly include all descendent tags of the parent tag. Example: `parentTagIds=345,678`
        :param driver_ids: A filter on the data based on this comma-separated list of driver IDs. Example: `driverIds=1234,5678`
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param limit: The limit for how many objects will be in the response. Default and max for this value is 512 objects.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetHosClocksRequest(
            tag_ids=tag_ids,
            parent_tag_ids=parent_tag_ids,
            driver_ids=driver_ids,
            after=after,
            limit=limit,
        )

        req = self._build_request(
            method="GET",
            path="/fleet/hos/clocks",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getHosClocks",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.HosClocksResponse)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(http_res.text, models.StandardErrorResponse)

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_hos_clocks_async(
        self,
        *,
        tag_ids: Optional[List[str]] = None,
        parent_tag_ids: Optional[List[str]] = None,
        driver_ids: Optional[List[str]] = None,
        after: Optional[str] = None,
        limit: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetHosClocksResponse:
        r"""Get HOS clocks

        Get the current HOS status for all drivers. Note that this includes inactive as well as active drivers. The legacy version of this endpoint can be found at [samsara.com/api-legacy](https://www.samsara.com/api-legacy#operation/getFleetHosLogsSummary).

        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        To use this endpoint, select **Read ELD Compliance Settings (US)** under the Compliance category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>

        :param tag_ids: A filter on the data based on this comma-separated list of tag IDs. Example: `tagIds=1234,5678`
        :param parent_tag_ids: A filter on the data based on this comma-separated list of parent tag IDs, for use by orgs with tag hierarchies. Specifying a parent tag will implicitly include all descendent tags of the parent tag. Example: `parentTagIds=345,678`
        :param driver_ids: A filter on the data based on this comma-separated list of driver IDs. Example: `driverIds=1234,5678`
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param limit: The limit for how many objects will be in the response. Default and max for this value is 512 objects.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetHosClocksRequest(
            tag_ids=tag_ids,
            parent_tag_ids=parent_tag_ids,
            driver_ids=driver_ids,
            after=after,
            limit=limit,
        )

        req = self._build_request_async(
            method="GET",
            path="/fleet/hos/clocks",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getHosClocks",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.HosClocksResponse)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(http_res.text, models.StandardErrorResponse)

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_hos_daily_logs(
        self,
        *,
        driver_ids: Optional[List[str]] = None,
        start_date: Optional[str] = None,
        end_date: Optional[str] = None,
        tag_ids: Optional[str] = None,
        parent_tag_ids: Optional[str] = None,
        driver_activation_status: Optional[
            models.GetHosDailyLogsQueryParamDriverActivationStatus
        ] = models.GetHosDailyLogsQueryParamDriverActivationStatus.ACTIVE,
        after: Optional[str] = None,
        expand: Optional[models.Expand] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetHosDailyLogsResponse:
        r"""Get all driver HOS daily logs

        Get summarized daily Hours of Service charts for the specified drivers.

        The time range for a log is defined by the `driver`'s `eldDayStartHour`. This value is configurable per driver.

        The `startDate` and `endDate` parameters indicate the date range you'd like to retrieve daily logs for. A daily log will be returned if its `startTime` is on any of the days within in this date range (inclusive of `startDate` and `endDate`).

        **Note:** If data is still being uploaded from the Samsara Driver App, it may not be completely reflected in the response from this endpoint. The best practice is to wait a couple of days before querying this endpoint to make sure that all data from the Samsara Driver App has been uploaded.

        If you are using the legacy version of this endpoint and looking for its documentation, you can find it [here](https://www.samsara.com/api-legacy#operation/getFleetDriversHosDailyLogs).

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read ELD Compliance Settings (US)** under the Compliance category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param driver_ids: A filter on the data based on this comma-separated list of driver IDs and externalIds. Example: `driverIds=1234,5678,payroll:4841`
        :param start_date: A start date in YYYY-MM-DD. This is a date only without an associated time. Example: `2019-06-13`. This is a required field
        :param end_date: An end date in YYYY-MM-DD. This is a date only without an associated time. Must be greater than or equal to the start date. Example: `2019-07-21`. This is a required field
        :param tag_ids: A filter on the data based on this comma-separated list of tag IDs. Example: `tagIds=1234,5678`
        :param parent_tag_ids: A filter on the data based on this comma-separated list of parent tag IDs, for use by orgs with tag hierarchies. Specifying a parent tag will implicitly include all descendent tags of the parent tag. Example: `parentTagIds=345,678`
        :param driver_activation_status: If value is `deactivated`, only drivers that are deactivated will appear in the response. This parameter will default to `active` if not provided (fetching only active drivers).  Valid values: `active`, `deactivated`
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param expand: Expands the specified value(s) in the response object. Expansion populates additional fields in an object, if supported. Unsupported fields are ignored. To expand multiple fields, input a comma-separated list.  Valid value: `vehicle`  Valid values: `vehicle`
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetHosDailyLogsRequest(
            driver_ids=driver_ids,
            start_date=start_date,
            end_date=end_date,
            tag_ids=tag_ids,
            parent_tag_ids=parent_tag_ids,
            driver_activation_status=driver_activation_status,
            after=after,
            expand=expand,
        )

        req = self._build_request(
            method="GET",
            path="/fleet/hos/daily-logs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getHosDailyLogs",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.HosDailyLogsGetHosDailyLogsResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsGetHosDailyLogsUnauthorizedErrorResponseBodyData,
            )
            raise models.HosDailyLogsGetHosDailyLogsUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsGetHosDailyLogsNotFoundErrorResponseBodyData,
            )
            raise models.HosDailyLogsGetHosDailyLogsNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsGetHosDailyLogsMethodNotAllowedErrorResponseBodyData,
            )
            raise models.HosDailyLogsGetHosDailyLogsMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsGetHosDailyLogsTooManyRequestsErrorResponseBodyData,
            )
            raise models.HosDailyLogsGetHosDailyLogsTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsGetHosDailyLogsInternalServerErrorResponseBodyData,
            )
            raise models.HosDailyLogsGetHosDailyLogsInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsGetHosDailyLogsNotImplementedErrorResponseBodyData,
            )
            raise models.HosDailyLogsGetHosDailyLogsNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsGetHosDailyLogsBadGatewayErrorResponseBodyData,
            )
            raise models.HosDailyLogsGetHosDailyLogsBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsGetHosDailyLogsServiceUnavailableErrorResponseBodyData,
            )
            raise models.HosDailyLogsGetHosDailyLogsServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsGetHosDailyLogsGatewayTimeoutErrorResponseBodyData,
            )
            raise models.HosDailyLogsGetHosDailyLogsGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsGetHosDailyLogsBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_hos_daily_logs_async(
        self,
        *,
        driver_ids: Optional[List[str]] = None,
        start_date: Optional[str] = None,
        end_date: Optional[str] = None,
        tag_ids: Optional[str] = None,
        parent_tag_ids: Optional[str] = None,
        driver_activation_status: Optional[
            models.GetHosDailyLogsQueryParamDriverActivationStatus
        ] = models.GetHosDailyLogsQueryParamDriverActivationStatus.ACTIVE,
        after: Optional[str] = None,
        expand: Optional[models.Expand] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetHosDailyLogsResponse:
        r"""Get all driver HOS daily logs

        Get summarized daily Hours of Service charts for the specified drivers.

        The time range for a log is defined by the `driver`'s `eldDayStartHour`. This value is configurable per driver.

        The `startDate` and `endDate` parameters indicate the date range you'd like to retrieve daily logs for. A daily log will be returned if its `startTime` is on any of the days within in this date range (inclusive of `startDate` and `endDate`).

        **Note:** If data is still being uploaded from the Samsara Driver App, it may not be completely reflected in the response from this endpoint. The best practice is to wait a couple of days before querying this endpoint to make sure that all data from the Samsara Driver App has been uploaded.

        If you are using the legacy version of this endpoint and looking for its documentation, you can find it [here](https://www.samsara.com/api-legacy#operation/getFleetDriversHosDailyLogs).

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read ELD Compliance Settings (US)** under the Compliance category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param driver_ids: A filter on the data based on this comma-separated list of driver IDs and externalIds. Example: `driverIds=1234,5678,payroll:4841`
        :param start_date: A start date in YYYY-MM-DD. This is a date only without an associated time. Example: `2019-06-13`. This is a required field
        :param end_date: An end date in YYYY-MM-DD. This is a date only without an associated time. Must be greater than or equal to the start date. Example: `2019-07-21`. This is a required field
        :param tag_ids: A filter on the data based on this comma-separated list of tag IDs. Example: `tagIds=1234,5678`
        :param parent_tag_ids: A filter on the data based on this comma-separated list of parent tag IDs, for use by orgs with tag hierarchies. Specifying a parent tag will implicitly include all descendent tags of the parent tag. Example: `parentTagIds=345,678`
        :param driver_activation_status: If value is `deactivated`, only drivers that are deactivated will appear in the response. This parameter will default to `active` if not provided (fetching only active drivers).  Valid values: `active`, `deactivated`
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param expand: Expands the specified value(s) in the response object. Expansion populates additional fields in an object, if supported. Unsupported fields are ignored. To expand multiple fields, input a comma-separated list.  Valid value: `vehicle`  Valid values: `vehicle`
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetHosDailyLogsRequest(
            driver_ids=driver_ids,
            start_date=start_date,
            end_date=end_date,
            tag_ids=tag_ids,
            parent_tag_ids=parent_tag_ids,
            driver_activation_status=driver_activation_status,
            after=after,
            expand=expand,
        )

        req = self._build_request_async(
            method="GET",
            path="/fleet/hos/daily-logs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getHosDailyLogs",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.HosDailyLogsGetHosDailyLogsResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsGetHosDailyLogsUnauthorizedErrorResponseBodyData,
            )
            raise models.HosDailyLogsGetHosDailyLogsUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsGetHosDailyLogsNotFoundErrorResponseBodyData,
            )
            raise models.HosDailyLogsGetHosDailyLogsNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsGetHosDailyLogsMethodNotAllowedErrorResponseBodyData,
            )
            raise models.HosDailyLogsGetHosDailyLogsMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsGetHosDailyLogsTooManyRequestsErrorResponseBodyData,
            )
            raise models.HosDailyLogsGetHosDailyLogsTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsGetHosDailyLogsInternalServerErrorResponseBodyData,
            )
            raise models.HosDailyLogsGetHosDailyLogsInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsGetHosDailyLogsNotImplementedErrorResponseBodyData,
            )
            raise models.HosDailyLogsGetHosDailyLogsNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsGetHosDailyLogsBadGatewayErrorResponseBodyData,
            )
            raise models.HosDailyLogsGetHosDailyLogsBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsGetHosDailyLogsServiceUnavailableErrorResponseBodyData,
            )
            raise models.HosDailyLogsGetHosDailyLogsServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsGetHosDailyLogsGatewayTimeoutErrorResponseBodyData,
            )
            raise models.HosDailyLogsGetHosDailyLogsGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.HosDailyLogsGetHosDailyLogsBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_hos_logs(
        self,
        *,
        tag_ids: Optional[List[str]] = None,
        parent_tag_ids: Optional[List[str]] = None,
        driver_ids: Optional[List[str]] = None,
        start_time: Optional[str] = None,
        end_time: Optional[str] = None,
        after: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetHosLogsResponse:
        r"""Get HOS logs

        Returns HOS logs between a given `startTime` and `endTime`. The logs can be further filtered using tags or by providing a list of driver IDs (including external IDs). The legacy version of this endpoint can be found at [samsara.com/api-legacy](https://www.samsara.com/api-legacy#operation/getFleetHosLogs).

        **Note:** If data is still being uploaded from the Samsara Driver App, it may not be completely reflected in the response from this endpoint. The best practice is to wait a couple of days before querying this endpoint to make sure that all data from the Samsara Driver App has been uploaded.

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        To use this endpoint, select **Read ELD Compliance Settings (US)** under the Compliance category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>

        :param tag_ids: A filter on the data based on this comma-separated list of tag IDs. Example: `tagIds=1234,5678`
        :param parent_tag_ids: A filter on the data based on this comma-separated list of parent tag IDs, for use by orgs with tag hierarchies. Specifying a parent tag will implicitly include all descendent tags of the parent tag. Example: `parentTagIds=345,678`
        :param driver_ids: A filter on the data based on this comma-separated list of driver IDs. Example: `driverIds=1234,5678`
        :param start_time: A start time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param end_time: An end time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetHosLogsRequest(
            tag_ids=tag_ids,
            parent_tag_ids=parent_tag_ids,
            driver_ids=driver_ids,
            start_time=start_time,
            end_time=end_time,
            after=after,
        )

        req = self._build_request(
            method="GET",
            path="/fleet/hos/logs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getHosLogs",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.HosLogsResponse)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(http_res.text, models.StandardErrorResponse)

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_hos_logs_async(
        self,
        *,
        tag_ids: Optional[List[str]] = None,
        parent_tag_ids: Optional[List[str]] = None,
        driver_ids: Optional[List[str]] = None,
        start_time: Optional[str] = None,
        end_time: Optional[str] = None,
        after: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetHosLogsResponse:
        r"""Get HOS logs

        Returns HOS logs between a given `startTime` and `endTime`. The logs can be further filtered using tags or by providing a list of driver IDs (including external IDs). The legacy version of this endpoint can be found at [samsara.com/api-legacy](https://www.samsara.com/api-legacy#operation/getFleetHosLogs).

        **Note:** If data is still being uploaded from the Samsara Driver App, it may not be completely reflected in the response from this endpoint. The best practice is to wait a couple of days before querying this endpoint to make sure that all data from the Samsara Driver App has been uploaded.

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        To use this endpoint, select **Read ELD Compliance Settings (US)** under the Compliance category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>

        :param tag_ids: A filter on the data based on this comma-separated list of tag IDs. Example: `tagIds=1234,5678`
        :param parent_tag_ids: A filter on the data based on this comma-separated list of parent tag IDs, for use by orgs with tag hierarchies. Specifying a parent tag will implicitly include all descendent tags of the parent tag. Example: `parentTagIds=345,678`
        :param driver_ids: A filter on the data based on this comma-separated list of driver IDs. Example: `driverIds=1234,5678`
        :param start_time: A start time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param end_time: An end time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetHosLogsRequest(
            tag_ids=tag_ids,
            parent_tag_ids=parent_tag_ids,
            driver_ids=driver_ids,
            start_time=start_time,
            end_time=end_time,
            after=after,
        )

        req = self._build_request_async(
            method="GET",
            path="/fleet/hos/logs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getHosLogs",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(http_res.text, models.HosLogsResponse)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(http_res.text, models.StandardErrorResponse)

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def get_hos_violations(
        self,
        *,
        driver_ids: Optional[List[str]] = None,
        start_time: Optional[str] = None,
        end_time: Optional[str] = None,
        tag_ids: Optional[str] = None,
        parent_tag_ids: Optional[str] = None,
        types: Optional[List[str]] = None,
        after: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetHosViolationsResponse:
        r"""Get all driver HOS violations

        Get active Hours of Service violations for the specified drivers.

        The day object time range for a violation is defined by the `driver`'s `eldDayStartHour`. This value is configurable per driver.

        The `startTime` and `endTime` parameters indicate the datetime range you'd like to retrieve violations for. A violation will be returned if its `violationStartTime` falls within this datetime range (inclusive of `startTime` and `endTime`)

        **Note:** The following are all the violation types with a short explanation about what each of them means: `californiaMealbreakMissed` (Missed California Meal Break), `cycleHoursOn` (Cycle Limit), `cycleOffHoursAfterOnDutyHours` (Cycle 2 Limit), `dailyDrivingHours` (Daily Driving Limit), `dailyOffDutyDeferralAddToDay2Consecutive` (Daily Off-Duty Deferral: Add To Day2 Consecutive), `dailyOffDutyDeferralNotPartMandatory` (Daily Off-Duty Deferral: Not Part Of Mandatory), `dailyOffDutyDeferralTwoDayDrivingLimit` (Daily Off-Duty Deferral: 2 Day Driving Limit), `dailyOffDutyDeferralTwoDayOffDuty` (Daily Off-Duty Deferral: 2 Day Off Duty), `dailyOffDutyNonResetHours` (Daily Off-Duty Time: Non-Reset), `dailyOffDutyTotalHours` (Daily Off-Duty Time), `dailyOnDutyHours` (Daily On-Duty Limit), `mandatory24HoursOffDuty` (24 Hours of Off Duty required), `restbreakMissed` (Missed Rest Break), `shiftDrivingHours` (Shift Driving Limit), `shiftHours` (Shift Duty Limit), `shiftOnDutyHours` (Shift On-Duty Limit), `unsubmittedLogs` (Missing Driver Certification)

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read ELD Compliance Settings (US)** under the Compliance category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param driver_ids: A filter on the data based on this comma-separated list of driver IDs and externalIds. Example: `driverIds=1234,5678,payroll:4841`
        :param start_time: A start time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param end_time: An end time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param tag_ids: A filter on the data based on this comma-separated list of tag IDs. Example: `tagIds=1234,5678`
        :param parent_tag_ids: A filter on the data based on this comma-separated list of parent tag IDs, for use by orgs with tag hierarchies. Specifying a parent tag will implicitly include all descendent tags of the parent tag. Example: `parentTagIds=345,678`
        :param types: A filter on violations data based on the violation type enum. Supported types: `NONE, californiaMealbreakMissed, cycleHoursOn, cycleOffHoursAfterOnDutyHours, dailyDrivingHours, dailyOffDutyDeferralAddToDay2Consecutive, dailyOffDutyDeferralNotPartMandatory, dailyOffDutyDeferralTwoDayDrivingLimit, dailyOffDutyDeferralTwoDayOffDuty, dailyOffDutyNonResetHours, dailyOffDutyTotalHours, dailyOnDutyHours, mandatory24HoursOffDuty, restbreakMissed, shiftDrivingHours, shiftHours, shiftOnDutyHours, unsubmittedLogs`
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetHosViolationsRequest(
            driver_ids=driver_ids,
            start_time=start_time,
            end_time=end_time,
            tag_ids=tag_ids,
            parent_tag_ids=parent_tag_ids,
            types=types,
            after=after,
        )

        req = self._build_request(
            method="GET",
            path="/fleet/hos/violations",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getHosViolations",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.HosViolationsGetHosViolationsResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosViolationsGetHosViolationsUnauthorizedErrorResponseBodyData,
            )
            raise models.HosViolationsGetHosViolationsUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosViolationsGetHosViolationsNotFoundErrorResponseBodyData,
            )
            raise models.HosViolationsGetHosViolationsNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosViolationsGetHosViolationsMethodNotAllowedErrorResponseBodyData,
            )
            raise models.HosViolationsGetHosViolationsMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosViolationsGetHosViolationsTooManyRequestsErrorResponseBodyData,
            )
            raise models.HosViolationsGetHosViolationsTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosViolationsGetHosViolationsInternalServerErrorResponseBodyData,
            )
            raise models.HosViolationsGetHosViolationsInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosViolationsGetHosViolationsNotImplementedErrorResponseBodyData,
            )
            raise models.HosViolationsGetHosViolationsNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosViolationsGetHosViolationsBadGatewayErrorResponseBodyData,
            )
            raise models.HosViolationsGetHosViolationsBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosViolationsGetHosViolationsServiceUnavailableErrorResponseBodyData,
            )
            raise models.HosViolationsGetHosViolationsServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosViolationsGetHosViolationsGatewayTimeoutErrorResponseBodyData,
            )
            raise models.HosViolationsGetHosViolationsGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.HosViolationsGetHosViolationsBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def get_hos_violations_async(
        self,
        *,
        driver_ids: Optional[List[str]] = None,
        start_time: Optional[str] = None,
        end_time: Optional[str] = None,
        tag_ids: Optional[str] = None,
        parent_tag_ids: Optional[str] = None,
        types: Optional[List[str]] = None,
        after: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GetHosViolationsResponse:
        r"""Get all driver HOS violations

        Get active Hours of Service violations for the specified drivers.

        The day object time range for a violation is defined by the `driver`'s `eldDayStartHour`. This value is configurable per driver.

        The `startTime` and `endTime` parameters indicate the datetime range you'd like to retrieve violations for. A violation will be returned if its `violationStartTime` falls within this datetime range (inclusive of `startTime` and `endTime`)

        **Note:** The following are all the violation types with a short explanation about what each of them means: `californiaMealbreakMissed` (Missed California Meal Break), `cycleHoursOn` (Cycle Limit), `cycleOffHoursAfterOnDutyHours` (Cycle 2 Limit), `dailyDrivingHours` (Daily Driving Limit), `dailyOffDutyDeferralAddToDay2Consecutive` (Daily Off-Duty Deferral: Add To Day2 Consecutive), `dailyOffDutyDeferralNotPartMandatory` (Daily Off-Duty Deferral: Not Part Of Mandatory), `dailyOffDutyDeferralTwoDayDrivingLimit` (Daily Off-Duty Deferral: 2 Day Driving Limit), `dailyOffDutyDeferralTwoDayOffDuty` (Daily Off-Duty Deferral: 2 Day Off Duty), `dailyOffDutyNonResetHours` (Daily Off-Duty Time: Non-Reset), `dailyOffDutyTotalHours` (Daily Off-Duty Time), `dailyOnDutyHours` (Daily On-Duty Limit), `mandatory24HoursOffDuty` (24 Hours of Off Duty required), `restbreakMissed` (Missed Rest Break), `shiftDrivingHours` (Shift Driving Limit), `shiftHours` (Shift Duty Limit), `shiftOnDutyHours` (Shift On-Duty Limit), `unsubmittedLogs` (Missing Driver Certification)

        <b>Rate limit:</b> 5 requests/sec (learn more about rate limits <a href=\"https://developers.samsara.com/docs/rate-limits\" target=\"_blank\">here</a>).

        To use this endpoint, select **Read ELD Compliance Settings (US)** under the Compliance category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>


        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        :param driver_ids: A filter on the data based on this comma-separated list of driver IDs and externalIds. Example: `driverIds=1234,5678,payroll:4841`
        :param start_time: A start time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param end_time: An end time in RFC 3339 format. Defaults to now if not provided. Millisecond precision and timezones are supported. (Examples: 2019-06-13T19:08:25Z, 2019-06-13T19:08:25.455Z, OR 2015-09-15T14:00:12-04:00).
        :param tag_ids: A filter on the data based on this comma-separated list of tag IDs. Example: `tagIds=1234,5678`
        :param parent_tag_ids: A filter on the data based on this comma-separated list of parent tag IDs, for use by orgs with tag hierarchies. Specifying a parent tag will implicitly include all descendent tags of the parent tag. Example: `parentTagIds=345,678`
        :param types: A filter on violations data based on the violation type enum. Supported types: `NONE, californiaMealbreakMissed, cycleHoursOn, cycleOffHoursAfterOnDutyHours, dailyDrivingHours, dailyOffDutyDeferralAddToDay2Consecutive, dailyOffDutyDeferralNotPartMandatory, dailyOffDutyDeferralTwoDayDrivingLimit, dailyOffDutyDeferralTwoDayOffDuty, dailyOffDutyNonResetHours, dailyOffDutyTotalHours, dailyOnDutyHours, mandatory24HoursOffDuty, restbreakMissed, shiftDrivingHours, shiftHours, shiftOnDutyHours, unsubmittedLogs`
        :param after: If specified, this should be the endCursor value from the previous page of results. When present, this request will return the next page of results that occur immediately after the previous page of results.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.GetHosViolationsRequest(
            driver_ids=driver_ids,
            start_time=start_time,
            end_time=end_time,
            tag_ids=tag_ids,
            parent_tag_ids=parent_tag_ids,
            types=types,
            after=after,
        )

        req = self._build_request_async(
            method="GET",
            path="/fleet/hos/violations",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="getHosViolations",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=[
                "401",
                "404",
                "405",
                "429",
                "4XX",
                "500",
                "501",
                "502",
                "503",
                "504",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.HosViolationsGetHosViolationsResponseBody
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosViolationsGetHosViolationsUnauthorizedErrorResponseBodyData,
            )
            raise models.HosViolationsGetHosViolationsUnauthorizedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "404", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosViolationsGetHosViolationsNotFoundErrorResponseBodyData,
            )
            raise models.HosViolationsGetHosViolationsNotFoundErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "405", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosViolationsGetHosViolationsMethodNotAllowedErrorResponseBodyData,
            )
            raise models.HosViolationsGetHosViolationsMethodNotAllowedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "429", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosViolationsGetHosViolationsTooManyRequestsErrorResponseBodyData,
            )
            raise models.HosViolationsGetHosViolationsTooManyRequestsErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosViolationsGetHosViolationsInternalServerErrorResponseBodyData,
            )
            raise models.HosViolationsGetHosViolationsInternalServerErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "501", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosViolationsGetHosViolationsNotImplementedErrorResponseBodyData,
            )
            raise models.HosViolationsGetHosViolationsNotImplementedErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "502", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosViolationsGetHosViolationsBadGatewayErrorResponseBodyData,
            )
            raise models.HosViolationsGetHosViolationsBadGatewayErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "503", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosViolationsGetHosViolationsServiceUnavailableErrorResponseBodyData,
            )
            raise models.HosViolationsGetHosViolationsServiceUnavailableErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "504", "application/json"):
            response_data = utils.unmarshal_json(
                http_res.text,
                models.HosViolationsGetHosViolationsGatewayTimeoutErrorResponseBodyData,
            )
            raise models.HosViolationsGetHosViolationsGatewayTimeoutErrorResponseBody(
                data=response_data
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(
                http_res.text,
                models.HosViolationsGetHosViolationsBadRequestErrorResponseBody,
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def set_current_duty_status(
        self,
        *,
        driver_id: int,
        duty_status: str,
        location: Optional[str] = None,
        remark: Optional[str] = None,
        status_change_at_ms: Optional[float] = None,
        vehicle_id: Optional[float] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[str]:
        r"""Set a duty status for a specific driver

        <n class=\"warning\">
        <nh>
        <i class=\"fa fa-exclamation-circle\"></i>
        This endpoint is still on our legacy API.
        </nh>
        </n>

        Set an individual driver’s current duty status to 'On Duty' or 'Off Duty'.

        To ensure compliance with the ELD Mandate, only  authenticated drivers can make direct duty status changes on their own logbook. Any system external to the Samsara Driver App using this endpoint to trigger duty status changes must ensure that such changes are only triggered directly by the driver in question and that the driver has been properly authenticated. This endpoint should not be used to algorithmically trigger duty status changes nor should it be used by personnel besides the driver to trigger duty status changes on the driver’s behalf. Carriers and their drivers are ultimately responsible for maintaining accurate logs and should confirm that their use of the endpoint is compliant with the ELD Mandate.

        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        To use this endpoint, select **Write ELD Hours of Service (US)** under the Compliance category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>

        :param driver_id: ID of the driver for whom the duty status is being set.
        :param duty_status: Duty status to set the driver to. The only supported values are 'ON_DUTY' and 'OFF_DUTY'.
        :param location: Location to associate the duty status change with.
        :param remark: Remark to associate the duty status change with.
        :param status_change_at_ms: Timestamp that the duty status will begin at specified in milliseconds UNIX time. Defaults to the current time if left blank. This can only be set to up to 8 hours in the past.
        :param vehicle_id: Vehicle ID to associate the duty status change with.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.SetCurrentDutyStatusRequest(
            driver_id=driver_id,
            inline_object_1=models.InlineObject1(
                duty_status=duty_status,
                location=location,
                remark=remark,
                status_change_at_ms=status_change_at_ms,
                vehicle_id=vehicle_id,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/v1/fleet/drivers/{driver_id}/hos/duty_status",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.inline_object_1,
                False,
                True,
                "json",
                Optional[models.InlineObject1],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="setCurrentDutyStatus",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "*"):
            return None
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(http_res.text, str)

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def set_current_duty_status_async(
        self,
        *,
        driver_id: int,
        duty_status: str,
        location: Optional[str] = None,
        remark: Optional[str] = None,
        status_change_at_ms: Optional[float] = None,
        vehicle_id: Optional[float] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[str]:
        r"""Set a duty status for a specific driver

        <n class=\"warning\">
        <nh>
        <i class=\"fa fa-exclamation-circle\"></i>
        This endpoint is still on our legacy API.
        </nh>
        </n>

        Set an individual driver’s current duty status to 'On Duty' or 'Off Duty'.

        To ensure compliance with the ELD Mandate, only  authenticated drivers can make direct duty status changes on their own logbook. Any system external to the Samsara Driver App using this endpoint to trigger duty status changes must ensure that such changes are only triggered directly by the driver in question and that the driver has been properly authenticated. This endpoint should not be used to algorithmically trigger duty status changes nor should it be used by personnel besides the driver to trigger duty status changes on the driver’s behalf. Carriers and their drivers are ultimately responsible for maintaining accurate logs and should confirm that their use of the endpoint is compliant with the ELD Mandate.

        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        To use this endpoint, select **Write ELD Hours of Service (US)** under the Compliance category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>

        :param driver_id: ID of the driver for whom the duty status is being set.
        :param duty_status: Duty status to set the driver to. The only supported values are 'ON_DUTY' and 'OFF_DUTY'.
        :param location: Location to associate the duty status change with.
        :param remark: Remark to associate the duty status change with.
        :param status_change_at_ms: Timestamp that the duty status will begin at specified in milliseconds UNIX time. Defaults to the current time if left blank. This can only be set to up to 8 hours in the past.
        :param vehicle_id: Vehicle ID to associate the duty status change with.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.SetCurrentDutyStatusRequest(
            driver_id=driver_id,
            inline_object_1=models.InlineObject1(
                duty_status=duty_status,
                location=location,
                remark=remark,
                status_change_at_ms=status_change_at_ms,
                vehicle_id=vehicle_id,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/v1/fleet/drivers/{driver_id}/hos/duty_status",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.inline_object_1,
                False,
                True,
                "json",
                Optional[models.InlineObject1],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="setCurrentDutyStatus",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "*"):
            return None
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(http_res.text, str)

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def v1get_fleet_hos_authentication_logs(
        self,
        *,
        driver_id: int,
        start_ms: int,
        end_ms: int,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.V1getFleetHosAuthenticationLogsResponse:
        r"""Get HOS signin and signout

        <n class=\"warning\">
        <nh>
        <i class=\"fa fa-exclamation-circle\"></i>
        This endpoint is still on our legacy API.
        </nh>
        </n>

        Get the HOS (hours of service) signin and signout logs for the specified driver. The response includes 4 fields that are now deprecated.

        **Note:** If data is still being uploaded from the Samsara Driver App, it may not be completely reflected in the response from this endpoint. The best practice is to wait a couple of days before querying this endpoint to make sure that all data from the Samsara Driver App has been uploaded.

        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        To use this endpoint, select **Read ELD Hours of Service (US)** under the Compliance category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>

        :param driver_id: Driver ID to query.
        :param start_ms: Beginning of the time range, specified in milliseconds UNIX time.
        :param end_ms: End of the time range, specified in milliseconds UNIX time.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.V1getFleetHosAuthenticationLogsRequest(
            driver_id=driver_id,
            start_ms=start_ms,
            end_ms=end_ms,
        )

        req = self._build_request(
            method="GET",
            path="/v1/fleet/hos_authentication_logs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="V1getFleetHosAuthenticationLogs",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.V1HosAuthenticationLogsResponse
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(http_res.text, str)

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def v1get_fleet_hos_authentication_logs_async(
        self,
        *,
        driver_id: int,
        start_ms: int,
        end_ms: int,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.V1getFleetHosAuthenticationLogsResponse:
        r"""Get HOS signin and signout

        <n class=\"warning\">
        <nh>
        <i class=\"fa fa-exclamation-circle\"></i>
        This endpoint is still on our legacy API.
        </nh>
        </n>

        Get the HOS (hours of service) signin and signout logs for the specified driver. The response includes 4 fields that are now deprecated.

        **Note:** If data is still being uploaded from the Samsara Driver App, it may not be completely reflected in the response from this endpoint. The best practice is to wait a couple of days before querying this endpoint to make sure that all data from the Samsara Driver App has been uploaded.

        **Submit Feedback**: Likes, dislikes, and API feature requests should be filed as feedback in our <a href=\"https://forms.gle/zkD4NCH7HjKb7mm69\" target=\"_blank\">API feedback form</a>. If you encountered an issue or noticed inaccuracies in the API documentation, please <a href=\"https://www.samsara.com/help\" target=\"_blank\">submit a case</a> to our support team.

        To use this endpoint, select **Read ELD Hours of Service (US)** under the Compliance category when creating or editing an API token. <a href=\"https://developers.samsara.com/docs/authentication#scopes-for-api-tokens\" target=\"_blank\">Learn More.</a>

        :param driver_id: Driver ID to query.
        :param start_ms: Beginning of the time range, specified in milliseconds UNIX time.
        :param end_ms: End of the time range, specified in milliseconds UNIX time.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url

        request = models.V1getFleetHosAuthenticationLogsRequest(
            driver_id=driver_id,
            start_ms=start_ms,
            end_ms=end_ms,
        )

        req = self._build_request_async(
            method="GET",
            path="/v1/fleet/hos_authentication_logs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="V1getFleetHosAuthenticationLogs",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return utils.unmarshal_json(
                http_res.text, models.V1HosAuthenticationLogsResponse
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/json"):
            return utils.unmarshal_json(http_res.text, str)

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise models.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )
